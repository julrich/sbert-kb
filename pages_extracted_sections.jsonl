{"title": "Integrations - making your interface come alive!", "heading": "Leverage rich integrations...", "content": "... to ease setup and everyday tasks Focus on the stuff that really matters: While having a solid Design System is the necessary start, without projects using it this is theoretical value. This is why kickstartDS comes with ready-to-use integrations and adapters for a lot of common scenarios you might encounter while thinking about a project - like your main marketing site, your blog or the way you want to integrate design decisions into an automated process. Jump directly to integrations for:", "tokens": 100}
{"title": "Integrations - making your interface come alive!", "heading": "Immediate integration with your favorite CMS backend", "content": "... because you shouldn't start from zero here, either Why good integrations matter: Instead of doing the legwork to setup a project with these headless CMS yourself, you can use our plugins and starters to hit the ground running... while also having your Design System automatically integrated from the get-go. Sanity for structured content Sanitys approach to structured data gels really well with our way of creating components. The existing component JSON Schemas can be re-used with our tooling to create Sanity configurations in a generic way - always in sync with your Design System, without additional, manual overhead! WordPress for blogs WordPress shines for blog content, and many editors have a really solid working knowledge of it? By using WordPress in a headless way (using wpgraphql) with our Gatsby theme, you can leverate the editorial experience without losing out on a modern, performant and secure web stack! Marketing sites with Contentful When building bigger pages, especially those with more of a page-builder like marketing experience, Contentful is a great solution to empower your digital team. It's also one of the contenders offering deep solutions for customers with enterprise needs.", "tokens": 248}
{"title": "Integrations - making your interface come alive!", "heading": "Generators and Jamstack", "content": "... multiplying existing value What a generator can do for you: Your Design System already has a really good knowledge about what a component is, how it is structured and how it behaves. We use that knowledge to provide a Gatsby theme, that already includes everything a website needs (for SEO, performance, etc). We even already have transformers for that theme for WordPress, Netlify CMS, Contentful, MDX. And if you're using Next.js we have some plugins to use your components in a performant way there too, without writing glue code yourself. Finally: being able to use our GraphQL tooling to generate TypeScript types for your components and GraphQL types and fragments for usage in Gatsby and Next, all while including component documentation automatically. Plugin and starter for Next.js Use our starter to have a project running in mere minutes, or use our plugins directly to configure everything the way you like... while still profiting from work already done. All components are completely SSR-compatible, too. Complete Gatsby theme Our theme automates everything related to rendering your frontend (SEO, performance, etc), while also providing a common interface to implement your own transformers and resolvers. Or you just re-use one of those we've already written for: WordPress, Netlify CMS, Contentful, MDX GraphQL types and fragments Based on our component API we have tooling (based on GraphQL Tools) to automatically generate types and fragments for GraphQL. This can be the perfect building block to creating your shared API between frontend and backend, and, for example, powers the core of our Gatsby theme.", "tokens": 345}
{"title": "Integrations - making your interface come alive!", "heading": "Connect to Design Tooling", "content": "... to help bridge the dev-design divide How Design Tokens enable better processes: Tokens are the perfect starting ground when establishing shared processes and responsibilities between designers and developers, as they encode the most atomic design decisions of your Design System. Connecting design tools like Figma through Style Dictionary, or using complementary services to manage your Design System like Backlight, helps set up a baseline for your team, without requiring you to do everything by yourself! Style Dictionary Style Dictionary is a tool developed by Amazon to help with establishing a dependable structure for your Design Tokens. This includes defining them in a well-defined way (JSON) and then converting them to different target formats: CSS Properties, iOS definitions or themes. All our tokens are defined in a Style Dictionary. Figma Figma is currently taking the design space by storm. We offer a Figma template with all our semantic Design Tokens encoded in a visual way. You can even change values in Figma, and use one of our connectors to integrate them back into your code base automatically... for example as part of your CI/CD Backlight Backlight can function as your teams whole-in-one platform for Design System management / DesignOps. kickstartDS is wholly compatible with Backlight, and its features like the Style Dictionary integration, bundling and packaging, etc. You can even use our starter to cut even more corners in getting your first Design System release live!.", "tokens": 290}
{"title": "Integrations - making your interface come alive!", "heading": "Integration with", "content": "Storybook is the de-facto standard for writing high-quality, isolated components. This is why we've not only invested a lot of time on making sure that everything between kickstartDS and Storybook integrates as nicely as possible, but also already written two addons ourselves! Controls Interact with our rich component API through automatically configured Storybook controls. Tokens View and change component tokens directly in Storybook with our own Storybook addon. Composition We enable Storybook composition, meaning you'll always get our docs inside your Storybooks. JSON Schema Inspect the JSON Schema defining the component APIs, or change values with typed auto-complete.", "tokens": 134}
{"title": "Integrations - making your interface come alive!", "heading": "Derivatives", "content": "... generate low-code integration points Re-use your tokens to generate themes for other frameworks and libraries. Bootstrap Generate a Bootstrap theme automatically, based on our semantic Design Tokens by utilizing the Style Dictionary integration. Themes can be a great way to achieve a 80% solution immediately; and build from there. Material UI / MUI As with the Bootstrap theme, it makes a lot of sense to leverage your existing Design Tokens and our Style Dictionary configuration to automatically generate a fitting Material UI / MUI theme, even as part of your connected CI/CD in a continuous way!", "tokens": 122}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Install", "content": "Storybook We start by initializing Storybook using their CLI. We call it with npx, which runs the command ( Storybook) without actually installing the dependency to our project. And as we won't be using their included examples, we just remove those immediately, too: _2npx storybook init_2rm -rf src/stories Let's have a look at our package.json, after having added Storybook: Storybook dependencies Those are the dependencies added through using npx storybook init. They ensure Storybook itself can be built for development and production. It also includes Storybooks Essential addon, adding recommended addons by default: https://storybook.js.org/docs/react/essentials/introduction", "tokens": 153}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "New", "content": "scripts entries Next to the dependencies, two scripts entries were added by the Storybook init: Storybook: to start your Storybookin development / watch mode build-storybook: to build a production ready, deployable version of your Storybook Add the following lines to your .gitignore to exclude locally built versions of Storybook (e.g. by calling yarn build-storybook):", "tokens": 82}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "General configuration", "content": "For this we'll be looking at the .storybook folder, automatically created for us by npx storybook init. It contains all general configuration to make a Storybook your own, and allows to really adapt it to your use case. We'll set up some integrations that are convenient to use, especially when working with kickstartDS. The folder contains two files for now: .storybook/main.js .storybook/preview.js main.js configuration This file contains configuration for Storybook itself... which addons to load, additional addon configuration, Webpack build & compile configuration, and so on. We'll continue building this up while adding addons in the next steps. For a detailed overview, have a look at Storybooks documentation.", "tokens": 157}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Add glob for documentation", "content": "We'll be adding a few pages of documentation to test configuration, but these can also serve as the perfect starting point and orientation for your own growing documentation. For Storybook to pick up those pages, we have to tell it where those will be found. We'll be creating that folder docs/ later.", "tokens": 67}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Adding a", "content": "Welcome page As promised we add a Welcome page now, to verify configuration... and to have something in Storybook to display in the browser. Create a folder docs at the root of your repository, and add a file welcome.stories.mdx to it. .mdx is an extension of the popular Markdown format, allowing the use of React / JSX components as part of your documentation. In the context of kickstartDS this also means being able to use all of your components as part of your Storybook documentation, too. For example having nice hero images on pages important to you! Learn more about the .mdx format here. _2mkdir -p docs_2touch docs/welcome.stories.mdx Add the following content to it:", "tokens": 159}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Define story title and category", "content": "We define a title and category for our Welcome page by importing and using Meta from @storybook/addon-docs, a component provided to us by Storybook. This would also be a first example on the benefits of using .mdx for documentation.", "tokens": 57}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Some initial dummy content", "content": "The rest of the file just contains some dummy content to start. Feel free to replace this with something more meaningful, but you'll probably want to revisit this page later, anyways!", "tokens": 41}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Verifying configuration", "content": "It's not much, yet, but we can start our Storybook now to see our Welcome page in action: _1yarn storybook This should automatically open Storybook in your browser of choice. Next to displaying your first page (ðŸ™Œ), there's something interesting that happened! As part of the left sidebar, and under your initially opened Welcome page, there'll be a section titled @kickstartds/base. This gets shown because we've added @kickstartds/base as a dependency before. kickstartDS uses Storybook composition to always include the base documentation (in the correct version used by your Design System) to your Storybook, as a handy reference! Design Token integration Next up is adding some glue code to have our Design Token set nicely integrated with Storybook. We can start by copying some stories provided by kickstartDS (those are the same that can be seen here).", "tokens": 187}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Add", "content": "storybook-design-token addon For Design Token documentation we also use storybook-design-token as an addon. Mainly for its DesignTokenDocBlock component, which helps in rendering the pages we've copied. So we also install that, too: _2cp -r node_modules/@kickstartds/core/lib/design-tokens docs/tokens_2yarn add -D storybook-design-token But if you start your Storybook now ( yarn storybook), you'll be greeted by empty pages. That's because we've not set up the actual Design Token integration with Storybook / our Style Dictionary, yet.", "tokens": 140}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Integrate with", "content": "Style Dictionary As the storybook-design-token addon needs our tokens in a specific format (read more here), we adjust our Style Dictionary configuration in sd.config.cjs to include the provided Storybook configuration. We also tell it to put those Storybook specific files into our already existing src/token directory: With that change, re-build your Design Token set: _1yarn build-tokens You'll notice it now writes two additional files for you, specifically for the Storybook integration:", "tokens": 107}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Annotated", "content": "tokens.css Those are all of our Design Token converted to CSS custom properties (as with src/token/tokens.css), but with the correct storybook-design-token presenters already added. icons.svg icon collection Contains a collection of all used icons. Similarly to before, they just get annotated with the correct presenters for storybook-design-token for Storybook. The file gets picked up by the addon automatically, we don't need to add any additional configuration. 43yarn run v1.22.18_43$ kickstartDS tokens compile_43 _  _  _ 43| | (_) | | _| |_  _  __| || _ \\/ |43| |/ / |/ | |/ / | __/ ` | '| | | | _ _43| <| | (| <_ \\ || (| | | | || || |) |43||__|_||____/__,|| _|/|_/43_43__/\\\\\\\\__/\\___/\\\\\\\\\\__43_/\\\\////////__\\/\\_____________\\/////\\\\///_________43_________/\\\\/___________\\/\\_________________\\/\\____________43________/\\_____________\\/\\_________________\\/\\____________43_______\\/\\_____________\\/\\_________________\\/\\____________43_______\\//\\____________\\/\\_________________\\/\\____________43________\\///\\__________\\/\\_________________\\/\\____________43__/\\____\\////\\\\\\\\_\\/\\\\\\\\\\\\\\_/\\\\\\\\\\_/\\__43\\///__\\/////////\\///////////////\\///////////__\\///___43_43Version: 1.0.0_43For more information visit:_43https://www.kickstartDS.com/docs/intro/cli_43_43Starting..._43[kickstartDS: general] [info]: welcome to the kickstartDS CLI_43[kickstartDS: tokens/compile] starting: compile command with compile variable compile-task_43[1/1] [compile: check] [info]: checking prerequesites before starting_43[1/1] [compile: check] [info]: prerequesites met, starting_43[compile: cleanup] [info]: cleaning up temp dir /tmp/tokens-compile-compile-task before starting command_43[compile: cleanup] [info]: finished cleaning up temp dir /tmp/tokens-compile-compile-task before starting command_43[1/1] [compile: compile] [info]: running the compile subtask_43[1/1] [compile: compile] [info]: getting Style Dictionary from token files_43[1/1] [compile: compile] [info]: compiling Style Dictionary to needed CSS and assets_43_43css_43âœ”ï¸Ž src/token/tokens.css_43_43storybook_43âœ”ï¸Ž src/token/storybook/tokens.css_43âœ”ï¸Ž src/token/storybook/icons.svg_43[1/1] [compile: compile] [info]: copying generated CSS and assets to local folder_43[1/1] [compile: compile] [info]: finished running the compile subtask successfully_43[kickstartDS: tokens/compile] finished: compile command with compile variable compile-task_43Done in 1.08s.", "tokens": 757}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Compile", "content": ".storybook/manager.scss We add a script entry called sass-manager, which when called will compile our Sass to a regular CSS file (placed in static/manager.css) to be read by Storybook.", "tokens": 50}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Watch mode for", "content": ".storybook/manager.scss And while we're at it, we'll also add a watch task that can be used in development. This rebuilds your changes to manager.scss live, and triggers a reload in your browser subsequently.", "tokens": 54}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Finalizing", "content": "Design Token integration steps To get Storybook to pick up our static folder when run / compiled, and thus above relative reference to work, we also need to tell Storybook about it in .storybook/main.js. Further we have to add the storybook-design-token addon to the addons array. The designTokenGlob tells it where to find our token definitions (the annotated token.css from before): Finally, we'll disable the storybook-design-token addon in Canvas views. It's output there is redundant when having explicit pages for Design Token, and tends to be a bit noisy in the context of a singular component, anyway. Learn more about that option (and other ones) in the official addon documentation. As this is an option concerned with the general rendering of a Story, the change will have to be made in .storybook/preview.js: If you re-start, or re-open, your Storybook now ( yarn storybook), you'll be greeted by all your glorious Design Token. Neatly categorized by category and semantic meaning!", "tokens": 227}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Empty tables in Firefox?", "content": "This was a bug with the storybook-design-token addon, see this issue. This is fixed starting with version 2.8.0 of the addon. If you're affected, just update your version to ^2.8.0 or higher in your package.json, to fix the addon! We'll add those additional files generated based on our Design Token set to our .gitignore now:", "tokens": 88}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Adding", "content": "ing .storybook/themes.js Create the file .storybook/themes.js... _1touch .storybook/themes.js ... and add the following content: We import the create function from Storybook and our token. With those we create a new theme, with light as the base. We won't go into detail about the specific token applications now, but feel free to adjust brandTitle and brandUrl to your liking! brandImage will be added next... Create a folder static on your project root now: _1mkdir -p static For this to work, we add our logo to the static/ directory created before, as logo.svg. If you don't have a fitting logo laying around now, feel free to just use ours (right click > save as).", "tokens": 167}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Add a fitting", "content": "a fitting favicon Our final addition for this section includes changing .storybook/manager-head.html again. Add the following lines to it: This adds a good looking, custom favicon to our Storybook when opened in the browser, which really helps to find your own Design System... in a sea of tabs ðŸ˜…. The configuration expects the files favicon/favicon.ico and favicon/favicon-192-192.png to be placed in our static/ folder, like it was the case for logo.svg before. Create the sub directory... _1mkdir -p static/favicon ... and place your files inside. If you need something to continue, feel free to use our favicon.ico (right click > save as) and favicon-192-192.png (right click > save as) for now!", "tokens": 183}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Transpile", "content": "@kickstartDS components Base components installed as part of @kickstartDS dependencies (e.g. @kickstartDS/base) are placed in your node_modules after installation. For those components to be compatible with Storybook, and its build & compilation pipeline, we need to ensure that they get transpiled (like your local code automatically is). Add the following webpackFinal configuration to .storybook/main.js: This sets up everything needed to import components from @kickstartDS (e.g. import { Button } from \"@kickstartds/base/lib/button\"). First we add exemptions to the babel-loader for JavaScript code transpilation, which normally ignores code in node_modules. Additionally we add loaders for CSS / SCSS, allow includes from node_modules, configure the path our code lives in, and configure mainFields (learn about them here). Read more about Storybooks Webpack builder, or Webpack in general, for details.", "tokens": 207}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Adding a demo", "content": "demo Button To test our Storybook setup and integration actually works, we add a Button to our Welcome page. First we import the Button component from @kickstartds/base/lib/button, to then add it to the end of the page with a label of \"Learn more\". To see all available options for such a Button component have a look at our Storybook. If not still running, start your Storybook again now ( yarn storybook), and browse to the Welcome page. You should be greeted by your newly added Button there. But there's something missing. It's not looking quite right, yet!", "tokens": 130}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Add missing styles in", "content": "missing styles in preview.js We need some base styles and JavaScript provided by @kickstartds/base, and our own Design Token set, the one converted to CSS custom properties in src/token/tokens.css. Add the following lines to your .storybook/preview.js: Re-start Storybook to revisit the Welcome page. Everything should be looking as expected now!", "tokens": 86}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Adding an", "content": "n Icon to our Button As a small motivation for the next section, change the Button markup in docs/welcome.stories.jsx slightly: We add an Icon to the button using iconAfter (you can use iconAfter or iconBefore, or both!). To see a list of available Icons you can have a look at your Storybook. It should have a page titled Icons in the Design Tokens category. This has all of your .svg icons compiled, all those are possible inputs for icon here. To see all options available on a Button, have a look at its documentation in Storybook (either in our docs, or locally through the composed docs in your sidebar). If you re-check your Welcome page in the browser again now, you'll see the button having space reserved for an Icon. But the Icon itself is still missing. This is because we haven't included our Icon Sprite for component previews in Storybook, yet. The only reason they're successfully displayed on your Icons page currently, is that the storybook-design-token addon is picking them up using its own loader. Let's add our Icon Sprite to Storybook for real, now!", "tokens": 242}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Integrate", "content": "Icons with Storybook previews Instead of loading a bunch of single files per icon, we encourage compiling all your SVGs into one sprite. We offer different output formats for that through the pre-configured Style Dictionary in use (SVG, HTML, React). This can be included once in the page, and the elements will just be referenced. Learn more about sprites with  and  on MDN. As with other changes that had to do with how Storybook renders our own components (in a preview context), we will need to adjust .storybook/preview.js again to integrate kickstartDS and Storybook: We wrap Storybooks story rendering in two places. Firstly we import the default DocsContainer from @storybook/addon-docs and our Icons from ../src/token/icons/IconSprite, to then ensure that every time a docs page is rendered, our Icons get included there, too. Secondly we add our first decorator to the decorators array, also adding our imported Icons. This one is concerned with all the other story previews there are, read more about decorators here. You might have stumbled over our Icons import above: import IconSprite from \"../src/token/icons/IconSprite\". That file doesn't actually exist (yet)! You might also recall how we've added annotated Design Token before, by adding a new transform to our Style Dictionary configuration. We'll now add another transform to it that takes our Icons and converts them to a JSX component-variant of our IconSprite, ready to be imported in .storybook/preview.js: And, you know the drill by now, after changing our sd.config.cjs we'll want to re-compile our Style Dictionary... 1yarn build-tokens ... to find a new output for jsx in the log, written to src/token/icons/IconSprite.js, as referenced by .storybook/preview.js: _49yarn run v1.22.18_49$ kickstartDS tokens compile_49 _  _  _ 49| | (_) | | _| |_  _  __| || _ \\/ |49| |/ / |/ | |/ / | __/ ` | '| | | | _ _49| <| | (| <_ \\ || (| | | | || || |) |49||__|_||____/__,|| _|/|_/49_49__/\\\\\\\\__/\\___/\\\\\\\\\\__49_/\\\\////////__\\/\\_____________\\/////\\\\///_________49_________/\\\\/___________\\/\\_________________\\/\\____________49________/\\_____________\\/\\_________________\\/\\____________49_______\\/\\_____________\\/\\_________________\\/\\____________49_______\\//\\____________\\/\\_________________\\/\\____________49________\\///\\__________\\/\\_________________\\/\\____________49__/\\____\\////\\\\\\\\_\\/\\\\\\\\\\\\\\_/\\\\\\\\\\_/\\__49\\///__\\/////////\\///////////////\\///////////__\\///___49_49Version: 1.0.0_49For more information visit:_49https://www.kickstartDS.com/docs/intro/cli_49_49Starting..._49[kickstartDS: general] [info]: welcome to the kickstartDS CLI_49[kickstartDS: tokens/compile] starting: compile command with compile variable compile-task_49[1/1] [compile: check] [info]: checking prerequesites before starting_49[1/1] [compile: check] [info]: prerequesites met, starting_49[compile: cleanup] [info]: cleaning up temp dir /tmp/tokens-compile-compile-task before starting command_49[compile: cleanup] [info]: finished cleaning up temp dir /tmp/tokens-compile-compile-task before starting command_49[1/1] [compile: compile] [info]: running the compile subtask_49[1/1] [compile: compile] [info]: getting Style Dictionary from token files_49[1/1] [compile: compile] [info]: compiling Style Dictionary to needed CSS and assets_49_49css_49âœ”ï¸Ž src/token/tokens.css_49_49jsx_49âœ”ï¸Ž src/token/icons/IconSprite.js_49_49storybook_49âœ”ï¸Ž src/token/storybook/tokens.css_49âœ”ï¸Ž src/token/storybook/icons.svg_49_49js_49âœ”ï¸Ž src/token/storybook/tokens.js_49[1/1] [compile: compile] [info]: copying generated CSS and assets to local folder_49[1/1] [compile: compile] [info]: finished running the compile subtask successfully_49[kickstartDS: tokens/compile] finished: compile command with compile variable compile-task_49Done in 1.49s. (Re-)open your Storybook now and change to the Welcome page. You should be greeted by a Button with its Icon visible, as configured in the component props! Like before, we make sure to include the newly generated file in our .gitignore:", "tokens": 1166}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Install remaining addons", "content": "remaining addons Like the last step, this one will also mostly be done in preparation. We add some more addons, that each add a specific view of your components to Storybook: HTMLrendering addon JSON Schemaaddon Component Tokenaddon This will give you a great overview of all aspects that make up a component in a Design System in general, and with kickstartDS specifically. Especially helpful while adding components in the next main chapter of this guide! First add the addons to your project: _1yarn add -D @kickstartds/storybook-addon-component-tokens @kickstartds/storybook-addon-jsonschema @whitespace/storybook-addon-html@git+https://github.com/lmestel/storybook-addon-html.git", "tokens": 176}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Fork of @whitespace/storybook-addon-html", "content": "We currently need a fork of @whitespace/storybook-addon-html, because the original version of the addon just takes the HTML from the browser. This is problematic, because it means that markup might already be manipulated by client-side JavaScript (e.g. some classes being added). For our use, copy & paste of the initial HTML, we've switched the addon to use Reacts SSR Renderer. To activate those addons, we need to add them to .storybook/main.js, too. They don't need any further configuration:", "tokens": 121}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Review changes", "content": "Let us review our package.json again now, it's starting to grow already: HTML rendering addon We use @whitespace/storybook-addon-html to add a tab to every component Canvas sidebar, where you can copy the currently configured component as a plain HTML component. Design Token addon For Design Token documentation we use storybook-design-token. Mainly for its DesignTokenDocBlock component, which helps rendering the pages we'll create to display our Design Token set. JSON Schema addon We use our own @kickstartds/storybook-addon-jsonschema to display our component structure / API in a Canvas tab, alongside the component. Read more about it on our dedicated integration page. Component Token addon For this we use another Canvas and tab based addon we've written ourselves, to visualize your Component Token: @kickstartds/storybook-addon-component-token. Especially helps discovering the token layering applied to a component. Read more about it on our dedicated integration page.", "tokens": 212}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Result", "content": "With that, we've successfully added Storybook to our Design System, integrated it with our Design Token / Style Dictionary, adopted some concepts of kickstartDS, and even added a bit of theming! We have our main setup running now, including Storybook.", "tokens": 56}
{"title": "3. Configure Storybook | kickstartDS docs", "heading": "Code Sandbox", "content": "See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/3 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 86}
{"title": "Extend `Section` component | kickstartDS docs", "heading": "Summary", "content": "Follow our main guide to learn how you can \"Create your Design System\" in just 5 steps: Open guide\nExtend Section component\nThis guided example shows how you'd add components to your Design System that use a kickstartDS base component pretty directly. But unlike just adapting a component, extending a component also involves adding something to it, or changing the way certain things work under the hood, by composing multiple kickstartDS base components (whereas customizing a component does that by adding changes to the customized components React template). This expands possible applications of existing kickstartDS components greatly.\nEven while using the component rather directly from kickstartDS, you'll want to find the correct set of properties for your own use case. Components in kickstartDS come equipped with properties for a wide range of possible use cases, so it makes sense to reduce those to the ones you really need... to make components easier to understand, use and reason about!\nWe call this type of workflow Extension. Learn more about it in our dedicated guide about it. If you're unsure about something, have a look over there. We go into more background detail there about what we're doing here.\nNot touching the actual markup generated by components let's us get by without adding any custom styling (CSS / SCSS) to it. We simply reuse the already existing Design Token and component structure.\nOverview\nThis is how the result of this guide will look like:\nThis guide assumes that you already have a working Design System, that is based on kickstartDS, running.\nIf that's not the case, follow our Create your Design System guide.\n1. Component Definition\nPurpose\nWe've found that we'd love to use the existing kickstartDSSection, but it's not quite flexible enough for our taste. We'd like to add more call-to-actions to our page, which mostly consists of such Sections, and don't need as much flexibility for the included headline.\nWe take width, gutter, mode, content, spaceBefore, spaceAfter and inverted directly from the Section, and rename background to style for our version of it. And crucially we add our own property ctas, to hold call-to-actions, into the mix, while reducing the complexity of headline significantly... from mapping to all of the Headline properties, to just a single string type prop setting its content.\nWe also keep the name Section, as it fits our use case well enough already.\nStructure\nDefining the structure of a component means finding the component API for it:\nProperty\nType\nDescription\nheadline\nstring\nHeadline for the section\nwidth\nenum\nWidth of section to use\ngutter\nenum\nSize of gutter to use\nmode\nenum\nLayout mode used for section contents\ncontent\narray\nAllowed content for the section\nstyle\nenum\nStyle of section, influences background\nspaceBefore\nenum\nAmount of spacing before the section\nspaceAfter\nenum\nAmount of spacing after the section\ninverted\nboolean\nWhether to invert the section\nctas\narray\nCall-to-actions to show\nctas[].label *\nstring\nLabel for the Call to action\nctas[].target *\nstring\nTarget for the Call to action\nFields that should be required are marked with a *.\nWhile directly helping us get a better grasp on our new component, these will also be used to write our JSON Schema later!\n2. Component Creation\nWe like to colocate components. This means to have all involved files next to each other in the same folder; the template (.jsx / .tsx), potential CSS / SASS (.css / .scss), JavaScript (.js / .ts), our JSON Schema component definition (.schema.json), and so on.\nSo we start by creating the directory src/components/section, from our Design System repository root:\n_1\nmkdir -p src/components/section\nThis is the folder we'll add new files to in the coming few paragraphs.\nJSON Schema definition\nFirst file we'll create is the JSON Schema definition, encoding the structure we've defined for our component before:\nFinished JSON Schema\nWe'll work our way up to this JSON Schema definition.\nWe start by adding a title, description and $id attribute. The correct $id depends on your Design System configuration. We'll assume you've created components before, living under the schema prefix http://schema.mydesignsystem.com.\n\"description\": \"Component used to layout components into pages\",\n_8\n\"type\": \"object\",\n_8\n\"properties\": {}\n_8\n}\nCreate headline field\nThe headline field is a straight-forward string type properties, so we just document it a bit!\nWe do mark it by setting format to markdown, though, to enable some light RTE-like formatting options of the rendered text later on.\n\"description\": \"Amount of spacing before the section\",\n_104\n\"enum\": [\"default\", \"small\", \"none\"],\n_104\n\"default\": \"default\"\n_104\n},\n_104\n\"spaceAfter\": {\n_104\n\"type\": \"string\",\n_104\n\"title\": \"Space After\",\n_104\n\"description\": \"Amount of spacing after the section\",\n_104\n\"enum\": [\"default\", \"small\", \"none\"],\n_104\n\"default\": \"default\"\n_104\n},\n_104\n\"inverted\": {\n_104\n\"type\": \"boolean\",\n_104\n\"title\": \"Inverted\",\n_104\n\"description\": \"Whether to invert the section\",\n_104\n\"default\": false\n_104\n},\n_104\n\"ctas\": {\n_104\n\"type\": \"array\",\n_104\n\"title\": \"Call to actions\",\n_104\n\"description\": \"Add Call to actions to the end of the section\",\n_104\n\"items\": {\n_104\n\"type\": \"object\",\n_104\n\"properties\": {\n_104\n\"label\": {\n_104\n\"type\": \"string\",\n_104\n\"title\": \"Label\",\n_104\n\"description\": \"Label for the Call to action\"\n_104\n},\n_104\n\"target\": {\n_104\n\"type\": \"string\",\n_104\n\"title\": \"Target\",\n_104\n\"description\": \"Target for the Call to action\",\n_104\n\"format\": \"uri\"\n_104\n}\n_104\n},\n_104\n\"required\": [\"label\", \"target\"]\n_104\n}\n_104\n}\n_104\n},\n_104\n\"required\": []\n_104\n}\nFinished JSON Schema\nWe'll work our way up to this JSON Schema definition.\nStart with just the boilerplate for a component definition\nThis includes all necessarily required values for a valid component definition in kickstartDS.\nAdd basic info describing component\nWe start by adding a title, description and $id attribute. The correct $id depends on your Design System configuration. We'll assume you've created components before, living under the schema prefix http://schema.mydesignsystem.com.\nCreate headline field\nThe headline field is a straight-forward string type properties, so we just document it a bit!\nWe do mark it by setting format to markdown, though, to enable some light RTE-like formatting options of the rendered text later on.\nAdd allowed widths 1/2\nWe add a width property of type string...\nAdd allowed widths 2/2\n... and make it an enum, defining its available options explicitly. We also set a default.\nAdd allowed gutters 1/2\nWe add a gutter property of type string...\nAdd allowed gutters 2/2\n... and make it an enum, defining its available options explicitly. We also set a default.\nAdd allowed modes 1/2\nWe add a mode property of type string...\nAdd allowed modes 2/2\n... and make it an enum, defining its available options explicitly. We also set a default.\nAdd allowed contents\nWe add a field content of type arrayÂ´. Let's assume we have three components that can be used as content for the section. We reference each one using anyOfand$ref`.\nAdd allowed styles 1/2\nWe add a style property of type string...\nAdd allowed styles 2/2\n... and make it an enum, defining its available options explicitly. We also set a default.\nAdd allowed spaceBefores 1/2\nWe add a spaceBefore property of type string...\nAdd allowed spaceBefores 2/2\n... and make it an enum, defining its available options explicitly. We also set a default.\nAdd allowed spaceAfters 1/2\nWe add a spaceAfter property of type string...\nAdd allowed spaceAfters 2/2\n... and make it an enum, defining its available options explicitly. We also set a default.\nAdd inverted property\nWe add a property inverted, as a boolean.\nAdd ctas property 1/2\nWe add the ctas property of type array, this will hold our call-to-action related properties label and target.\nAdd ctas property 2/2\nWe specify the array items type, adding an object with properties label and target to it, both of simple string types (with target having format set to uri to enable resource-like behaviour).\nFinished JSON Schema\nLet's have a look at our completed JSON Schema definition.\n\"description\": \"Amount of spacing before the section\",\n_104\n\"enum\": [\"default\", \"small\", \"none\"],\n_104\n\"default\": \"default\"\n_104\n},\n_104\n\"spaceAfter\": {\n_104\n\"type\": \"string\",\n_104\n\"title\": \"Space After\",\n_104\n\"description\": \"Amount of spacing after the section\",\n_104\n\"enum\": [\"default\", \"small\", \"none\"],\n_104\n\"default\": \"default\"\n_104\n},\n_104\n\"inverted\": {\n_104\n\"type\": \"boolean\",\n_104\n\"title\": \"Inverted\",\n_104\n\"description\": \"Whether to invert the section\",\n_104\n\"default\": false\n_104\n},\n_104\n\"ctas\": {\n_104\n\"type\": \"array\",\n_104\n\"title\": \"Call to actions\",\n_104\n\"description\": \"Add Call to actions to the end of the section\",\n_104\n\"items\": {\n_104\n\"type\": \"object\",\n_104\n\"properties\": {\n_104\n\"label\": {\n_104\n\"type\": \"string\",\n_104\n\"title\": \"Label\",\n_104\n\"description\": \"Label for the Call to action\"\n_104\n},\n_104\n\"target\": {\n_104\n\"type\": \"string\",\n_104\n\"title\": \"Target\",\n_104\n\"description\": \"Target for the Call to action\",\n_104\n\"format\": \"uri\"\n_104\n}\n_104\n},\n_104\n\"required\": [\"label\", \"target\"]\n_104\n}\n_104\n}\n_104\n},\n_104\n\"required\": []\n_104\n}\nThis concludes creating the JSON Schema. When running the schema generation in our Design System again, we should now automatically end up with a corresponding type definition to be used in creation of the template in the next step:\nsrc/components/section/SectionProps.ts\nsrc/components/section/section.schema.json\n_176\n/* eslint-disable */\n_176\n/**\n_176\n* This file was automatically generated by json-schema-to-typescript.\n_176\n* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n_176\n* and run `yarn run schema` to regenerate this file.\nAs the final step for this example, we'll add the template. This will be a purely functional React component, mapping our component structure (as defined in the JSON Schema) to the original component we're basing our work off of; the kickstartDSStorytelling component.\nFinished React template\nWe'll work our way up to this React template.\nsrc/components/section/SectionComponent.tsx\n_61\nimport { HTMLAttributes, FC, PropsWithChildren } from \"react\";\n_61\n_61\nimport {\n_61\nSectionContextDefault,\n_61\nSectionContext,\n_61\n} from \"@kickstartds/base/lib/section\";\n_61\n_61\nimport { SectionProps } from \"./SectionProps\";\n_61\nimport { Button } from \"../button/ButtonComponent\";\nImport and add generated props from SectionProps.ts. Generated by our JSON Schema, these guarantee you're matching your expected component structure while implementing. In combination with TypeScript this enables auto-complete and auto-fix for even better DX! (see here, at the very end of that section, for more details)\nWe also add HTMLAttributes<HTMLElement> to the type signature for the props that we'll pass through to the native HTML element underneath.\nWe also need to add our own properties, so we'll destructure props. We add our default values here, too. We'll just pass through everything HTMLAttributes related!\nsrc/components/section/SectionComponent.tsx\n_20\nimport { HTMLAttributes, FC } from \"react\";\n_20\n_20\nimport { SectionProps } from \"./SectionProps\";\n_20\n_20\nexport const Section: FC<\n_20\nSectionProps & HTMLAttributes<HTMLElement>\n_20\n> = ({\n_20\nheadline,\n_20\nwidth = \"default\",\n_20\ngutter = \"default\",\n_20\nmode = \"default\",\n_20\nstyle = \"default\",\n_20\nspaceBefore = \"default\",\n_20\nspaceAfter = \"default\",\n_20\ninverted = false,\n_20\nctas = [],\n_20\n...props\n_20\n}) => (\n_20\n<div {...props}>Lorem ipsum</div>\n_20\n));\nAdd Section component 1/7\nNow we'll import and add the kickstartDSSection component. To start, we'll use the hard-coded properties of the Content BoxesSection variant from our kickstartDS Design System.\nWe'll omit the child components added there (ContentBoxes), as they only exist for illustrative purposes inside that Storybook. We will just pass children through to the original Section, later.\nsrc/components/section/SectionComponent.tsx\n_43\nimport { HTMLAttributes, FC } from \"react\";\n_43\n_43\nimport {\n_43\nSectionContextDefault,\n_43\n} from \"@kickstartds/base/lib/section\";\n_43\n_43\nimport { SectionProps } from \"./SectionProps\";\n_43\n_43\nexport const Section: FC<\n_43\nSectionProps & HTMLAttributes<HTMLElement>\n_43\n> = ({\n_43\nheadline,\n_43\nwidth = \"default\",\n_43\ngutter = \"default\",\n_43\nmode = \"default\",\n_43\nstyle = \"default\",\n_43\nspaceBefore = \"default\",\n_43\nspaceAfter = \"default\",\n_43\ninverted = false,\n_43\nctas = [],\n_43\n...props\n_43\n}) => (\n_43\n<SectionContextDefault\n_43\nbackground=\"default\"\n_43\nheadline={{\n_43\nalign: 'center',\n_43\nclassName: undefined,\n_43\ncontent: 'Headline',\n_43\nlevel: 'h2',\n_43\npageHeader: false,\n_43\nspaceAfter: 'none',\n_43\nstyleAs: 'none',\n_43\nsubheadline: undefined\n_43\n}}\n_43\nwidth=\"default\"\n_43\ngutter=\"default\"\n_43\nmode=\"tile\"\n_43\npattern=\"none\"\n_43\nspaceBefore=\"default\"\n_43\nspaceAfter=\"default\"\n_43\nvariant=\"none\"\n_43\n/>\n_43\n));\nAdd Section component 2/7\nWe remove all of the unneeded stuff, as there are a bunch of properties that are completely optional, mainly those having their values undefined or null in the copied JSX, or ones which just state the default value of that property anyway. Those can be freely removed.\nsrc/components/section/SectionComponent.tsx\n_34\nimport { HTMLAttributes, FC } from \"react\";\n_34\n_34\nimport {\n_34\nSectionContextDefault,\n_34\n} from \"@kickstartds/base/lib/section\";\n_34\n_34\nimport { SectionProps } from \"./SectionProps\";\n_34\n_34\nexport const Section: FC<\n_34\nSectionProps & HTMLAttributes<HTMLElement>\n_34\n> = ({\n_34\nheadline,\n_34\nwidth = \"default\",\n_34\ngutter = \"default\",\n_34\nmode = \"default\",\n_34\nstyle = \"default\",\n_34\nspaceBefore = \"default\",\n_34\nspaceAfter = \"default\",\n_34\ninverted = false,\n_34\nctas = [],\n_34\n...props\n_34\n}) => (\n_34\n<SectionContextDefault\n_34\nbackground=\"default\"\n_34\nheadline={{\n_34\ncontent: 'Headline',\n_34\n}}\n_34\nwidth=\"default\"\n_34\ngutter=\"default\"\n_34\nmode=\"tile\"\n_34\nspaceBefore=\"default\"\n_34\nspaceAfter=\"default\"\n_34\n/>\n_34\n));\nAdd Section component 3/7\nWe now import the component we want to use to display the call-to-actions, in this case a Button included in our own Design System. We also add a second Section (losing its headline) to hold our Buttons, and connect those to cta.label. We choose the variant of Button by index, first equals primary, second means secondary and all others are tertiary.\nsrc/components/section/SectionComponent.tsx\n_51\nimport { HTMLAttributes, FC } from \"react\";\n_51\n_51\nimport {\n_51\nSectionContextDefault,\n_51\n} from \"@kickstartds/base/lib/section\";\n_51\n_51\nimport { SectionProps } from \"./SectionProps\";\n_51\nimport { Button } from \"../button/ButtonComponent\";\nWe then connect the props as defined in our component API that are directly taken from the underlying kickstartDS base component by just passing them through. We also destructure props first, so our own properties take precedence when set. We add it to the first Section, that will always be rendered.\nsrc/components/section/SectionComponent.tsx\n_56\nimport { HTMLAttributes, FC } from \"react\";\n_56\n_56\nimport { SectionContextDefault } from '@kickstartds/base/lib/section';\n_56\n_56\nimport { SectionProps } from './SectionProps';\n_56\nimport { Button } from '../button/ButtonComponent';\nAgain we'll start with a very basic skeleton for our React component. We're using TypeScript here (.tsx), but it works the same with plain JSX (.jsx).\nAdd correct typings\nImport and add generated props from SectionProps.ts. Generated by our JSON Schema, these guarantee you're matching your expected component structure while implementing. In combination with TypeScript this enables auto-complete and auto-fix for even better DX! (see here, at the very end of that section, for more details)\nWe also add HTMLAttributes<HTMLElement> to the type signature for the props that we'll pass through to the native HTML element underneath.\nDestructure props\nWe also need to add our own properties, so we'll destructure props. We add our default values here, too. We'll just pass through everything HTMLAttributes related!\nAdd Section component 1/7\nNow we'll import and add the kickstartDSSection component. To start, we'll use the hard-coded properties of the Content BoxesSection variant from our kickstartDS Design System.\nWe'll omit the child components added there (ContentBoxes), as they only exist for illustrative purposes inside that Storybook. We will just pass children through to the original Section, later.\nAdd Section component 2/7\nWe remove all of the unneeded stuff, as there are a bunch of properties that are completely optional, mainly those having their values undefined or null in the copied JSX, or ones which just state the default value of that property anyway. Those can be freely removed.\nAdd Section component 3/7\nWe now import the component we want to use to display the call-to-actions, in this case a Button included in our own Design System. We also add a second Section (losing its headline) to hold our Buttons, and connect those to cta.label. We choose the variant of Button by index, first equals primary, second means secondary and all others are tertiary.\nAdd Section component 4/7\nWe then connect the props as defined in our component API that are directly taken from the underlying kickstartDS base component by just passing them through. We also destructure props first, so our own properties take precedence when set. We add it to the first Section, that will always be rendered.\nAdd Section component 5/7\nWe renamed background to style in our component API, so we add that in its renamed form... to both Sections.\nAdd Section component 6/7\nWe connect our property headline to the first Sections headline.content.\nAdd Section component 7/7\nAs a final step, we make sure the spacing between the two Sections is optimized, so it will look seamless later on. We also hard code some options of the second Section.\nAdd component Provider\nWe want our Section to replace all default kickstartDS base Sections, no matter where they appear. We add a Provider for that purpose now!\nFinished React template\nLet's have a look at our completed React template.\nsrc/components/section/SectionComponent.tsx\n_61\nimport { HTMLAttributes, FC, PropsWithChildren } from \"react\";\n_61\n_61\nimport {\n_61\nSectionContextDefault,\n_61\nSectionContext,\n_61\n} from \"@kickstartds/base/lib/section\";\n_61\n_61\nimport { SectionProps } from \"./SectionProps\";\n_61\nimport { Button } from \"../button/ButtonComponent\";\nTo complete the template we add the SectionProvider to our src/components/Providers.jsx:\nsrc/components/Providers.jsx\n_14\nimport { ButtonProvider } from \"./button/ButtonComponent\";\n_14\nimport { SectionProvider } from \"./section/SectionComponent\";\n_14\nimport { TeaserBoxProvider } from \"./teaser-card/TeaserCardComponent\";\n_14\nimport { HeadlineProvider } from \"./headline/HeadlineComponent\";\n_14\n_14\nexport default (props) => (\n_14\n<ButtonProvider>\n_14\n<HeadlineProvider>\n_14\n<SectionProvider>\n_14\n<TeaserBoxProvider {...props} />\n_14\n</SectionProvider>\n_14\n</HeadlineProvider>\n_14\n</ButtonProvider>\n_14\n);\nThis concludes the creation of our new Section component. It's now ready to be used inside your Design System, and available to your down stream consumers... hopefully efficiently closing a gap for them!\nUse of Storybook\nIf you're using Storybook, you can follow this part of the example to get all the integration goodness possible with kickstartDS!\nStorybook setup\nThis guide assumes you're using a set up like described in our Create your\nDesign System guide! Be sure to adapt commands and\nconfiguration to your use accordingly, when following this part!\nAdd the following file to your src/components/section folder:\nImport re-usable SectionStories\nImport Section component and add it to the Template that we'll bind Stories to.\nImport re-usable TeaserCardStories\nImport TeaserCardStories as demo content for our SectionStory. Add them to the Template, too.\nImport Storybook Controls helpers\nImport dereferenced component JSON Schema and getArgsShared helper to generate Storybook Controls, and parameterize Storybook JSON Schema Addon.\nOverwrite Story values where needed\nWe set all the Story defaults specific to our component.\nConvert args to flat keys\nWe use pack to convert all deep JSON args to flat (. delimited) keys and values. This is the format your Storybook Controls get generated off.\nCreate Section variants\nWe do this by binding to our Template, and use pack to convert all deep JSON args to flat (. delimited) keys and values. This is the format your Storybook Controls get generated off.\nsrc/components/section/Section.stories.jsx\n_65\nimport merge from \"deepmerge\";\n_65\nimport {\n_65\npack,\n_65\nunpack,\n_65\ngetArgsShared,\n_65\n} from \"@kickstartds/core/lib/storybook/helpers\";\n_65\nimport sectionStories from \"@kickstartds/base/lib/section/section.stories\";\n_65\nimport TeaserCardStory, {\n_65\nCardWithImage,\n_65\n} from \"../teaser-card/TeaserCard.stories\";\n_65\nimport schema from \"./section.schema.dereffed.json\";", "tokens": 5743}
{"title": "2. Design Application | kickstartDS docs", "heading": "Overview", "content": "Applying your branding and corporate design to kickstartDS is itself done in roughly two steps: - Use a reduced set of Branding Tokento generate your initial Design Tokenset - Fine tune the resulting Design Tokenset to closely fit your corporate identity", "tokens": 52}
{"title": "2. Design Application | kickstartDS docs", "heading": "Initialization", "content": "We start by creating a file branding-token.json, inside a new directory src/token... for everything to do with Design Token going forward: _2mkdir -p src/token_2touch src/token/branding-token.json This file will hold all of our Branding Token. Those are used to initialize you first Design Token set, and especially ease first-time setup. Get the most up-to-date version of its content from here, and paste it into the file you just created:", "tokens": 110}
{"title": "2. Design Application | kickstartDS docs", "heading": "Use a current version", "content": "Be sure to actually copy the file linked above, entering the values yourself. This way you'll be sure not to miss any recently updated token in your set up, in case this guide gets outdated!", "tokens": 45}
{"title": "2. Design Application | kickstartDS docs", "heading": "Select", "content": "Branding Token For a more in-depth overview of those token, have a look at our foundations page about Branding Token, detailing all values in use. But to get a first feel for working with the file, and to add some flavour to our Design System, we'll change some select values around. And feel free to replace everything with values that seem more appropriate for you, or that fit your particular brand (maybe even because you opted to follow the more detailed guide above). If you're wondering which values we selected for this guide... we're mostly matching our own brand for this guide: |Preview||Name||Value|", "tokens": 130}
{"title": "2. Design Application | kickstartDS docs", "heading": "Customize", "content": "primary color Most brands have such a primary color as part of their corporate design guidelines. This will be used to highlight elements, and give them more importance. Next to primary itself, we'll also define its counter part primary-inverted as ecff00 ( fff / white works for most uses otherwise, read about the finer details here).", "tokens": 72}
{"title": "2. Design Application | kickstartDS docs", "heading": "Customize tonal colors", "content": "tonal colors There are a bunch of tokens that, for lack of a better explanation, relate to the tone of voice the element using it should have. Most commonly this would be something like a notice shown to the user (which might be successful = positive, neutral = informative, etc). Because it seems to fit our branding, and doesn't interfere with user expectations otherwise, we'll change informative (and you guessed it, informative-inverted) to our primary color.", "tokens": 100}
{"title": "2. Design Application | kickstartDS docs", "heading": "Add a fitting font", "content": "In this guide we'll opt for a native system font stack for our display and copy fonts. We'll leave interface and mono and all size values untouched for now. If you have other requirements (for example a self-hosted font, or one by Google Fonts), we'll add a guide for that soon!", "tokens": 69}
{"title": "2. Design Application | kickstartDS docs", "heading": "Adjust spacing behaviour", "content": "As we have a pretty dense layout in mind, we reduce spacing > scale-ratio and bp-ratio a bit. This will result in spacing in general scaling a bit less. We keep the general spacing of 8px, though. We'll also leave the rest of the values untouched as they'll work just fine for this guide!", "tokens": 75}
{"title": "2. Design Application | kickstartDS docs", "heading": "Generate first", "content": "Design Token set Generate your first full set of Design Token now, by calling: 1yarn init-tokens Your output should look roughly like this: _35yarn run v1.22.18_35$ kickstartDS tokens init_35 _  _  _ 35| | (_) | | _| |_  _  __| || _ \\/ |35| |/ / |/ | |/ / | __/ ` | '| | | | _ _35| <| | (| <_ \\ || (| | | | || || |) |35||__|_||____/__,|| _|/|_/35_35__/\\\\\\\\__/\\___/\\\\\\\\\\__35_/\\\\////////__\\/\\_____________\\/////\\\\///_________35_________/\\\\/___________\\/\\_________________\\/\\____________35________/\\_____________\\/\\_________________\\/\\____________35_______\\/\\_____________\\/\\_________________\\/\\____________35_______\\//\\____________\\/\\_________________\\/\\____________35________\\///\\__________\\/\\_________________\\/\\____________35__/\\____\\////\\\\\\\\_\\/\\\\\\\\\\\\\\_/\\\\\\\\\\_/\\__35\\///__\\/////////\\///////////////\\///////////__\\///___35_35Version: 1.0.0_35For more information visit:_35https://www.kickstartDS.com/docs/intro/cli_35_35Starting..._35[kickstartDS: general] info: welcome to the kickstartDS CLI_35[kickstartDS: tokens/init] starting: init command with init variable init-task_35[1/1] [init: check] info: checking prerequesites before starting_35[1/1] [init: check] info: prerequesites met, starting_35[init: cleanup] info: cleaning up temp dir /tmp/tokens-init-init-task before starting command_35[init: cleanup] info: finished cleaning up temp dir /tmp/tokens-init-init-task before starting command_35[1/1] [init: init] info: running the init subtask_35[info] generating your token set from primitives tokens file /tmp/tokens-init-init-task/token-primitives.json_35[info] successfully generated primitives tokens and wrote them to folder /tmp/tokens-init-init-task/./src/token/dictionary_35[1/1] [init: init] info: finished running the init subtask successfully_35[kickstartDS: tokens/init] finished: init command with init variable init-task_35Done in 1.19s. It uses your branding-token.json as an input, and generates a folder src/token/dictionary for you. That folder holds JSON files defining your Design Token by category: _17$ tree src/token/dictionary_17_17> src/token/dictionary_17> â”œâ”€â”€ background-color.json_17> â”œâ”€â”€ border-color.json_17> â”œâ”€â”€ border.json_17> â”œâ”€â”€ box-shadow.json_17> â”œâ”€â”€ breakpoints.json_17> â”œâ”€â”€ color.json_17> â”œâ”€â”€ deprecated.json_17> â”œâ”€â”€ depth.json_17> â”œâ”€â”€ spacing.json_17> â”œâ”€â”€ text-color.json_17> â”œâ”€â”€ transition.json_17> â””â”€â”€ typo.json_17>_17> 0 directories, 12 files You'll only use this mechanism when first setting up your tokens. It's meant to specifically ease this workflow. Running it again will overwrite changes you manually did to your Design Token set, which is probably not intended! To learn more about the categories represented by those generated files, have a look at our foundations page about them.", "tokens": 834}
{"title": "2. Design Application | kickstartDS docs", "heading": "Compile", "content": "Design Token set Finally, to test the integration works as expected, we'll first want to create one additional file: sd.config.cjs at our projects root. As the name may imply, this is further configuration for our Design Token, to convert them into different outputs (more specifically the Style Dictionary that gets used under the hood): And, as this is based on Style Dictionary, it generally follows their configuration scheme. Let's detail some lines:", "tokens": 94}
{"title": "2. Design Application | kickstartDS docs", "heading": "Import dependencies", "content": "Import style-dictionary to use their native StyleDictionary.extend, and get our pre-made, kickstartDS compatible, configuration from @kickstartds/style-dictionary.", "tokens": 43}
{"title": "2. Design Application | kickstartDS docs", "heading": "Extend configuration", "content": "Our pre-made configuration gets extended by our local project setup. That way we can reuse stuff for easier configuration, if needed. Design Token location We configure the default Design Token location, which is tokens as a glob src/token/dictionary/*/.json...", "tokens": 56}
{"title": "2. Design Application | kickstartDS docs", "heading": "Default SVG icons", "content": "... and tell Style Dictionary where to look for our default icons. These are used by kickstartDS components, and need to be present in different formats later on (depending on the use case).", "tokens": 44}
{"title": "2. Design Application | kickstartDS docs", "heading": "Platforms", "content": "To test that our integration works as expected, we'll add the CSS platform for now, which will result in our Design Token being converted to CSS custom properties, as src/token/tokens.css.", "tokens": 46}
{"title": "2. Design Application | kickstartDS docs", "heading": "Using correct file extension", "content": "It's important to actually use cjs as the file extension here. You can build your Design Token set into different outputs using Style Dictionary and kickstartDS. So far we've mainly configured how token are ingested, but we'll build on our single test platform CSS in the process of this guide. Adding integrations for Storybook, the use in kickstartDS components, and so on! By re-using our pre-made configurations we only have to define a buildPath to activate a platform. Optionally you can define file names with files, too. With all of that in place, for the first time compile your Design Token set into CSS Custom Properties now: 1yarn build-tokens If everything worked as expected, you should end up with a long src/token/tokens.css file and the following output on your terminal: _52yarn run v1.22.19_52$ kickstartDS tokens compile_52 _  _  _ 52| | (_) | | _| |_  _  __| || _ \\/ |52| |/ / |/ | |/ / | __/ ` | '| | | | _ _52| <| | (| <_ \\ || (| | | | || || |) |52||__|_||____/__,|| _|/|_/52_52__/\\\\\\\\__/\\___/\\\\\\\\\\__52_/\\\\////////__\\/\\_____________\\/////\\\\///_________52_________/\\\\/___________\\/\\_________________\\/\\____________52________/\\_____________\\/\\_________________\\/\\____________52_______\\/\\_____________\\/\\_________________\\/\\____________52_______\\//\\____________\\/\\_________________\\/\\____________52________\\///\\__________\\/\\_________________\\/\\____________52__/\\____\\////\\\\\\\\_\\/\\\\\\\\\\\\\\_/\\\\\\\\\\_/\\__52\\///__\\/////////\\///////////////\\///////////__\\///___52_52Version: 1.0.4_52For more information visit:_52https://www.kickstartds.com/docs/intro/cli/_52_52Starting..._52[kickstartDS: general] [info]: welcome to the kickstartDS CLI_52[kickstartDS: tokens/compile] starting: compile command with compile variable compile-task_52[1/1] [compile: check] [info]: checking prerequesites before starting_52[1/1] [compile: check] [info]: prerequesites met, starting_52[compile: cleanup] [info]: cleaning up temp dir /tmp/tokens-compile-compile-task before starting command_52[compile: cleanup] [info]: finished cleaning up temp dir /tmp/tokens-compile-compile-task before starting command_52[1/1] [compile: compile] [info]: running the compile subtask_52[1/1] [compile: compile] [info]: getting Style Dictionary from token files_52[1/1] [compile: compile] [info]: compiling Style Dictionary to needed CSS and assets_52_52css_52âœ”ï¸Ž src/token/tokens.css_52_52html_52âœ”ï¸Ž src/token/icons/icon-sprite.html_52_52jsx_52âœ”ï¸Ž src/token/icons/IconSprite.js_52_52storybook_52âœ”ï¸Ž src/token/storybook/tokens.css_52âœ”ï¸Ž src/token/storybook/icons.svg_52_52js_52âœ”ï¸Ž src/token/storybook/tokens.js_52[1/1] [compile: compile] [info]: copying generated CSS and assets to local folder_52[1/1] [compile: compile] [info]: finished running the compile subtask successfully_52[kickstartDS: tokens/compile] finished: compile command with compile variable compile-task_52Done in 2.41s.", "tokens": 899}
{"title": "2. Design Application | kickstartDS docs", "heading": "To commit, or not to commit...", "content": "It's up to personal / team preference if the generated src/token/token.css file should be added to your repository... or your .gitignore. There are valid arguments to make for both sides, so you should just follow what feels right for you! We'll add it to our .gitignore:", "tokens": 71}
{"title": "2. Design Application | kickstartDS docs", "heading": "Fine tune the design", "content": "Once the Design Token are generated, the Design System will already have the broad look & feel of your Corporate Design! However you probably still have to tweak it a little to make it match up perfecly with your CD requirements. This can be done by configuring the various .json files found within the dictionary folder.", "tokens": 70}
{"title": "2. Design Application | kickstartDS docs", "heading": "Adjustments in", "content": "background-color.json Common adjutments are made in the background-color.json file. Note that the same can be applied to text-color.json and border-color.json.", "tokens": 43}
{"title": "2. Design Application | kickstartDS docs", "heading": "Set", "content": "hover / active We are going to be adjusting various states of primary, as they are entireley dependant on the selected color. What might initially work on certain colors might not work at all on others.", "tokens": 44}
{"title": "2. Design Application | kickstartDS docs", "heading": "Next Step", "content": "In the next step we'll set up Storybook. This connects nicely, as we'll add the Storybook integration for Design Token there, to make them viewable in the browser. We'll also make preparations for the step after, where we'll add components. It's probably a good idea to commit everything again, now!", "tokens": 69}
{"title": "2. Design Application | kickstartDS docs", "heading": "Code Sandbox", "content": "See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/2 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 86}
{"title": "Adapt a component | kickstartDS docs", "heading": "Overview", "content": "Adapting a component means to use the component \"directly\". This includes using the same name and purpose for it. The obvious example would be using the Button provided by kickstartDS for the Button as part of your own Design System. It typically doesn't make a lot of sense to find a different name for this component, because the name is fitting and well-known. the process of changing to suit different conditions The word \"directly\" above is set in quotes, because even though we re-use the component with the same intent, we will still want to reduce the offered options (component properties) to better suit our needs. A simple component API helps in creating a shared understanding of what a component is, and does.", "tokens": 151}
{"title": "Adapt a component | kickstartDS docs", "heading": "kickstartDS component properties", "content": "Components as delivered by kickstartDS modules (like @kickstartDS/base for the Button) have to support a wide range of use cases, as they get used to build a multitude of different, but custom, Button implementations in the end. This means reducing the set of properties, given by the component API of a kickstartDS component, to your needs is explicitly something that should be done! You still benefit by the broad, underlying foundation giving you flexibility when further adapting your own version of it. For example when adding a variant including an Icon, which was not part of your Button before. For a detailed example of adapting the Button component, have a look at our component example guide describing just that! To learn more about the different processes available to you when creating a component with kickstartDS, have a look at the overview page of this section.", "tokens": 178}
{"title": "Adapt a component | kickstartDS docs", "heading": "Adaptation process", "content": "There's one big assumption made when choosing the adaptation process: you've already identified a component you'd like to use... and it already offers all the options you'll need. Let's call this component the base component. This greatly simplifies finding a component definition, as it means simply selecting props you'd like to use for yourself, from a well-defined set. ", "tokens": 78}
{"title": "Adapt a component | kickstartDS docs", "heading": "Adaptation process as a base line", "content": "as a base line Each of the other ways of adding a component to your Design System based on kickstartDS builds upon this adapdation process. Which is to say, you'll always want to reduce the props of kickstartDS components used as a base, as described here. But sometimes that may not be enough. You might need a slightly different version of the component, or its props (learn more in our guide \"Customize a component\", or view \"Customize Headline component\" as an example), or you may want to add something completely new to it (learn more in our guide \"Extend a component\", or view \"Extend Section component\" as an example). If you don't have component in mind yet, you're probably better served by our guide \"Create a component\". In that guide, you'll start off without a specific component in mind. This means defining a structure (someting you probably have an idea about already) first, and then mapping that structure to a fitting component second. We also have an example for this with \"Create Teaser Card component\". If you're still unsure, then maybe you're still missing a clear picture on what your components should look like. In that case, you should probably take a step back first, and maybe start a Design System Initiative to narrow down on what components you'll really need. There are two main steps in adapting a component: - Component definition, and - Component creation Let's see what they're all about!", "tokens": 311}
{"title": "Adapt a component | kickstartDS docs", "heading": "1. Component Definition", "content": "The adaptation process starts by defining a component API. As touched on before, this mainly means selecting a set of props from the pool of props available through your selected base component. We'll use the Button component throughout this guide to illustrate concepts. This will not be an exhaustive example, though. For that have a look at our guide \"Adapt Button component\".", "tokens": 75}
{"title": "Adapt a component | kickstartDS docs", "heading": "Purpose", "content": "For the adaptation process the main purpose of a component is already defined by the selected base component. Nontheless, the purpose for even a well-known type of component, like the Button, can vary from one Design System to the next. So it helps to think about the specific purpose the selected base component will serve in your Design System. As a hypothetical: you might decide to really only use components looking like a Button for elements the user directly interacts with... but not for links. This would be a big part of the components purpose, and thus should inform your property selection and naming process.", "tokens": 124}
{"title": "Adapt a component | kickstartDS docs", "heading": "Structure", "content": "Before we start implementing, we'll want to define a first rough draft of our component API. Defining a name, a small description and a rough type, per property, goes a long way in keeping the focus on the core of your component. Let's keep using the Button as an example. We're starting with the following properties with that one: |Property||Type||Description| |Text used on button| |Choose one of the styles from the list| |If the button should be inverted| |Choose a size between small, medium and large| |Link used for button| |Icon identifier for icon before the button text| |Icon identifier for icon after the button text| |Add fill animation on hover| |Add icon animation on hover| |Select the type attribute for the button| |Define a value attribute for the button| |Define a name attribute for the button| |Set the disabled attribute for the button| |Open link in new Tab| |Add additional css classes that should be applied to the button| |Optional custom component identifier| Fields that should be required are marked with a . For the detailed documentation have a look at the Button in our Storybook* here: https://www.kickstartds.com/storybook/?path=/docs/base-button--solid One potential set of props, it's also the one used in our guide \"Adapt Button component\" if you're wondering, would be the following: |Property||Type||Description| |Text content to display inside the button| |Target that should be linked, makes the button behave like a link semantically when set| |Variant of button to be used| |Size of button to use| |Whether the button should be disabled| We took label, variant, size and disabled directly, and renamed href to target for our version of the Button. Required fields are marked with a * again. In our hypothetical above, we would probably drop the option of specifying href or target altogether.", "tokens": 409}
{"title": "Adapt a component | kickstartDS docs", "heading": "2. Component Creation", "content": "In the second and final step we'll get to actually create our component. We'll encode the component API by creating its JSON Schema, and create a React template matching our selected properties to the kickstartDS base component. JSON Schema definition We establish the structure of components by creating a JSON Schema for them, defining their component API in code. For an abridged version of that process, have a look at the Button again:", "tokens": 93}
{"title": "Adapt a component | kickstartDS docs", "heading": "Finished component", "content": "JSON Schema The finished component definition in all its glory. For the full version of adapting a Button have a look at our guide \"Adapt Button component\". React template Now that our JSON Schema is defined, we'll automatically get matching TypeScript types for our component. We use those, combined with the types already included with the kickstartDS base component, to quickly hook up our set of properties to the original component. Using auto-complete, and TypeScript telling us about required properties in the base component, this is done in light speed! To learn more about the tooling that create those types for you, and how to hook it up, see part four of our \"Create your Design System\" guide. Let's continue showcasing this process using our Button, creating the component template:", "tokens": 162}
{"title": "Adapt a component | kickstartDS docs", "heading": "Add correct type to component", "content": "correct type to component We need to type our React component to use our JSON Schema, while also making sure native HTML attributes and React refs are passed correctly. For the Button this means also including HTMLAnchorElement | HTMLButtonElement and using forwardRef. Doing this allows users of your component to enjoy having the same auto-complete and safety when working with your Design System. ", "tokens": 85}
{"title": "Adapt a component | kickstartDS docs", "heading": "Add parameters to component", "content": "parameters to component Next we add all our components defined properties to its function signature. For properties having a default defined in your component API we add that default here, too. As we also want to pass through all the props not explicitly managed by us we sponge up ...props. And in the case of the Button, we also have to add the ref added through forwardRef.", "tokens": 83}
{"title": "Adapt a component | kickstartDS docs", "heading": "Destructure additional props", "content": "Coming to our component JSX, we start by passing down (destructuring) the props we're carrying through first. This ensures properties defined in our component API will always take precedence, because they're added after the general props.", "tokens": 51}
{"title": "Adapt a component | kickstartDS docs", "heading": "Glue component API to base component 1/3", "content": "The simplest cases of connecting props to the base component is when the name of the property is taken from the base component. We can just directly pass those without much thought.", "tokens": 42}
{"title": "Adapt a component | kickstartDS docs", "heading": "Glue component API to base component 2/3", "content": "In some cases we might have changed the name of a prop. In that instance, we just to have to wire up the renamed property to the originally named base components property.", "tokens": 43}
{"title": "Adapt a component | kickstartDS docs", "heading": "Glue component API to base component 3/3", "content": "Finally there might be properties where the naming of the actual values was changed, for example when adapting enum typed properties. We'll have to simply rewire the values in that case.", "tokens": 44}
{"title": "Adapt a component | kickstartDS docs", "heading": "Finalize component JSX by adding the", "content": "ref This will be optional, and depend on the element being handled. If you've included a forwardRef before, you'll have to pass that ref down to the kickstartDS base component. We'll have to simply rewire the values in that case. ", "tokens": 61}
{"title": "Adapt a component | kickstartDS docs", "heading": "Adding a", "content": "ing a Provider The final part of creating our React component is adding a component Provider for it. As we've adapted a component here, we'll want to make sure that every time another component includes the base component, our own version of it gets used instead. If you're wondering what that Provider we've added last is all about, think about it like this: There may be other components you've built, that themselves use the base Button component by default. For example we might have our own TeaserCard component, based on the kickstartDS TeaserBox which includes a Button. As a means to not having to go through every combination of those component now, making sure our Button actually gets used, you can just change the default Button rendered by adding a single Provider once, instead. Learn more about Providers and React Context in[our dedicated page about them. Or look at our \"Create your Design System\" guide, where we add the general setup for Providers. That one also includes some more details on this!", "tokens": 210}
{"title": "Adapt a component | kickstartDS docs", "heading": "Visual Studio Code component property quick-fix", "content": "Visual Studio Code has a great feature aiding in this workflow, with React components that include TypeScript types... like kickstartDS components do. When adding a \"bare\" component without props to your template, Visual Studio Code will offer you the option to Add missing attributes. This will automatically create all required options for your component. Now you just have to connect your own props to those, while hard-coding the ones you don't plan on exposing as part of your components component API. Just hover the squiggly, red line that should be decorating your component, and choose Quick Fix..., to get to that option (alternatively put your cursor on the component tag and hit Ctrl+.).", "tokens": 148}
{"title": "Adapt a component | kickstartDS docs", "heading": "Technical debt added", "content": "This way of creating components adds minimal technical debt to your Design System. Not much has been changed around, we just add a small layer on top of the original kickstartDS base component. Relevant underlying changes you'll have to look out for: - changes to the base components component API - removal of the base component You're immune to underlying changes to: - the components template (both React, and the resulting HTML) - the design and layout (changes to CSS, SCSSand Design & Component Token) In the case of a changed component API, you should have a look at the corresponding CHANGELOG.md and potential notes in our matching migration guide. You'll probably just need to add a newly added field to your React template, and potentially your own component API if you want to use it. If a field was changed, that might also necessitate some adaption of your own version. Finally a removed field you're actually using would mean adding additional customization to regain that functionality. Have a look at our Headline example guide to see how you'd add your own, new property! Learn more about what we mean by technical debt here on the overview page of this section.", "tokens": 246}
{"title": "Adapt a component | kickstartDS docs", "heading": "Adapt", "content": "Button component In this example component guide we adapt the Button component (as part of the @kickstartDS/base module) to use it for buttons in our own Design System. We drastically reduce the options used, and offered, in our own adaptation. We remove all options that include having an Icon displayed as part of the Button, for example. This is what the result looks like: _1", "tokens": 83}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Introduction to kickstartDS", "content": "kickstartDS is an Open Source Design System starter and UI toolkit for building up your very own Design System. This in turn enables you, and your team, to build brand-compliant websites and apps super efficiently. All while using core web technologies â€” HTML, CSS, and JavaScript â€” and best practices. Check out the following video for a more in-depth demonstration, and see kickstartDS in action (timestamped start): Many thanks to Amplifyn for allowing us to use their recording.", "tokens": 107}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Overview", "content": "kickstartDS focuses on the consistent frontend UX and UI interaction of components â€” colors, layout, interactions, animations. It's easy to adapt, and integrates with every frontend-approach that works with regular HTML. Additionally, under the hood, React is used as the templating layer of choice, but integration into your templating layer, or backend, of choice is in no way limited by this, as everything is written to be usable without a React runtime! Only development of new components involves, and benefits by, the use of React!", "tokens": 116}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Framework-agnostic", "content": "Every kickstartDS component consists of semantic HTML(5), CSS Modules & Properties and JavaScript (ES6). This makes it easy to implement across any framework or even stand alone. Alternatively, use our ready-to-use React components directly in your codebase!", "tokens": 57}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Quality UX", "content": "A quality UX is defined not only by relevant content and services, it is also a matter of a clear and consistent brand image, with intuitive and usable interaction patterns and features. Use our experience to your advantage!", "tokens": 45}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Performance", "content": "Built for maximum performance. The kickstartDS components runtime, design token system and CSS framework are as lightweight as you need it to be. Stop thinking about build tooling and bundling!", "tokens": 41}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Accessibility", "content": "kickstartDS provides support for W3Câ€™s WCAG 2.1 spec. We take care that components support touch and keyboard navigation, screen readers and more. And if needed, we can give you pointers for your content!", "tokens": 51}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Great components as the baseline", "content": "Make the most out of your frontend interfaces by unifying their core â€“ utilizing component and design Token, component APIs and props and a shared core as a baseline to unlock effiency when implementing new applications of your Design System. kickstartDS aims to be the foundation for your Design System, built with reusable components and tools itself, guided by clear standards, that can be adopted and assembled together, to create your products: fast, flexible, responsive, accessible and best of all: you can plug it onto every digital touch point you own!", "tokens": 115}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Enable flexible + easy design application", "content": "Establish one common ground for developers and designers to deliver on your marketing, branding and design requirements. kickstartDS should help developers and designers in independently delivering a consistent UX and engaging user interfaces. With kickstartDS teams should be able to design, build, and organize UI components better and faster. Using Storybook you make sure every element aligns with all the responsive scenarios your users may encounter, and components are developed independently!", "tokens": 94}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Work with \"classic\" backend environments", "content": "Provide tooling to support your integration tasks, by improving developer DX drastically. Working with a more \"classic\" approach shouldn't mean you'd have to lack tooling to support your daily work. Because not every potential touchpoint can be run headless, and integration of HTML markup into backend templates still plays a very important role today. Be it your Rails-driven eCommerce site, a blog you run for your marketing department, or a fully custom backend-rendering based approach. Changelogs with automatic markup change detection and documentation, copy-pasteable & configurable HTML-Snippets through Storybook, and optimized JavaScript and CSS bundles lighten your load!", "tokens": 144}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Jamstack & composable integrations", "content": "Starting with a strong common ground in your Design System you should be able to integrate fitting solutions as you go. This gets especially easy when opting for React as the central building block of your tech stack. With kickstartDS components at their core already being pure, functional React components, composability should be encouraged on all levels. With a multitude of existing integrations, common tasks can be reduced to just adding the correct one to the mix! Additionally an added, optional layer of React concepts should support those use cases: - React Provider / Context - React Render Props Working on a marketing- or landing-page, or a blog? Get the page builder experience with Netlify CMS, Sanity, Tina CMS or Wordpress in combination with the official kickstartDS Gatsby theme. Building a Next.js page or application? Use our auto-generated GraphQL APIs (based on your component API), including full documentation! Everything is SSR- and ESM-compatible, too, which means you shouldn't have to worry about performance yourself!", "tokens": 218}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "kickstartDS CLI", "content": "The kickstartDS CLI, or Command Line Interface, is a tool to quickly scaffold kickstartDS components, generate and convert Design Token and provides a number of helpful commands to kickstartDS developers. In addition to installing and updating kickstartDS versions, you can generate your initial, expansive & semantic Token set from a reduced, branding-orientend JSON input, or convert your Style Dictionary-based Token set into different output formats... for example the CSS Properties used and referenced in component Token. Learn more about our CLI.", "tokens": 109}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Figma", "content": "We currently support integrating with Figma through our official Design Token library: The template includes all our Token categories (colors, spacings, typography, borders, durations, opacities and shadows), and for all of those Token categories there are pre-defined base scales and semantic Token based on those base scales. All ready to use, but customizable by just re-defining relationships. You can just copy that file and enter your own Design Token (as defined in your Style Dictionary) to have a Figma file to hand around to your designers, enabling them to use the same, semantic structure underlying your real components and interfaces. It also serves as a great illustration of your Design Token. Learn more about our token structure, and how to leverage it for yourself. We're currently working on an automatic sync option native to kickstartDS, which should work in both directions (Figma -> Style Dictionary, Style Dictionary -> Figma) and thus enable true synchronization in shared workflows. In the meantime you can add solutions like Specify to the mix, to enable at least one way sync from Figma to your Style Dictionary. We've built a preliminary pilot for this, so if you're interested in that... just hit us up! Further we're currently exploring generation of Figma UI Kits based on your single point of truth - your coded components. One such approach involves using story.to.design, which looks to be becoming quite dependable for automatic conversion!", "tokens": 300}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Ecosystem", "content": "No modern technical solutions exists in a vacuum, at least it really shouldn't. Having a lively ecosystem enables broader and quicker adoption, while sharing knowledge and common learnings with a wider, organic community. This is why we're also always actively trying to add building blocks to that ecosystem ourselves, while listening closely to which problems people are actually trying to solve.", "tokens": 74}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Tooling", "content": "While having a solid Design System can be described as the necessary start, without projects using it, this is theoretical value. This is why kickstartDS comes with ready-to-use integrations and adapters for a lot of common scenarios you might encounter while thinking about a project - like your main marketing site, your blog or the way you want to integrate design decisions into an automated process.", "tokens": 81}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Generator", "content": "Your Design System already has a really good knowledge about what a component is, how it is structured and how it behaves. We use that knowledge to provide a Gatsby theme, that already includes everything a website needs (for SEO, performance, etc). We even already have transformers for that theme for WordPress, Netlify CMS, Contentful, MDX. And if you're using Next.js we have some plugins to use your components in a performant way there too, without writing glue code yourself.", "tokens": 107}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Gatsby Theme", "content": "Our theme automates everything related to rendering your frontend (SEO, performance, etc), while also providing a common interface to implement your own transformers and resolvers. Or you just re-use one of those we've already written for: WordPress, Netlify CMS, Contentful, MDX", "tokens": 66}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Next.js Helper", "content": "Use our starter to have a project running in mere minutes, or use our plugins directly to configure everything the way you like... while still profiting from work already done. All components are completely SSR-compatible, too.", "tokens": 48}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "GraphQL Tooling", "content": "Based on our component API we have tooling (based on GraphQL Tools) to automatically generate types and fragments for GraphQL. This can be the perfect building block to creating your shared API between frontend and backend, and, for example, powers the core of our Gatsby theme.", "tokens": 62}
{"title": "Introduction to kickstartDS | kickstartDS docs", "heading": "Community", "content": "We try to have a healthy, friendly and active community. Although it's still quite small, this also enables us to respond to requests in a very hands-on fashion. Feel free to join us on Discord! If that's not your cup of tea, you can also reach out to us: - Through the chat widget, included in all of our public facing websites - By writing us an email - By joining us on Twitter - By writing us on WhatsApp", "tokens": 95}
{"title": "Everything Meta! And everything matters.", "heading": "Summary", "content": "*#tldr: in this post Daniel explains why kickstartDS is a meta framework for Design System creation and how you can benefit from it when starting to develop a Design System.*\nWhen we made the decision to develop our pattern library into an Open Source tool, we thought about many different ways to describe what the core of it is, or at that time will become:\n**kickstartDS is a â€¦**\n- Comprehensive component and pattern library for Design System\n- Adaptable framework for digital Design Systems\n- UI framework for all your headless and legacy experiences\n- Low-code framework and starter kit for Design Systems\n- Design System Meta Framework\n**All of the above is true!** When we were doing user research at that time, on a first glimpse, no one really understood what that means. Yes, our value proposition is really a tough take and in need of further explanation. That is also one reason while we came up with the rather descriptive claim â€œa starter kit for design systemsâ€.\nNevertheless, whenever I meet a client to demonstrate kickstartDS, I still use the meta-description in addition, and outline: â€œkickstartDS it is a Design System starter, you can imagine it as a Meta Framework for Design Systems.â€\nIf you are a developer, you are familiar working with frameworks of different kinds, and hence they can understand more easily why kickstartDS is a Meta Framework. Usually, they really like how we have created it and how easy it is to implement.", "tokens": 318}
{"title": "Everything Meta! And everything matters.", "heading": "A meta system", "content": "is a system that is comprised of other, smaller systems that work together to achieve a common goal. One example of a meta system is the human body, which is made up of a number of smaller systems such as the circulatory system, the digestive system, and the nervous system, all of which work together to keep the body functioning properly. Another example of a meta system is a city, which is made up of a number of smaller systems such as the transportation system, the water supply system, and the sewage system, all of which work together to support the needs of the cityâ€™s residents.", "tokens": 126}
{"title": "Everything Meta! And everything matters.", "heading": "A meta framework", "content": "is a framework that provides a structure or set of guidelines for organizing and developing other frameworks. The term â€œmetaâ€ in this context refers to the fact that the framework is concerned with the organization or structure of information, rather than the specific content of that information. We will start by looking at the concept of a â€œmeta frameworkâ€ and how it can be used to analyze the structure and dynamics of a system. A meta framework is a tool to help understand how the components of a system interact and how they can be adjusted to improve the overall performance of the system. A meta framework consists of a set of rules or principles that are used to identify and measure the different components of a system and their interrelationships.", "tokens": 151}
{"title": "Everything Meta! And everything matters.", "heading": "Example of a Meta Framework", "content": "GraphQL is an increasingly popular language for APIs. Itâ€™s also a good example of a software-oriented meta framework. Itâ€™s used to create and expose data to clients and is a powerful tool for creating a unified API layer. GraphQL allows developers to define their data schema and access rules in a single, unified layer which helps streamlining development, making code easier to integrate into existing systems and to maintain.", "tokens": 92}
{"title": "Everything Meta! And everything matters.", "heading": "Transferring the idea onto Design Systems", "content": "A design system meta framework is a set of guidelines, principles and best practices that are used to create, maintain, and evolve a Design System. A Design System is a collection of standardized design elements, such as colors, typography, iconography, and components, that are used to create a consistent, high-quality user experience across multiple products and platforms. In this sense, kickstartDS is a meta layer providing the framework for creating these design elements, using industry best practices. The underlying concepts are based on state-of-the-art industry standards. We have taken design decisions to make it easier for you to get your Design System started quickly and without investing much energy and budget.", "tokens": 146}
{"title": "Everything Meta! And everything matters.", "heading": "A tough take, it is", "content": "I can imagine Master Yoda saying this. Even within the Design System community, where you meet very knowledgeable people with broad experience and expertise in the field, explaining kickstartDS sometimes feels like talking to strangers. Maybe some of these people still do not believe that there could be something like a meta framework for Design System creation and hence just deny it already upon its idea â€“ although everyone hates to recreate basic components over and over again â€“ or it feels like we are too niche-y inside the already small niche of Design Systems.", "tokens": 113}
{"title": "Everything Meta! And everything matters.", "heading": "Asking for feedback!", "content": "What is your understanding of kickstartDS? Do you think a meta framework is helpful to get things started and sorted out quickly or not? Please let me know either on Twitter, LinkedIn, our Discord, or on Mastodon.", "tokens": 50}
{"title": "Sections | kickstartDS docs", "heading": "Style", "content": "A section style is mainly expressed by the given background color. You should make sure that the chosen background color always offers enough contrast to display various font colors! |Setting||Token||Description| |The default background color, shouldnt be percieved as a distinct surface| |A very prevelant color heavily drawing focus to the displayed content| |A light color, making it disctinct from the default background without being too heavy|", "tokens": 92}
{"title": "Sections | kickstartDS docs", "heading": "Frame Width", "content": "The width propertiy determines the with of the frame the content will be displayed in. |Setting||Token||Application| |The default frame width| |A narrow frame width| |A wide frame width| |The content spans over the entiere screen| |The content spans over the entiere screen,| without", "tokens": 68}
{"title": "Sections | kickstartDS docs", "heading": "Screen spanning layouts", "content": "For creating full screen layouts there are options of max and full. They both state that the frame spans over the entire screen. The max option still leaves content-padding to the left and right browser border. With the full option the content will be placed directly against the browser border.", "tokens": 61}
{"title": "Sections | kickstartDS docs", "heading": "Space Before / Space After", "content": "Determines how much vertical spacing a section has. |Setting||Preview||Token||Application| |The default section spacing ensuring an even rythm| |A smaller space between Sections| |---||No space between Sections|", "tokens": 52}
{"title": "Sections | kickstartDS docs", "heading": "Combining spacings", "content": "By combining the given spaceAfter/ spaceBefore options, it's possible to move sections closer together. That way you can create a visual connection between the content in two sections. You can even make them seem as a single element by removing all spacing between them.", "tokens": 55}
{"title": "Sections | kickstartDS docs", "heading": "Mode", "content": "default The children will be placed next to each other, stretched across the full section width. tile The children will be placed next to each other, in a pre set column width. list The children will be placed on top of each other, stretched across the full section width.", "tokens": 58}
{"title": "Sections | kickstartDS docs", "heading": "Gutter", "content": "|Setting||Token||Application| |---||No space between children| |A small space between children| |The default spacing between children, ensuring an even rythm| |A large space between children| none small default large", "tokens": 49}
{"title": "Sections | kickstartDS docs", "heading": "Toggle Code", "content": "_69small,_69}}_69>_69_69_69<TeaserRow_69topic=\"Components\"_69image=\"https://www.kickstartds.com/img/recipes/toolbox.svg\"_69ratio=\"none\"_69text=\"Tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod.\"_69link={{", "tokens": 130}
{"title": "Sections | kickstartDS docs", "heading": "We help you overcome digital obstacles", "content": "Autem voluptas quis facere et qui voluptate earum. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum.", "tokens": 74}
{"title": "Sections | kickstartDS docs", "heading": "Customisation", "content": "Customisation is typically done via scss files. The default token are declared on the .l-section__container selector and can be overritten there. To increase the selector accuracy, its recommended to wrap them into a :root selector. KickstartDS Sections use CSS Grid. The child elements will be placed in columns, which are arranged in rows. To get deeper into the workings of CSS Grid we recommend this article: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout The minimum width of a column is determined by --l-section_col--min-width. The maximum width of a column is determined by --l-section_col--max-width. The default value is 1fr. (Recommended for responsive layouts) The amount of columns fit in one row is determined by --l-section_col--repeat. The default value is auto-fit. (Recommended for responsive layouts)", "tokens": 200}
{"title": "Sections | kickstartDS docs", "heading": "Fill Space", "content": "If you want the available space to be efficiently used, it is recommended to leave the max-width token set to its default value of 1fr. --l-section_col--min-width: 5rem", "tokens": 46}
{"title": "Sections | kickstartDS docs", "heading": "Fixed Width", "content": "If you dont want your elements to fill the available space, you can set a max-width value in addition to min-width. --l-section_col--min-width: 5rem --l-section_col--max-width: 10rem", "tokens": 56}
{"title": "Sections | kickstartDS docs", "heading": "Scaling Width", "content": "By using a percentage on the min-width token, you can create a scaling layout. It will keep its proportions, no matter the screen size. --l-section_col--min-width: 40%", "tokens": 46}
{"title": "Sections | kickstartDS docs", "heading": "Set Columns Amount", "content": "If you use a custom value, make sure the columns do not exceed the avialable space in your layout (especially on narrow screens). You can do so by balancing out the min-width in correspondence to the set column amount. --l-section_col--repeat: 4 --l-section_col--min-width: 5rem", "tokens": 75}
{"title": "TypeScript", "heading": "TypeScript", "content": "In addition to using ES6 as a specific flavor, on top of JavaScript as a technology, we're using TypeScript for it's additional type safety and resulting confidence when developing long lasting, well-rounded frontend solutions like a component library. One additional feature of TypeScript we're relying heavily on is the ability to generate types for publishing packages. We use this to generate all component typings automatically, based on shared JSON Schema definitions, enabling auto-complete for properties defined in the context of the component... based on the generated types. kickstartDS Decision Why we care? Read more, or chat with us, to learn how this helps create consistent frontend interfaces", "tokens": 138}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Customize", "content": "Headline component This guided example shows how you'd add components to your Design System that use a kickstartDS base component pretty directly. But unlike just adapting a component, customizing a component also involves adding something to it, or changing the way certain things work under the hood, by modifying its React template (whereas extending a component does that by composing multiple kickstartDS base components). This expands possible applications of existing kickstartDS components greatly. Even while using the component rather directly from kickstartDS, you'll want to find the correct set of properties for your own use case. Components in kickstartDS come equipped with properties for a wide range of possible use cases, so it makes sense to reduce those to the ones you really need... to make components easier to understand, use and reason about! We call this type of workflow Customization. Learn more about it in our dedicated guide about it. If you're unsure about something, have a look over there. We go into more background detail there about what we're doing here. Not touching the actual markup generated by components let's us get by without adding any custom styling ( CSS / SCSS) to it. We simply reuse the already existing Design Token and component structure.", "tokens": 251}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Overview", "content": "This is how the result of this guide will look like: It will only need two simple steps for that: - Component Definition, and - Component Creation For more details about those steps, have a look at the guide about different component processes and their shared structure.", "tokens": 55}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Purpose", "content": "We like what the kickstartDS base Headline component has to offer. We just feel that we need a bit more flexibility in arranging the headlines different contents, which we try to achieve by making the order of headline and subheadline switcheable. We also want some light RTE-like content formatting options for all rendered text, while keeping the component simple by just mapping properties really needed by our use case. We take level and spaceAfter directly, and rename subheadline to sub, styleAs to style and content to text for our version of the Headline. And crucially we add our own property switchOrder into the mix. We also keep the name Headline, as it fits our use case well enough already.", "tokens": 152}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Structure", "content": "Defining the structure of a component means finding the component API for it: |Property||Type||Description| |Text content of headline| |Subheadline content| |Switch order of headline and subheadline| |Level of headline to use| |Style of headline to show| |Whether to display space after headline| Fields that should be required are marked with a *. While directly helping us get a better grasp on our new component, these will also be used to write our JSON Schema later!", "tokens": 105}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "2. Component Creation", "content": "We like to colocate components. This means to have all involved files next to each other in the same folder; the template ( .jsx / .tsx), potential CSS / SASS ( .css / .scss), JavaScript ( .js / .ts), our JSON Schema component definition ( .schema.json), and so on. So we start by creating the directory src/components/headline, from our Design System repository root: _1mkdir -p src/components/headline This is the folder we'll add new files to in the coming few paragraphs. JSON Schema definition First file we'll create is the JSON Schema definition, encoding the structure we've defined for our component before:", "tokens": 154}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Add basic info describing component", "content": "We start by adding a title, description and $id attribute. The correct $id depends on your Design System configuration. We'll assume you've created components before, living under the schema prefix http://schema.mydesignsystem.com.", "tokens": 55}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Create", "content": "text and sub fields... Both fields are straight-forward string type properties, so we just document them a bit! We do mark text and sub by setting format to markdown, though, to enable some light RTE-like formatting options of rendered text later on.", "tokens": 57}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Finished", "content": "JSON Schema Let's have a look at our completed JSON Schema definition. This concludes creating the JSON Schema. When running the schema generation in our Design System again, we should now automatically end up with a corresponding type definition to be used in creation of the template in the next step: How your schema generation is started might change depending on your setup. If you've followed our \"Create your Design System\" guide before, or want to add it like we do, follow this section of it closely. React template As the final step for this example, we'll add the template. This will be a purely functional React component, mapping our component structure (as defined in the JSON Schema) to the original component we're basing our work off of; the kickstartDS Storytelling component.", "tokens": 164}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Start with a boilerplate", "content": "Again we'll start with a very basic skeleton for our React component. We're using TypeScript here ( .tsx), but it works the same with plain JSX ( .jsx).", "tokens": 44}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Add correct typings", "content": "correct typings Import and add generated props from HeadlineProps.ts. Generated by our JSON Schema, these guarantee you're matching your expected component structure while implementing. In combination with TypeScript this enables auto-complete and auto-fix for even better DX! (see here, at the very end of that section, for more details) We also add our rendering functions and HTMLAttributes to the type signature.", "tokens": 89}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Destructure", "content": "props We also need to add our own properties, so we'll destructure props. We add our default values here, too. Because we're using rendering functions, we also need to have those in there... we'll just pass through everything HTMLAttributes related!", "tokens": 56}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Add", "content": "Headline component 1/5 As we can't use the underlying kickstartDS base component export directly, because we intend to customize its behaviour, we start with the raw component template of the original kickstartDS Headline instead. You can find its markup in our Github mono-repository here. We also write the level into TagName, which we'll use to generically render the correct markup tag for the Headline.", "tokens": 90}
{"title": "Customize `Headline` component | kickstartDS docs", "heading": "Storybook setup", "content": "This guide assumes you're using a set up like described in our Create your Design System guide! Be sure to adapt commands and configuration to your use accordingly, when following this part! Add the following file to your src/components/headline folder:", "tokens": 54}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "About", "content": "The kickstartDS CLI helps ease everyday tasks when working with Design Systems, especially when building on and with kickstartDS. It currently supports two main categories of commands: Schema: Generate TypeScripttypes for components, or dereference component JSON Schema Token: Initialize Style Dictionaryusing Branding Token, or build prepared Style Dictionaryplatforms and formats for your token set Commands can generally be divided into the following types: - Commands that thinly wrap other APIs or toolingfor you (for example Style Dictionarycommands within the tokenscategory), enabling zero-config use when following our recommended structure for your project - Commands automating tasks for you(for example creating TypeScripttypes for your components, or dereferencing them, within the schemacategory), which helps keep your project free from scripts for those tasks - Commands meant to reduce the amount of scaffoldingyou'll have to write manually. We're currently working on those! We generally strive for all the commands to work with zero config when following the project structure outlined in our documentation for your own Design System (it's also the same one used in our starter). But we also try to expose options to change those values as needed, you shouldn't ever need to follow our structure. If there's an option that's missing for your use case, feel free to contact us so when can add it! We also include support for shell completions. Though those will probably still need some more intimate knowledge with your terminal and shell setup, they can be a nice addition to explore available commands and options!", "tokens": 317}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Installation", "content": "You'll need to have Node.js installed to use our CLI, see our page about the expected environment when working with kickstartDS for details. kickstartDS CLI has to be installed for use with Node.js, which can be done through all the common package managers. You can either install it globally, or as a dependency of your Design System project.", "tokens": 76}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Install in project", "content": "Installing the CLI as part of your Design System projects helps keeping the version used across your team and consumers consistent. We generally advise going this route, and wiring up your local package.json scripts entries to those commands for isolation. Have a look at part 2 of our main guide \"Create your Design System\", for a more detailed explanation of this setup. Alternatively you can use the CLI directly, without installing it, by using npx, like this: _1npx tokens init Learn more about npx as an option to run commands globally, without installation, in the npm Docs.", "tokens": 123}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Install globally with", "content": "npm or Yarn kickstartDS CLI is available as a npm package. If you have Node.js available, you can install it by running: _1npm install kickstartds@latest -g or if using Yarn: _1yarn global add kickstartds If you're encountering problems with this, or for more details on the technical setup needed to work with kickstartDS, see our Getting Started page about the environment needed.", "tokens": 98}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Install as a part of a", "content": "kickstartDS Design System This is the preferred way of integrating the kickstartDS CLI into your workflow. It gives you the ability to fix the version of the CLI in use to the exact corresponding kickstartDS package versions, added as a dependency to your Design System. It also allows using the CLI in multiple projects, without those interferring with each other through a globally installed, shared dependency. All that said: we're being really careful with changes to the CLI, so it should only ever need to be upgraded when changing to a new breaking release of kickstartDS itself. You might still want to upgrade earlier to get access to fixes ( X.X.3) or new features ( X.2.X). See our page about Upgrading to learn more about our release process, and our versioning scheme! The preferred way to install the CLI to your Design System project would be as a devDependency. _1yarn add -D kickstartds See the following code snippet for an example of a typical (abridged) example of a package.json for a Design System project utilizing the kickstartDS CLI: We have @kickstartds/base as our main kickstartDS package dependency, and kickstartds (the kickstartDS CLI) as a devDependency. We also include React to complete our dependencies, while chokidar-cli and npm-run-all help us glue together kickstartDS CLI commands with our local scripts entries, as the remaining devDependencies. There are three integration types at play here: 1. Wire up a script entry to a CLI command directly (optionally setting parameters as required), 2. Run select scripts in parallel (using npm-run-all) to improve DX, by grouping commands commonly used together, and 3. Watch for file changes, to subsequently trigger a script entry... enabling a watch / hot reload mode (using chokidar-cli). For a more detailed description of what all those commands do, have a look at our \"Create your Design System\" guide.", "tokens": 429}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Getting started", "content": "Once you've installed the kickstartDS CLI, you can verify everything works as expected by running the following command: _1kickstartDS --help You'll notice the version of the CLI used is part of the logs, written by every command you run. This can help narrow down problems when debugging errors. You can also get the version by calling --version directly: _1kickstartDS --version The CLI should generally be pretty explorable by itself, so feel free to just follow the output provided by --help to find out about about commands, options, etc. There are some general options that can be included with every command, and you can integrate the CLI with your terminal / shell, too. We'll explore both in the two upcoming sections.", "tokens": 155}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "General options", "content": "The following options each influence how your command will be run, and can be used with all commands included: |Option||Default Value||Description| |Adds additional debug output to the logging| |Don't quote the user for input, read from environment and parameters| |Inverse of the command, useful for reverting unwanted changes| |Clean up temporary folders used first| If an option is not set the default value will be used for it. To learn more about --cleanup, --revert and --rc-only have a look at the features section below.", "tokens": 118}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Setting up shell completions", "content": "You can set up local shell completions for your terminal by simply calling the completion install command: _1kickstartDS completion install You can also remove completions again by using the inverse completion remove: _1kickstartDS completion remove We use omelette under the hood to enable the completion features, see their section about Automated Install for details on how this is achieved for different shell flavours. This can be especially helpful if something is not working out-of-the-box for you!", "tokens": 105}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Shell support", "content": "This is a really early feature. As there are a lot of different terminal and shell combinations out there, we pretty much expect this to still be pretty unstable, because it is not widely tested. We'd love to hear your experience (Did it work? Did it to what you expected?), so we can continue improving this!", "tokens": 68}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Features", "content": "Next to General options there's also some more general features in use throughout all CLI commands. Read through the following paragraphs for details on those features, what they're used for, and how you can use them.", "tokens": 45}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Interactive prompts and", "content": ".rc files Though not in use for the basic commands implemented currently, every command can specify a corresponding .rc file to set options to be used by default. If not using .rc files (this is toggled through the general option --rc-only, true by default), or if the .rc file is missing some required parameters, you'll be prompted for those interactively. To have a reliable structure when doing this, and to easily provide defaults when omitted, we've opted to add JSON Schema definitions for all of our commands. This is the one defining kickstartDS tokens compile: https://github.com/kickstartDS/kickstartDS-cli/blob/next/.tokens-compilerc.schema.json There's also a base config included for every command, which provides the defaults in case --rc-only is supplied without a local .rc file in your project, or if that .rc file is missing some values. This is the one corresponding to the default .rc file for kickstartDS tokens compile from above: https://github.com/kickstartDS/kickstartDS-cli/blob/next/.tokens-compilerc.json Interactive prompts for commands are generated dynamically based on the supplied JSON Schema, using name, type, default and description from the definition, to help make useful choices. Especially type is used to present prompts semantically, using Inquirer.js. Defaults are first pulled from your local .rc file (even if using --rc-only set to false, to have better contextual defaults presented to you), and then the fallback .rc file provided by kickstartDS. e.g. https://github.com/leonzalion/inquirer-press-to-continue This setup provides a scalable approach to creating commands that can both work in a zero config way, while also being able to overwrite configuration (even if only granularly)... even in the most complex scenarios. It also allows persisting your configuration as part of your repository, so you can always repeat the exact process, or review the choices you made when running something like kickstartDS tokens init.", "tokens": 452}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Temporary folders", "content": "Everything needed to complete a command will be copied to a temporary folder, first. Results will then be copied back to your project / execution context if, and only if, the command that was run completed successfully. This ensures changes will be done in isolation, in a controlled environment. Additionally this avoids corrupting your project with output resulting from a failed command. Every command and subcommand combination uses a unique folder name combination to avoid conflicts when mulitple commands are run (e.g. tokens-init-init-task for the init subcommand of the tokens command). The exact location of the temporary folder used depends on your OS, but it should be part of the log output when running a command... e.g.: _1[init: cleanup] info: cleaning up temp dir /tmp/tokens-init-init-task before starting command Here /tmp/tokens-init-init-task would be the temporary folder in question on a Arch Linux OS (for macOS this slightly differs, for example).", "tokens": 212}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Revertability", "content": "We strive to implement a corresponding revert / rollback variant for every command, behind the --revert switch. This in part works by using the aforementioned temporary folder. While having such a general structure in place is necessary, it's also required to write commands in a way that the original starting point is preserved inside the temporary folder. This is something to be done by the author of new commands, and needs great care! Additionally, having a --revert variant available may not always be feasible or sensible. Those commands not having such a variant will be explicitly marked, including a short reasoning for not implementing it.", "tokens": 125}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Currently testing", "content": "The --revert variants of the tasks implemented so far are currently being tested. If you're stumbling over one not working as expected, please feel free to open an issue on our Github.", "tokens": 41}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Available commands", "content": "As hinted at before, commands are generally split into categories by some shared concept or use case. We currently have categories for Design Token ( token) and JSON Schema ( schema). Token category: Commands around working with your Design Token set. |Command||Subcommand||Description| |Initialize your |Design Token set from Branding Token |Compile your |Design Token set into all configured Style Dictionary formats / outputs |Sync your |Design Token set to Figma (work in progress) Schema category: Commands around working with your JSON Schema. |Command||Subcommand||Description| |Create |TypeScript types matching your components JSON Schema |Dereference |JSON Schema files for easier consumption Both categories and their subcommands will be described in a bit more detail below. Design Token commands Commands in this category are used to deal with every type of token present in your Design System. Namely Branding Token for initial token set generation, Design Token managed in Style Dictionary, and Component Token used by your components. For a detailed setup guide for everything related to Design Token, give part 2 of \"Create your Design System\" a visit. tokens init Initializes your Design Token set from a Branding Token file. Includes options to specify a specific file path for your branding token file ( --branding-token-path), and a path for the dictionary ( --token-dictionary-path), to set the location to store your Design Token set. See the section \"2. Design Application\" > \"Initialization\" of our main guide \"Create your Design System\" to learn more about this setup. Available options: |Option||Default||Description| |relative path from project root to your branding token file| |relative path from project root to your token dictionary| Default values are in alignment with the main guide, its corresponding repository, and the starter project. Which means in those cases, or if just following our best practices, you'll be able to use the subcommand without specifying any special options. tokens compile Takes your Design Token set (a collection of JSON files in Style Dictionary format), and compiles them to a set of different output formats. Internally a configuration file for Style Dictionary ( sd.config.cjs format) is included, that defines a base set of formats ( jsx, storybook) to be used when no local configuration file is found in your project. You can find the responsible code for this here in our repository, for reference. The resulting files are saved to the locations specified (per format) either by the included Style Dictionary config, or by the one provided inside your project ( sd.config.cjs), the location of your Design Token set you can use --token-dictionary-path. See the section \"2. Design Application\" > \"Compile Design Token set\" of our main guide \"Create your Design System\" to learn more about this setup. Available options: |Option||Default||Description| |relative path from project root to your token dictionary| Default values are in alignment with the main guide, its corresponding repository, and the starter project. Which means in those cases, or if just following our best practices, you'll be able to use the subcommand without specifying any special options. tokens tofigma Takes your Design Token set (a collection of JSON files in Style Dictionary format), and syncs them to a clone of our Figma token file. You can configure the location of your Design Token set by using --token-dictionary-path.", "tokens": 718}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Work in progress", "content": "This command is currently work in progress. It will support syncing your Design Token set / Style Dictionary to a copy of our Design Token template for Figma. When this command is finished, we'll add the other direction ( fromfigma), too. This will enable you to always keep Design Token in sync between code and design! Status: JSON Schema matching our Figma template down to every label, layer and description. Can already be used to validate the structure of a Figma file. Next up will be pulling the values out from the Figma template instance, to transform and write them to your Design Token set. Available options: |Option||Default||Description| |relative path from project root to your token dictionary| Default values are in alignment with the main guide, its corresponding repository, and the starter project. Which means in those cases, or if just following our best practices, you'll be able to use the subcommand without specifying any special options. JSON Schema commands Every component based on kickstartDS includes a JSON Schema definition for its component API. Commands in the schema category help transform those definitions into other helpful formats like TypeScript types, or deferenced versions of the schema. schema types Generate TypeScript types for your components, matching your component API / JSON Schema exactly. These types can then be used when implementing your React template, providing a stable base to rely upon. Generated type definitions are put alongside the JSON Schema files, into the components directory. You can set the path components are placed inside your Design System using --components-path, if you're not using the directory structure presumed in our guides, examples and starter. You'll always have to provide a domain that is used in your JSON Schema definitions by specifying --schema-domain (e.g. --schema-domain schema.mydomain.com). See our component example guide \"Adapt Button component\", especially the end of section \" JSON Schema definition\" and the subsequent section on the \" React template\" for an example of this at work. Available options: |Option||Default||Description| |relative path from project root to your components directory| |domain used in your JSON Schema $id fields| Default values are in alignment with the main guide, its corresponding repository, and the starter project. Which means in those cases, or if just following our best practices, you'll be able to use the subcommand without specifying any special options. schema dereference JSON Schema definitions for component APIs can (and often do) include references to other component definitions. This is done by the way of using a $ref in one of the properties, or by using advanced workflows involving allOf, anyOf, oneOf and so forth. Because we generate Storybook Controls and documentation for all of the properties of a component (including the referenced ones), we use this command to \"dereference\" all of those keywords. This results in a dereferenced version of the JSON Schema with all references resolved and inlined. This can then be used then without involving complex, or computationally expensive, conversions on the client. You can set the path components are placed inside your Design System using --components-path, if you're not using the directory structure presumed in our guides, examples and starter. You'll always have to provide a domain that is used in your JSON Schema definitions by specifying --schema-domain (e.g. --schema-domain schema.mydomain.com). Follow the links to learn more about the integrations we provide for Storybook in general, or Storybook Controls specifically. See the following example on Github to see such a dereferenced schema at work. Available options: |Option||Default||Description| |relative path from project root to your components directory| |domain used in your JSON Schema $id fields| Default values are in alignment with the main guide, its corresponding repository, and the starter project. Which means in those cases, or if just following our best practices, you'll be able to use the subcommand without specifying any special options.", "tokens": 842}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Usage in CI/CD", "content": "Using the kickstartDS CLI as part of your CI/CD should be pretty straight-forward. If you went the \"Install as a part of a kickstartDS Design System\" route, you only need to make sure to include all the needed environment variables for your build to work (stuff like NODE_ENV=production), the rest will be managed by npm. If you installed the CLI globally, you'll additionally have to make sure it will be installed in the environment used by your CI/CD when building, too! This can be done by simply adding a line installing it before the actual build command is triggered (like yarn global add kickstartds).", "tokens": 139}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Tips, Tricks and Gotchas", "content": "This section will cover some useful information that should help when working with the CLI. It ranges from tips on how to recover from errors to how you can debug a CLI command not running correctly.", "tokens": 44}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Recover from errors / problems", "content": "If something failed, or was broken by running a CLI command, you can always have a look at the generated temporary folder. All processing will be done in such a temporary folder, only at the end copying the generated result back to your project folder / execution context on success. In case something went horribly wrong, you can always look up that folder to potentially recover your previous state. See the section above about temporary folders for details.", "tokens": 92}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Debug long running commands", "content": "Some commands might be long running in the future. If it's a specific step, pretty late in the process, that fails, you can consider setting --cleanup to false. This should then pick up your command from the last known state when running again, based on the involved temporary folder. This can be especially useful if that last step only failed because an API wasn't available for a short time frame, or something comparable.", "tokens": 91}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Getting support", "content": "To get support, you can always have a look at the issues on our Github repository, or open one yourself if you've stumbled upon something broken or incomprehensible. When doing so, make sure to always include the log output of the command run. Especially the kickstartDS CLI version number used, part of that output, is of interest here! You can also join us on Discord. And if that's not your cup of tea, you can reach out to us: - Through the chat widget, included in all of our public facing websites - By writing us an email - By joining us on Twitter - By writing us on WhatsApp", "tokens": 129}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "Contributing", "content": "Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as below, without any additional terms or conditions. There's one additional command included with kickstartDS CLI, not mentioned before. It's the demo subcommand of the example command, which is just included as a reference to be used when creating new commands. This ensures having the basics in place, and helps you get started way faster!", "tokens": 104}
{"title": "kickstartDS CLI | kickstartDS docs", "heading": "References", "content": "Building a CLI with this range of features wouldn't have been possible without a solid foundation to build upon. We'll list our main dependencies here, to give you an idea of the general tooling in use: |Dependency||Link||Description| Inquirer.js |https://github.com/SBoudrias/Inquirer.js/||We use |Inquirer.js to dynamically generate context-sensitive prompts based on the commands JSON Schema. Commander.js |https://github.com/tj/commander.js/|Commander.js serves as the foundation for isolated implementation of the different commands, and provides CLI option handling. Omelette |https://github.com/f/omelette|Omelette provides auto-complete features and a managed shell integration ShellJS |https://github.com/shelljs/shelljs/||To have consistent behaviour (over |macOS, Linux and Windows) when interacting with shell features inside of commands we use ShellJS. winston |https://github.com/winstonjs/winston||Everything related to logging is handled by |winston. It provides the structure for having multiple transports, writing to the prompt, files, etc. Chalk |https://github.com/chalk/chalk||Nice colors that work across as many terminals and shells as possible made possible by |Chalk. Simple Git |https://github.com/steveukx/git-js||Nice abstraction upon |Git, with a nice API to wrap Git related tasks with. Nunjucks API |https://mozilla.github.io/nunjucks/api.html||Mighty and expressive templating engine, we use the | Nunjucks Templating |https://mozilla.github.io/nunjucks/templating.html||This is the heart of |Nunjucks, used for consistent and efficient templating of all kinds of templates. This can also serve as a great source of inspiration when trying to identify easy to implement extension opportunities for features, commands or options you feel currently missing!", "tokens": 445}
{"title": "Gatsby | kickstartDS docs", "heading": "Gatsby", "content": "Gatsby is a framework helping developers build websites faster and with better results overall, while being compatible with a wide range of other systems out-of-the-box. Gatsby enables developers to build fast, secure, and powerful websites using a React-based framework and innovative data layer that makes integrating different content, APIs, and services into one web experience incredibly simple. We have a feature complete Gatsby theme coming up, which automatically enables all of your (own, custom!) components to be usable on your website without additional work. You can see the Gatsby theme in action today, on our own website: https://www.kickstartDS.com To learn more about Gatsby, visit their official website.", "tokens": 152}
{"title": "Gatsby | kickstartDS docs", "heading": "Features", "content": "Using our upcoming theme will mean benefitting from included Gatsby Node definitions for kickstartDS compatible pages, and even already existing resolvers to connect to one of the following CMS as a headless content providers: - WordPress (see our own blog for an example of that combination): https://www.kickstartDS.com/blog/ - Contentful (see our glossary for an example of that combination): https://www.kickstartDS.com/glossary/typescript/ - Netlify CMS (see our main marketing- and landing pages): https://www.kickstartDS.com/ - MDX", "tokens": 134}
{"title": "Gatsby | kickstartDS docs", "heading": "Templates", "content": "Ready-made templates include (you can preview them in our Storybook): - Content Page (Storybook) - Glossary Entry Page (Storybook) - Blog List Page (Storybook) - Blog Detail Page (Storybook) This allows for extremely flexible combinations of data sources for your website, all while using one uniform frontend (your Design System) and minimizing implementation work, even when creating your completely new and custom transformer.", "tokens": 90}
{"title": "Packages | kickstartDS docs", "heading": "Packages", "content": "Packages in programming are commonly used to divide up code into distinctly (re-)usable blocks of functionality. (Almost) every programming language has its own version of handling packages, package dependencies and package installation. As we're using Node and JavaScript / TypeScript as our programming language of choice, our package registry will be npm. To read more about this topic, have a look at the \"Environment\" chapter of this section. On this page, we'll try to give an overview to all the packages we've created in the context of working with Design Systems and kickstartDS.", "tokens": 119}
{"title": "Packages | kickstartDS docs", "heading": "Overview", "content": "kickstartDS is split into a bunch of different packages. This way you can pick and choose which parts you actually want to use in your own setup. Not every package will be used directly, as there are existing dependencies between those packages, too. For example adding @kickstartds/base to your project will automatically also add @kickstartds/core in an up-to-date and compatible version. Packages get published on npm, you can see a full list here: https://www.npmjs.com/org/kickstartds We typically use different channels for different stabilities: latestis connected to the masterbranch on our mono-repository, always contains the latest stable release nextis connected to the nextbranch on our mono-repository, always contains the next feature release that's in preparation betais connected to the betabranch on our mono-repository, always contains the next breaking release that's in preparation canaryis connected to all branches that have an active PR open on Github, and generates a Canary release specific to that branch, for isolated, early testing This also aligns with our semantic versioning scheme. Breaking changes ( X.0.0) mature through the beta channel before being merged to latest, feature releases ( 1.X.0) go through next and fixes ( 1.0.X) land on latest directly. As every change introduced to these channels will have gone through a PR on Github, it will also have included a Canary release for it. All branches auto release based on merged PRs All releases get published on Github, too. So you can also use that as a reference: https://github.com/kickstartDS/kickstartDS/releases To learn more about Auto, Semantic Versioning and release handling you can read some background information on the \"Upgrading\" page, in the following section. We've categorized all the packages existing (right now) below, so feel free to have a closer look!", "tokens": 413}
{"title": "Packages | kickstartDS docs", "heading": "Component modules", "content": "Those are packages containing components to use as building blocks when creating your Design System. Every module is dependent on @kickstartds/core, for its shared core functionality. And all modules except @kickstartds/content are freely available to install right away. If you want to use our content module, have a look at the section about it below. We try to slice modules by the use cases its components enable, or the type of interface built using them. Core module @kickstartds/core contains shared functionality, that get's consumed by other component modules implementing components. Every other component module will have @kickstartds/core as a dependency. Some of the things included: - Generally shared helper components (like Containerto build up container query based components) - Shared Client-side utilities / functionality (like _ks.radiofor event-based communication between components) - Base Storybookstories for Design Token(for those base token are the same in every Design System based on kickstartDS) - Helpers used to enrich components in Storybook(like automatically generating all the Controlsfor you) - Utilities to help constructing Reacttemplates (like createProviderfor easy creation of kickstartDScomponent Providers) You can find this package on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/core| |Our |Github mono-repository |https://github.com/kickstartDS/kickstartDS/tree/master/packages/components/core| |https://github.com/kickstartDS/kickstartDS/blob/master/packages/components/core/CHANGELOG.md| Base module @kickstartds/base has all the obvious, and mostly simple, components. Those are like the smallest lego bricks in your collection... you use them to build up to bigger ones. Some components included here, to get a feeling: Buttonfor everything that should look like a button (Storybook) Headlinefor expressive and flexible headlines (Storybook) TextMediato arrange text and images / videos (Storybook) ContentBoxfor more condensed inline content (Storybook) TeaserBoxto tease something that's linked (Storybook) Sectionto organize components into pages (Storybook) For a complete list of components have a look at the following folder: https://github.com/kickstartDS/kickstartDS/tree/master/packages/components/base/source Or have a look through the BASE category (part of the left sidebar) in our Storybook: https://www.kickstartds.com/storybook/ You can find this package on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/base| |Our |Github mono-repository |https://github.com/kickstartDS/kickstartDS/tree/master/packages/components/base| |https://github.com/kickstartDS/kickstartDS/blob/master/packages/components/base/CHANGELOG.md| Content module @kickstartds/content has bigger, more feature-rich components used to build expressive and rich marketing- and landing-page type websites and interfaces. It's also our first commercial component module, meaning it's not available to install freely. You have to get access to it on Github and npm through acquiring a usage license from us. We think this module is a nice addition when building your Design System, but it's in no way a necessity. By offering this as a paid module, we enable further development of kickstartDS... while also delivering great value in the components offered. We're pretty sure you're always coming out ahead when choosing between using our content module and building similar components yourself!", "tokens": 799}
{"title": "Packages | kickstartDS docs", "heading": "kickstartDS Content Module", "content": "The perfect addition to our Open Source base The Content Module includes seven rich components: Hero visual, Quote, Storytelling etc. â€” everything you need to build beautiful content experiences or to enrich your existing Design System Components included with our paid module: CountUpto display a flexible amount of number counting elements (Storybook) LogoTilesto show a variable amount of logos in a grid-like way (Storybook) Quotefor flexible and rich versions of quotes (Storybook) Storytellingfor ultimate flexibility for image and text combinations (Storybook) Visualfor big, visual teasers involving one prominent image or video (Storybook) For a complete list of components have a look at the following folder (access needed): https://github.com/kickstartDS/content/tree/master/source Or have a look through the CONTENT category (part of the left sidebar) in our Storybook: https://www.kickstartds.com/storybook/ You can find this package on (access provided): |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/content| |Its own |Github repository |https://github.com/kickstartDS/content/tree/master| |https://github.com/kickstartDS/content/blob/master/CHANGELOG.md| Form module @kickstartds/form contains all the basic form elements typically used in web interfaces. It doesn't include validation or form behaviour, but is concerned with styling form elements according to your brand / Design Token set. Components included here: Checkboxfor single checkboxes (Storybook) CheckboxGroupfor grouped checkboxes (Storybook) RadioButtonfor single radio buttons (Storybook) RadioGroupfor grouped radio buttons (Storybook) SelectFieldfor select fields (Storybook) TextAreafor text area fields (Storybook) TextFieldfor text input fields (Storybook) For a complete list of components have a look at the following folder: https://github.com/kickstartDS/kickstartDS/tree/master/packages/components/form/source Or have a look through the FORM category (part of the left sidebar) in our Storybook: https://www.kickstartds.com/storybook/ You can find this package on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/form| |Our |Github mono-repository |https://github.com/kickstartDS/kickstartDS/tree/master/packages/components/form| |https://github.com/kickstartDS/kickstartDS/blob/master/packages/components/form/CHANGELOG.md| Blog module @kickstartds/blog contains all the components needed to build a nice looking blog, compatible with your Design System. You can have a look at our kickstartDS blog for an example of the components in action: https://www.kickstartds.com/blog/ Included components: PostAsideto tease author, blog meta data and sharing options (Storybook) PostHeadas ahead element for an entry, including tags, headline and cover image (Storybook) PostMetato show blog meta data, used by PostAside(Storybook) PostShareBarfor sharing an entry, also used by PostAside(Storybook) PostTeaserto tease a blog entry (Storybook) For a complete list of components have a look at the following folder: https://github.com/kickstartDS/kickstartDS/tree/master/packages/components/blog/source Or have a look through the BLOG category (part of the left sidebar) in our Storybook: https://www.kickstartds.com/storybook/ You can find this package on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/blog| |Our |Github mono-repository |https://github.com/kickstartDS/kickstartDS/tree/master/packages/components/blog| |https://github.com/kickstartDS/kickstartDS/blob/master/packages/components/blog/CHANGELOG.md|", "tokens": 908}
{"title": "Packages | kickstartDS docs", "heading": "Tooling packages", "content": "There are some packages used internally ( @kickstartds/bundler) by kickstartDS, while others are also meant to be consumed in your own project to enable specific integrations in an easy way (like having a kickstartDS compatible Style Dictionary config ready to use in @kickstartds/style-dictionary) or helping in every day tasks (like kickstartds). kickstartDS CLI kickstartds holds our CLI, and is the only package not published under the @kickstartDS org namespace, living directly at kickstartds instead. It's used to initialize and compile Design Token sets, generate TypeScript types for components and dereferenced JSON Schema files for you. To learn more about it, have a look at our \"CLI Usage\" page. You can find the CLI on: |Category||Link| npm package registry |https://www.npmjs.com/package/kickstartds| |Its own |Github repository |https://github.com/kickstartDS/kickstartDS-cli| |https://github.com/kickstartDS/kickstartDS-cli/blob/main/CHANGELOG.md| kickstartDS Bundler @kickstartds/bundler contains the bundler we use internally when releasing ready-to-consume packages on npm. This includes (non-exhaustive): - Generating JSON Schemasready for consumption - Generating TypeScripttypes for auto-completion - Transpiling code to be browser-compatible - Generating CSSbundles from SCSS If you're wondering how you'd do that in your own Design System, have a look at the final step of our main guide \"Create your Design System\". We describe one way to do it there, but this setup will always heavily depend on your specific set of circumstances... and the projects that you plan on using your Design System in. You can find the bundler on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/bundler| |Our |Github mono-repository |https://github.com/kickstartDS/kickstartDS/tree/master/packages/tools/bundler| |https://github.com/kickstartDS/kickstartDS/blob/master/packages/tools/bundler/CHANGELOG.md| Style Dictionary integration @kickstartds/style-dictionary provides a directly re-usable Style Dictionary configuration. Either consume a completely kickstartDS-compatible base config from this, or build up your own config using kickstartDS building blocks (like filters, formats, parsers and templates). Style Dictionary is used as a tool to manage your Design Token set. All your atomic design decisions get encoded in standardized JSON, ready to be transformed to all the outputs you might need. For kickstartDS this currently means converting your Design Token set to component-compatible CSS Custom Properties (CSS variables). Those, in turn, are used inside components by defining Component Token. But it could also mean exporting them in a format compatible with iOS, Android development, or to generate brand-compliant theming inputs for Material UI / MUI, Bootstrap or SAP Fiori. To learn more about Style Dictionary in general, visit their website. You can find our Style Dictionary utilities on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/style-dictionary| |Our |Github mono-repository |https://github.com/kickstartDS/kickstartDS/tree/master/packages/tools/style-dictionary| |https://github.com/kickstartDS/kickstartDS/blob/master/packages/tools/style-dictionary/CHANGELOG.md| Storybook addons Storybook earns its own category here, because using Storybook as your Design Systems workbench is one of the core choices we made when creating kickstartDS. This is also implied when using kickstartDS for yourself, as our approach to development utilizies, and profits from, Storybooks immensely. Case in point: we've written some addons for Storybook to bridge the gap between kickstartDS-specific implementation choices (like using JSON Schema or Component Token) and your general, known usage of Storybook to test and develop components. We still try to write those addons in a way that they're useful outside of kickstartDS, too. But they're especially useful when combined! JSON Schema addon @kickstartds/storybook-addon-jsonschema is an addon we wrote to display JSON Schema documentation for your component API, including a validating JSON Code Editor with semantic auto-complete, the ability to interact with your components, and copy configurations with ease. To learn more about this addon, view our dedicated integrations page about it. You can find this addon on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/storybook-addon-jsonschema| |Its own |Github repository |https://github.com/kickstartDS/storybook-addon-jsonschema| |https://github.com/kickstartDS/storybook-addon-jsonschema/blob/main/CHANGELOG.md| Component Token addon @kickstartds/storybook-addon-component-tokens is an addon we wrote to display Component Token directly alongside your component in Storybook. This enables you to inspect token assignment or layering, you can even experiment by changing tokens around and testing the result by browsing through the rest of your Storybook (changes to your tokens made this way are persisted for your browser session). To learn more about this addon, view our dedicated integrations page about it. You can find this addon on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/storybook-addon-component-tokens| |Its own |Github repository |https://github.com/kickstartDS/storybook-addon-component-tokens| |https://github.com/kickstartDS/storybook-addon-component-tokens/blob/main/CHANGELOG.md|", "tokens": 1342}
{"title": "Packages | kickstartDS docs", "heading": "Configuration packages", "content": "All the packages listed here include ready-to-use configuration for coding best practices, and tools related to that (e.g. linting with ESLint or Stylelint). Those are the configurations we use when developing kickstartDS itself, but it can make a lot of sense of just using them for your own Design System, too. Especially if you don't need anything super special, or don't feel like implementing it yourself. Auto configuration @kickstartds/auto-config contains a configuration for Auto, a tool to generate releases based on semantic version labels on pull requests. Learn more on their Github or dedicated website for the tool. We use this ourselves, to generate releases for all of our npm packages. Have a look at part 5 of \"Create your Design System\" for a deeper look on how this can work for your own Design System. You can find this config on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/auto-config| |Our |Github mono-repository |https://github.com/kickstartDS/config/tree/master/packages/auto| |https://github.com/kickstartDS/config/blob/master/packages/auto/CHANGELOG.md| ESLint configuration @kickstartds/eslint-config contains the ESLint config we use when developing code. It enables consistent code formatting for JavaScript / TypeScript, and in the process reduces diffs when changing code. It also recommends best practices, and helps avoid using bad code patterns. We use airbnb-base and prettier as a baseline, with some slight mutations for our own use. You can easily re-use this for your own Design System! Learn more about ESLint on their dedicated website. You can find this config on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/eslint-config| |Our |Github mono-repository |https://github.com/kickstartDS/config/tree/master/packages/eslint| |https://github.com/kickstartDS/config/blob/master/packages/eslint/CHANGELOG.md| Stylelint configuration @kickstartds/stylelint-config holds the Stylelint config we use for our CSS and SCSS authoring. It does pretty much the same for CSS as ESLint does for your JavaScript / TypeScript. Like with @kickstartds/eslint-config we haven't reinvented the wheel here. We're basing off of standard-scss, sass-guidelines and prettier. As with @kickstartds/eslint-config, you can easily re-use this for your own Design System! Learn more about Stylelint on their dedicated website. You can find this config on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/stylelint-config| |Our |Github mono-repository |https://github.com/kickstartDS/config/tree/master/packages/stylelint| |https://github.com/kickstartDS/config/blob/master/packages/stylelint/CHANGELOG.md| kickstartDS packages The following packages are used for our own purposes. For example to create our main marketing page, our documentation, our branded Storybook, and so on. These can be interesting to see how we've used kickstartDS ourselves. This currently (in a published form) includes the repository containing our own Storybook instance / Design System. kickstartDS Design System @kickstartds/design-system is our Design System, and includes all of our kickstartDS branded component versions. This can be a great place to find inspiration, as we've used the concepts described throughout this documentation ourselves, to build up our own website. You can find it here: |Category||Link| |Hosted |Storybook |https://www.kickstartds.com/storybook/| npm package registry |https://www.npmjs.com/package/@kickstartds/design-system| |Its own |Github repository |https://github.com/kickstartDS/kickstartDS-storybook| |https://github.com/kickstartDS/kickstartDS-storybook/blob/master/CHANGELOG.md|", "tokens": 956}
{"title": "Packages | kickstartDS docs", "heading": "Misc packages", "content": "This leaves us with some packages that can't quite fit the categories above. Currently this is only @kickstartds/json-schema-viewer, which gets utilized by our JSON Schema addon ( storybook-addon-jsonschema). JSON Schema viewer @kickstartds/json-schema-viewer is a fork of atlassian/json-schema-viewer. We forked that project to update the bundling to enable compiling it for the browser, and export some components more directly for consumption. It's used inside @kickstartds/storybook-addon-jsonschema, see its section above for more details. You can find this fork on: |Category||Link| npm package registry |https://www.npmjs.com/package/@kickstartds/json-schema-viewer| |Its own |Github repository |https://github.com/kickstartDS/json-schema-viewer|", "tokens": 208}
{"title": "Customize a component | kickstartDS docs", "heading": "Overview", "content": "Customizing a component should be part of your arsenal if you already have a specific kickstartDS component in mind, but it's missing a certain feature that you require. Instead of starting from zero, you can always just customize existing base components for your own purposes. It involves the same rough steps as adapting a component, but differs from it when it comes to creating the React template. Instead of (only) using the base component directly as imported, and just re-wiring properties, we customize the markup the base component uses to include our own behaviour. Everything else will basically be the same.", "tokens": 123}
{"title": "Customize a component | kickstartDS docs", "heading": "Customizing vs Extending", "content": "In both processes we add new features to a component, which results in it fitting one of the use cases we have in mind for our Design System. In the case of customizing a component, we either change the way a property of an existing kickstartDS base component behaves, or we add a new property to it altogether. But it's always a change that results in customizing the React component template, too. For example: adding a switchOrder property to the Headline. When extending a component, we take one existing kickstartDS base component and compose it with other kickstartDS base components to gain new functionality. We don't change the React component template in the process. For example: adding call-to-actions to our Section. Both processes can be combined in a component, if needed! Additionally this can of course also be used while creating a component, (see our TeaserCard component example for that). Or be used while extending a component that expands on some kickstartDS base component (see our Section component example for that). To learn more about the different processes available to you when creating a component with kickstartDS, have a look at the overview page of this section.", "tokens": 246}
{"title": "Customize a component | kickstartDS docs", "heading": "Customization process", "content": "As with the adaptation process, the big assumption here is that you already have a kickstartDS base component in mind. But unlike in that one, we have some requirement or feature that is not covered by it. We almost have a match. Additionally, the change required involves changing the component itself... not adding other kickstartDS base components into the mix. That would be covered by the extension process, instead. Finding your component definition is still very simplified, we just have to add those properties not covered by the base component into the mix ourselves.", "tokens": 113}
{"title": "Customize a component | kickstartDS docs", "heading": "Adaptation process as a base line", "content": "If you've read our \"Adapt a component\" guide you probably already know this: This guide expects you to reduce the set of props offered by kickstartDS components, when used as a base component. We'll also skip over, or significantly shorten, parts already covered by that guide. If unsure about something, best cross-reference it! If you don't have a kickstartDS base component in mind yet, you're probably better served by our guide \"Create a component\". In that guide, you'll start off without a specific component in mind. This means defining a structure (someting you probably have an idea about already) first, and then mapping that structure to a fitting component second. We also have an example for this with \"Create Teaser Card component\". If you're still unsure, then maybe you're still missing a clear picture on what your components should look like. In that case, you should probably take a step back first, and maybe start a Design System Initiative to narrow down on what components you'll really need. There are two main steps in customizing a component: - Component definition, and - Component creation Let's get right to it!", "tokens": 244}
{"title": "Customize a component | kickstartDS docs", "heading": "1. Component Definition", "content": "The customizing process starts by defining a component API. As with the adaptation process this mainly means selecting a set of props from the pool of props available through your selected base component. But this time, we'll also add a requirement that's not covered by the base component. We'll use the Headline component throughout this guide to illustrate concepts. This will not be an exhaustive example, though. For that have a look at our guide \"Customize Headline component\". As our additional requirement, we'll want to be able to switch the order of the main und sub headlines. That's not something the base Headline can do, so we'll add this ourselves. We also want to be able to render some light RTE-like markup in our headline and subheadline, to emphasize something with by making it bold for example.", "tokens": 172}
{"title": "Customize a component | kickstartDS docs", "heading": "Purpose", "content": "There's not a lot different here when compared to the adaptation process. We just mainly keep close to the original purpose of our chosen kickstartDS base component. There should be an exception though, as we have a requirement on our mind that is not part of the component yet. This will probably be part of the purpose of our component. For our Headline example, this could mean adding more flexibility being that requirement. We might want our component to fit more use cases, by switching said order in specific circumstances, and allowing additional code formatting for its content.", "tokens": 115}
{"title": "Customize a component | kickstartDS docs", "heading": "Structure", "content": "We'll also still start by defining a rough draft of our component API here. Let's keep going with our Headline component as an example. We're starting with the following properties: |Property||Type||Description| |Select the headline level to use, or p alternatively| |Select the headline style to use| |Choose an alignment for the headline| |Text content for the headline| |Text content for the optional subheadline| |Add additional spacing to the bottom of the headline| |Additional Classes| |Optional custom component identifier| Fields that should be required are marked with a . For the detailed documentation have a look at the Headline in our Storybook* here: https://www.kickstartds.com/storybook/?path=/docs/base-headline--h-1 One potential set of props, it's also the one used in our guide \"Customize Headline component\" if you're wondering, would be the following: |Property||Type||Description| |Text content of headline| |Subheadline content| |Switch order of headline and subheadline| |Level of headline to use| |Style of headline to show| |Whether to display space after headline| We took level and spaceAfter directly, and renamed subheadline to sub, styleAs to style and content to text for our version of the Headline. And crucially we add our own property switchOrder into the mix. Required fields are marked with a * again.", "tokens": 304}
{"title": "Customize a component | kickstartDS docs", "heading": "2. Component Creation", "content": "In the second and final step we'll get to actually create our component. We'll encode the component API by creating its JSON Schema, and create a React template matching our selected properties to the kickstartDS base component. While creating that template, we'll add the markup changes necessary to fit our additional requirement into the component. JSON Schema definition We establish the structure of components by creating a JSON Schema for them, defining their component API in code. This time we add our own, new property into the mix. For an abridged version of that process, have a look at the Headline again (adding our own switchOrder property):", "tokens": 135}
{"title": "Customize a component | kickstartDS docs", "heading": "Customizing multiple properties", "content": "This process can also involve customizing a component by adding multiple properties to it. Just repeat all the steps for every property you'll need to add. In general: these guides are mainly meant as basic building blocks, that can be combined and remixed by you to create exactly what you need... even if that's something more complex than described in these basic guides here. For the full version of customizing a Headline have a look at our \"Customize Headline component\" guide. React template Now that our JSON Schema is defined, we'll automatically get matching TypeScript types for our component. We use those, combined with the types already included with the kickstartDS base component, to quickly hook up our set of properties to the original component. Using auto-complete, and TypeScript telling us about required properties in the base component, this is gets easy like squeezing a lemon! To learn more about the tooling that create those types for you, and how to hook it up, see part four of our \"Create your Design System\" guide. Let's continue showcasing this process using our Headline, creating the component template:", "tokens": 233}
{"title": "Customize a component | kickstartDS docs", "heading": "Necessary imports", "content": "The main imports here are the kickstartDS base component, a rendering function being capable of rendering Markdown and our own components TypeScript types. Unlike the adapt, create and extend processes we don't actually need the HeadlineContextDefault, because we'll add our own markup... based on the original kickstartDS base components markup.", "tokens": 70}
{"title": "Customize a component | kickstartDS docs", "heading": "Add correct type to component", "content": "correct type to component We need to type our React component to use our JSON Schema, while also making sure native HTML attributes are passed correctly and our render functions are understood. For the Headline this means including HTMLAttributes, as it maps to a  under the hood, and our RenderFunctions interface. Doing this allows users of your component to enjoy having the same auto-complete and safety when working with your Design System. #", "tokens": 93}
{"title": "Customize a component | kickstartDS docs", "heading": "Add parameters to component", "content": "parameters to component Next we add all our components defined properties to its function signature. For properties having a default defined in your component API we add that default here, too. As we also want to pass through all the props not explicitly managed by us we sponge up ...props. And in the case of the Headline, we also include our rendering functions. ", "tokens": 80}
{"title": "Customize a component | kickstartDS docs", "heading": "Add the actual", "content": "the actual JSX Unlike when directly adapting or extending a kickstartDS base component, we can't use some imported component directly. We need to reference the template of the original component we're customizing, to copy the parts that need customizing. For the Headline this means copying and customizing this template.", "tokens": 67}
{"title": "Customize a component | kickstartDS docs", "heading": "Adjustments to copied template markup 1/3", "content": "This is where we actually customize the original components markup. For the Headline we drop properties we don't use (e.g. className), add hard coded values for others required but not part of our component API (e.g. align) and rename the ones we've given another name to (e.g. styleAs vs style)", "tokens": 78}
{"title": "Customize a component | kickstartDS docs", "heading": "Adjustments to copied template markup 2/3", "content": "The real custommization lies in adding the subheadline / sub in two places, before and after the main headline content. We just add matching if clauses using switchOrder and !switchOrder respectively, to toggle the one being displayed.", "tokens": 55}
{"title": "Customize a component | kickstartDS docs", "heading": "Adding a", "content": "ing a Provider The final part of creating our React component is adding a component Provider for it. As we've adapted an existing kickstartDS base component here, we'll want to make sure that every time another component includes that base component, our own version of it gets used instead. If you're wondering what that Provider we've added last is all about, think about it like this: There may be other components you've built, that themselves use the base Headline component by default. For example we might have our own TeaserCard component, based on the kickstartDS TeaserBox which includes a Headline. As a means to not having to go through every combination of those component now, making sure our customized Headline actually gets used, you can just change the default Headline rendered by adding a single Provider once, instead. Learn more about Providers and React Context in our dedicated page about them. Or look at our \"Create your Design System\" guide, where we add the general setup for Providers. That one also includes some more details on this!", "tokens": 219}
{"title": "Customize a component | kickstartDS docs", "heading": "Visual Studio Code component property quick-fix", "content": "Visual Studio Code has a great feature aiding in this workflow, with React components that include TypeScript types... like kickstartDS components do. When adding a \"bare\" component without props to your template, Visual Studio Code will offer you the option to Add missing attributes. This will automatically create all required options for your component. Now you just have to connect your own props to those, while hard-coding the ones you don't plan on exposing as part of your components component API. Just hover the squiggly, red line that should be decorating your component, and choose Quick Fix..., to get to that option (alternatively put your cursor on the component tag and hit Ctrl+.).", "tokens": 148}
{"title": "Customize a component | kickstartDS docs", "heading": "Technical debt added", "content": "This way of creating components adds a bit more technical debt than, for example, directly adapting or creating a component. Even extending a component can potentially carry less technical debt, if the extended component is mainly composed of unchanged kickstartDS base components. We still only add a small layer on top of the original kickstartDS base component from a component API perspective, but we also customize the markup. Relevant underlying changes you'll have to look out for: - changes to the base components component API - changes to the base components Reacttemplate - removal of the base components You're immune to underlying changes to: - the design and layout (changes to CSS, SCSSand Design & Component Token) In the case of a changed component API, you should have a look at the corresponding CHANGELOG.md and potential notes in our matching migration guide. You'll probably just need to add a newly added field to your React template, and potentially your own component API if you want to use it. If a field was changed, that might also necessitate some adaption of your own version. Finally a removed field you're actually using would mean adding additional customization to regain that functionality. Have a look at our Headline example guide to see how you'd add your own, new property! Changes to the markup of a components React component will also need to be adapted. Those will always be Breaking Changes, though. And there'll always be a migration guide detailing the changes you'll have to follow. But it's still one crucial dependency added for you to worry about.", "tokens": 320}
{"title": "Customize a component | kickstartDS docs", "heading": "Immunity to underlying design and layout changes", "content": "How immune you are to changes to design and layout of a kickstartDS base component can depend on the changes you've made to the component while customizing. If you're closely adhering to the original CSS / SCSS BEM class structure, only hard coding some classes in your copied template, you should be safe. Learn more about what we mean by technical debt here on the overview page of this section.", "tokens": 92}
{"title": "Customize a component | kickstartDS docs", "heading": "Customize", "content": "Headline component In this example component guide we customize the Headline component (as part of the @kickstartDS/base module) to use it for headlines in our own Design System. We greatly simplify the Headline and add both our own switchOrder property and RTE-like rendering capabilities for text content. This is what the result looks like: _1", "tokens": 76}
{"title": "Typography | kickstartDS docs", "heading": "Typography", "content": "Typography is one of the main ways you surface content in products. We care about good defaults to provide you a clear hierarchy and contrasting styles in your typography scale. The Token can be found in typo.json.", "tokens": 47}
{"title": "Typography | kickstartDS docs", "heading": "Font Families", "content": "|Token||Preview| Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. token.css", "tokens": 59}
{"title": "Typography | kickstartDS docs", "heading": "Font Size", "content": "|Token||Preview| Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. token.css", "tokens": 95}
{"title": "Typography | kickstartDS docs", "heading": "Line Height", "content": "|Token||Preview| Almost before we knew it, we had left the ground. dolor sit amet Almost before we knew it, we had left the ground. dolor sit amet Almost before we knew it, we had left the ground. dolor sit amet Almost before we knew it, we had left the ground. dolor sit amet Almost before we knew it, we had left the ground. dolor sit amet Almost before we knew it, we had left the ground. dolor sit amet Almost before we knew it, we had left the ground. dolor sit amet token.css", "tokens": 130}
{"title": "Typography | kickstartDS docs", "heading": "Font package", "content": "A combination of font-size, font-family and line-height. |Token||Application||Preview| |Headlines| Almost before we knew it, we had left the ground. |Copy Text| Almost before we knew it, we had left the ground. |User interface| Almost before we knew it, we had left the ground. |Code Snippets| Almost before we knew it, we had left the ground. token.css", "tokens": 94}
{"title": "Typography | kickstartDS docs", "heading": "Font Weight", "content": "|Token||Preview| Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. Almost before we knew it, we had left the ground. token.css", "tokens": 59}
{"title": "Storybook | kickstartDS docs", "heading": "Storybook", "content": "Integrating well with Storybook means giving all the users of your Design System the best experience possible. It should be the perfect workbench, welcoming every type of stakeholder! Integrating well with Storybook means giving all the users of your Design System the best experience possible. It should be the perfect workbench, welcoming every type of stakeholder!", "tokens": 73}
{"title": "Feedback | kickstartDS docs", "heading": "Feedback", "content": "Feel free to join us on Discord! If that's not your cup of tea, you can also reach out to us: - Through the chat widget, included in all of our public facing websites - By writing us an email - By joining us on Twitter - By writing us on WhatsApp", "tokens": 60}
{"title": "Environment | kickstartDS docs", "heading": "Environment", "content": "Everything needed for getting started with kickstartDS is a Node & npm environment. Additionally you'll probably want to use an editor like Visual Studio Code to work on your Design System. This also enables you to take advantage of smart features, like code completion or inline documentation, while coding.", "tokens": 60}
{"title": "Environment | kickstartDS docs", "heading": "Working with the terminal", "content": "Working with a Design System code base in general, and with kickstartDS specifically, often involve working with your local terminal. We can't give you an exhausting intro to that here, but the MDN one is a good start: Understanding client-side web development tools > Command line crash course Generally your best starting point is the built-in terminal, included with most Operating Systems (OS). There's nothing prohibiting you from using other terminal solutions or configurations, but if you happen to come accross something strange feel free to open a ticket on Github.", "tokens": 116}
{"title": "Environment | kickstartDS docs", "heading": "Included terminal options per OS", "content": "Windows: The older Command Line Shell or the newer PowerShell. macOS: The built-in Terminal app Linux: Choice of terminal can vary wildly, depending on distribution (Ubuntu, Debian, Arch, etc) and user preference", "tokens": 52}
{"title": "Environment | kickstartDS docs", "heading": "Node & npm", "content": "As with most modern frontend tooling, and JavaScript based projects in general, kickstartDS is based in Node. You can either download current prebuilt installation packages for all common platforms directly from their downloads page, which include both Node in a specific version, as well as the corresponding version of npm as the package manager, or you use a version manager for Node like nvm, to be more flexible in switching used versions of both. We're currently on Node LTS version 16.14.2. See details about it here. We generally adopt new LTS releases (the even numbered ones) when they become stable, and supported by all of our associated downstream tooling (like integrations, themes, etc).", "tokens": 149}
{"title": "Environment | kickstartDS docs", "heading": "Verifying installation", "content": "To check if your local installation works and matches your expecation, open a new terminal window and run: _2node --version_2npm --version Which should result in: _2v16.14.2_28.19.2", "tokens": 55}
{"title": "Environment | kickstartDS docs", "heading": "Usage with nvm", "content": "It's recommended to use a Node version manager. We prefer using nvm, a pretty widely used, terminal based solution: https://github.com/nvm-sh/nvm We also include a .nvmrc file with all our repositories, specifying the currently used and supported version, for example this one for the main repository of kickstartDS: https://github.com/kickstartDS/kickstartDS/blob/next/.nvmrc With nvm installed, just switch to the folder and call: _1nvm use Which should net you something like this: _2Found '/home/julrich/Projects/Frontend/code/kickstartDS/.nvmrc' with version <16.14>_2Now using node v16.14.2 (npm v8.19.2) If the needed version is not found locally, you're automatically prompted with the correct command to install it. This ensures general compatibility with provided code and it's associated processes.", "tokens": 213}
{"title": "Environment | kickstartDS docs", "heading": "Automatic Node version change", "content": "Your currently selected working version of Node and npm can also be chosen completely automated, based on your local shell configuration. This is a bit more environment specific, but enables (for example) version changes based on your current working directory: Read more on the nvm section about Deeper Shell Integration.", "tokens": 64}
{"title": "Environment | kickstartDS docs", "heading": "Usage with yarn", "content": "We use yarn for package management ourselves, including their workspaces feature... enabling having all modules / packages together in our single mono repository. Just replace commands normally prefixed with npm by their corresponding yarn equivalents.", "tokens": 45}
{"title": "Environment | kickstartDS docs", "heading": "Only ever use one package manager", "content": "You should never mix package manager use. So if you're opting for yarn, be careful to not call commands link npm install, or npm run any longer. Just use their counter parts yarn install / yarn or yarn run instead. yarn uses a yarn.lock file to pinpoint your exact versions, whereas npm uses package-lock.json. This might also give you an indication as to which package manager was used before in a project.", "tokens": 94}
{"title": "Environment | kickstartDS docs", "heading": "Other package managers", "content": "Currently the use of pnpm or Nx is untested. There's nothing immediately coming to mind blocking their use, though. If you happen to use one of them, and come upon problems, feel free to open a ticket on our Github repository. Almost all tooling for modern JavaScript projects is based in Node.js. The download page has prebuilt installation packages for all platforms. We recommend selecting the LTS version to ensure best compatibility.", "tokens": 95}
{"title": "Environment | kickstartDS docs", "heading": "Git", "content": "You'll probably want to have Git support installed on your system, too. This is not strictly a requirement for working with kickstartDS, but is the recommended way to work with code today. Learn more about Git on their official website. Next to your locally installed Git client, most of the time you'll interact with a hosted repository. This might live on popular SaaS hosting providers such as Github, Gitlab or Bitbucket, on privately hosted providers, based on those, or a variety of other flavours... up to completely local repositories just used for personal use. kickstartDS is hosted on Github, but where your Design System repository is hosted depends on your own setup. You can find our repository here: github.com/kickstartDS/kickstartDS Popular configuration guides include: GitHub: Set up Git Gitlab: Installing Git Bitbucket: Install Git ", "tokens": 182}
{"title": "Environment | kickstartDS docs", "heading": "Git GUI", "content": "GUI If working with the terminal is not your thing, you might want to use a dedicated Git GUI (Graphical User Interface). For an overview have a look at the options for your operating system. GitHub Desktop is an excellent choice when working with Github, but in general the Visual Studio Code Git extensions are an integrated, natural alternative for developers. Learn more about them on their intro page. ", "tokens": 82}
{"title": "Environment | kickstartDS docs", "heading": "Git TUI", "content": "TUI If you just want to have a nicer terminal based experience, you might have a look at the ncurses-based tig: jonas.github.io/tig", "tokens": 42}
{"title": "Theming | kickstartDS docs", "heading": "Theming", "content": "There are some limited options to theming Storybook. But while this might seem like a small thing, it can really help make your Storybook feel like home. To learn more about theming in Storybook, have a look at their dedicated docs for that.", "tokens": 56}
{"title": "Theming | kickstartDS docs", "heading": "Usage with", "content": "kickstartDS You already have a well established Design Token set when working with a Design System based on kickstartDS. In our mission to always provide sensible defaults, that improve your status quo without a big upfront investment of time, we provide a transformer in our Style Dictionary implementation (it's the tool backing your Design Token set). That transformer takes your Design Token set and converts it to JavaScript values that can be imported in Storybooks theme file ( .storybook/themes.js). As this is a generated file, based on your configuration, it's content will vary, but it should a little like this: This automatically connects your Design Token set to your Storybook theme, while also setting your logo.", "tokens": 146}
{"title": "Theming | kickstartDS docs", "heading": "Example", "content": "Have a look at our very own kickstartDS instance to see our colors (as an example) at work: To learn how to use this in your own Storybook, have a look at part three of our \"Create your Design System\" guide for an in-depth explanation.", "tokens": 60}
{"title": "Next Steps | kickstartDS docs", "heading": "Next Steps", "content": "With all of that introductory stuff out of the way, we recommend following one of the three following paths: If you're interested in more background info, have a look through our blog... we try to give insights there as much as possible, too: https://www.kickstartDS.com/blog/", "tokens": 65}
{"title": "Branding Token | kickstartDS docs", "heading": "Color Palette", "content": "_8\"color\": {_8\"primary\": \"#05566a\",_8\"primary-inverted\": \"#ecff00\",_8\"background\": \"#fff\",_8\"foreground\": \"#050505\",_8\"link\": \"#5D5DD5\",_8\"link-inverted\": \"#C6C6FF\"_8}, |Token||Description| |Important/interactive elements| The most prevalent color of the design system |Default background-color| |Default text-color| Upon inversion, foreground and background will be swapped |Signals text-links|", "tokens": 129}
{"title": "Branding Token | kickstartDS docs", "heading": "Spacing Scales", "content": "_5\"spacing\": {_5\"base\": 8,_5\"scale-ratio\": 1.35,_5\"bp-ratio\": 1.15_5}, |Token||Description| |The base spacing pixel value| It will represent the This value will be applied directly on mobile devices, on further breakpoints it will be scaled up |Set the value the m spacing value will be scaled by, down to | |A single value by which the base spacing will be multiplied on each breakpoint|", "tokens": 111}
{"title": "Branding Token | kickstartDS docs", "heading": "Fonts", "content": "_39\"font\": {_39\"display\": {_39\"family\": \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'\",_39\"font-size\": 18,_39\"line-height\": 1.5,_39\"scale-ratio\": 1.225,_39\"bp-factor\": {_39\"phone\": 1.167,_39\"tablet\": 1.333_39}_39},_39\"copy\": {_39\"family\": \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'\",_39\"font-size\": 16,_39\"line-height\": 1.5,_39\"scale-ratio\": 1.225,_39\"bp-factor\": {_39\"tablet\": 1.125_39}_39},_39\"ui\": {_39\"family\": \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'\",_39\"font-size\": 16,_39\"line-height\": 1.5,_39\"scale-ratio\": 1.225,_39\"bp-factor\": {_39\"tablet\": 1.125_39}_39},_39\"mono\": {_39\"family\": \"ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace\",_39\"font-size\": 16,_39\"line-height\": 1.75,_39\"scale-ratio\": 1.225,_39\"bp-factor\": {_39\"tablet\": 1.125_39}_39}_39}, |Token||Preview| |The base font size pixel value| It will represent the This value will be applied directly on mobile screens, on larger breakpoints it will be scaled up |The base line-height factor| The factor is multiplied with the font-size |The value by which the base font size will be multiplied, when on a certain breakpoint|", "tokens": 539}
{"title": "Branding Token | kickstartDS docs", "heading": "Font Weights", "content": "_6\"font-weight\": {_6\"light\": 300,_6\"regular\": 400,_6\"semi-bold\": 600,_6\"bold\": 700_6}, Add font-weights and the corresponding values to your design system.", "tokens": 57}
{"title": "Branding Token | kickstartDS docs", "heading": "Breakpoints", "content": "_6\"breakpoints\": {_6\"phone\": 576,_6\"tablet\": 768,_6\"laptop\": 992,_6\"desktop\": 1200_6} Set the screen sizes from which on the according breakpoint will be applied.", "tokens": 59}
{"title": "Color | kickstartDS docs", "heading": "Color palette", "content": "palette |Token||Description| |High priority elements| |Default foreground color, most prevelant in copy text.| |Hyperlink color| |Elements featuring transparency| ", "tokens": 41}
{"title": "Color | kickstartDS docs", "heading": "Color scales", "content": "scales kickstartDS generates color scales based on your Core Token. to-bg mixes in --ks-background-color-default (by default defined as --ks-color-fg-inverted). alpha adds transparency. Color scales are not linear. --ks-color-primary-alpha-3 doesn't mean, its alpha channel is 0.3. It's just the third most translucent variant. The same applies to to-bg. We use a cubic BÃ©zier curve to calculate the scales. This way there are more gradations at the beginning and at the end of the scale. For example, for hover or active states of a component you often need slight shades of a color. With a linear scaling the distance between the shades would be too large. In addition, the colors in the middle of the scale are almost useless, because they have too little contrast in combination with the background color. alpha/to-bg scale opacity/bg-mixin |to-bg| |alpha|", "tokens": 208}
{"title": "Color | kickstartDS docs", "heading": "Color variants", "content": "variants |Variant||Description| |Highlights elements. The most prevalent color of the design system.| |Highlights elements that are hierarchically second to primary elements.| |The default color of elements. Used as a fallback.| |Elements featuring transparency| |Signals user interactability| ", "tokens": 68}
{"title": "Color | kickstartDS docs", "heading": "Color categories", "content": "categories |Category||Description| |Highlights elements. The most prevalent color of the design system.| |Highlights elements that are hierarchically second to primary elements.| |The default background-color. Used on page the background.| ", "tokens": 54}
{"title": "Color | kickstartDS docs", "heading": "Color concepts", "content": "concepts interactive applies to primary, interface & clear variants. translucent applies to primary variant. |Concept||Description| |Signals interactability| |State of the element on hover| |State of the element when active| |Element has some form of opacity|", "tokens": 57}
{"title": "Premade Stories | kickstartDS docs", "heading": "Premade Stories", "content": "Stories are at the heart of Storybook (who whould've guessed ðŸ˜…). They are the stage and workbench for your components. As with Storybook Controls you don't have to start from zero with kickstartDS. A story captures the rendered state of a UI component. Developers write multiple stories per component that describe all the â€œinterestingâ€ states a component can support.", "tokens": 82}
{"title": "Premade Stories | kickstartDS docs", "heading": "Usage with", "content": "kickstartDS We provide support in two key areas when it comes to Storybook stories: - Premade Design Tokenstories - Premade component stories See below for an explanation what these can do for you!", "tokens": 44}
{"title": "Premade Stories | kickstartDS docs", "heading": "1. Premade", "content": "Design Token stories Our premade Design Token stories showcase your Design Token set instantly, neatly categorized and grouped by their semantic meaning established through kickstartDS. See the integration page about \"Design & Component Token\" in this very section to see a detailed description, and how you'd use them for your own Design System.", "tokens": 66}
{"title": "Premade Stories | kickstartDS docs", "heading": "2. Premade component stories", "content": "When building your own components based on kickstartDS, often you'll find that there's one single component, or a very limited set of components, that back your new creation. It'd make sense to re-use existing documentation for those, too! To enable re-use, we export stories as part of every component that's part of our modules. You can simply import those to set useful defaults for your own component stories, inheriting from the base component.", "tokens": 100}
{"title": "Premade Stories | kickstartDS docs", "heading": "Add them as defaults", "content": "Destructure them into your default export as defaults, and overwrite just what you want to need to. That's it, and as always this should help you focus on the important details! Have a look at the \"Adapt Button component\" guide for a full version of the Button component shown here. This also works when working with more than one component:", "tokens": 75}
{"title": "Premade Stories | kickstartDS docs", "heading": "Complex example", "content": "Glossary detail page This will be added soon, come back a bit later! WoÃ¶Ã¶ ise this page as a basis: https://github.com/kickstartDS/kickstartDS-storybook/blob/master/src/Pages/BlogList.story.jsx", "tokens": 64}
{"title": "Premade Stories | kickstartDS docs", "heading": "In action", "content": "To see this in action, have a look at the base story for our kickstartDS Button component, for example: https://master--6080932e6ca776002127f0c5.chromatic.com/?path=/story/base-button--default Then compare it to the story for the Button in our own kickstartDS Design System (which, of course, is also based on kickstartDS), which re-uses the base story from above: https://www.kickstartds.com/storybook/?path=/story/base-button--solid", "tokens": 123}
{"title": "Breakpoints | kickstartDS docs", "heading": "Breakpoints", "content": "Breakpoint tokens are only needed internally. They are used to generate scales of font sizes and spacing for different screen sizes. Only one CSS custom property is created, which is read via JavaScript and used to inform components about a breakpoint change. breakpoints.json tokens.css CSS custom properties don't work in media query declarations. So if you write custom styles, you have to write the media query declaration manually.", "tokens": 86}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "Summary", "content": "#tldr Weâ€™re still wasting massive amounts of valuable development cycles in the frontend world by working in silos, or by to at least some extent reinventing the wheel for every project. Results suffer in the process, impacting real world results for users and content creators alike.\nHow did we get here, and how could a way forward look like? How weâ€™ve already come a long way, and why still (so far) even Jamstack hasnâ€™t been the sole answer, eitherâ€¦", "tokens": 111}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "So whatâ€™s wrong?", "content": "This is something Iâ€™ve been thinking about for a while now. Way back in the day, when you wanted to build a website or digital product, you built everything yourself. You had no choice, you had to! This began with defining models and relationships, adding logic on top of it to extract the correct data to display, and implementing actions that should be triggered upon user interaction. Typically mutating server state of some sort. And then, finally, you purpose-built your frontend accordingly, for those exact circumstances. All in all, oftentimes a very interlocked process between all parties involved. Be it between software specification and backend development, design creation & specification and frontend development or frontend and backend development. Changes of every kind typically being costly as a consequence, leading to everyone trying to over-spec even moreâ€¦ a vicious cycle of ultimately missed expectations.", "tokens": 184}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "Classic architectures", "content": "Weâ€™ve moved away from this by adding frameworks and new, more flexible development approaches into the mix. Mostly adopting a Model-View-Controller (MVC) approach in the process, doing some domain driven design, and as a result agreeing to a way more manageable amount of shared best practices. This happened for almost every programming language (e.g. Symfony for PHP, Rails for Ruby, Express for Node.js, Spring for Java). In combination with adopting more agile processes to structure our development, this enabled everyone to be more resilient to often changing requirements. Because changes could be made in a more predictable fashion, and were better aligned with real needs, the resulting positive feedback loop kept converging everyone to adopting those shared best practices, fostering further exchange and standardization. Often designed into the respective frameworks from the start, as plugins, extensions or addons. Associated marketplaces further incentivizing this.", "tokens": 188}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "What about websites?", "content": "In parallel those conventions took hold for website development, too. Instead of general purpose frameworks (like Rails), which were still to expensive as a basis for the often repeated customer needs, content management systems (CMS solutions like WordPress, TYPO3, Drupal) took that place. Adding already established models, and thus a specific domain for content, to the open approach of working with â€œjustâ€ a MVC framework. This also enabled them to create much more tailored interfaces for editors working with said content, and layering additional functionality on top; as you just knew much more about what everyone was working with. But you still had to fine-tune it for every customer to create a truly fitting editor experience, and the frontend still got painstakingly re-implemented with every major overhaul. Additionally you had to fit everyone into the same monolithic system, increasing complexity and cognitive overhead for all different types of editors involved (news, career, marketing, blog, internal communication, the list goes on, all with different editorial needs).", "tokens": 215}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "The first wave of ecosystems for the web", "content": "Both ways of building web interfaces (website vs application, or custom vs CMS) succeeded in establishing flourishing ecosystems around their approaches, though, allowing developers to start exchanging real code instead of just ideas or framework best practicesâ€¦ getting more efficient in the process, while generally also creating better results. But you were still locked into that specific ecosystem, trying to build a monolithic jack-of-all-trades, even more so if your goal was to have a consistent experience over all the different brand touchpoints a user may encounter on his customer journey.", "tokens": 120}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "Emancipating the frontend", "content": "For websites, lately, this mental model has been challenged again by the notion of headless content mangement systems, and more generally speaking by completely detaching the frontend from the backend in an approach now often called the Jamstack (in comparison to the LAMP stack traditionally found in a CMS). This decoupling enables establishing a shared contract between both sides, an API. Making teams working on them more independent of each other, while also increasing stability because everyone can test against it in isolation. With generators (Gatsby, Next.js, 11ty) being a central part of the Jamstack approach, one additional super power thatâ€™s unlocked by them is the possibility to use multiple sources to feed into one resulting interface or website. Ultimately mix-and-matching backend and API solutions into one consistent experience, with everyone using the tool most suited for his daily job. The marketing team may work with WordPress to create long form content and something like Storyblok to build engaging landing pages. The main website could be built with Sanity, or other structured content-oriented solutions, as the headless CMS to really leverage connected, long-lasting content where it matters. Even other data can be spliced into the mix by adding third-party APIs as needed. Frontend frameworks like React embrace that way of working by optimizing for composability, while tech like GraphQL helps with enabling that same composability for APIs. In combination with a lot of SaaS offerings being API based, or at least supplying really rich, well documented APIs as par of their open source strategy, this unlocked a huge potential in the space for re-use, specialization and standardization. And Iâ€™m sure weâ€™ve just started experiencing the paradigm shift associated with that!", "tokens": 363}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "Butâ€¦ whereâ€™s my frontend ecosystem? ðŸ˜“", "content": "Unfortunately though, we still often build frontends completely isolated from each other. Creating and reinventing one-off work that suffers as a consequence, because you just canâ€™t invest the time thatâ€™s needed to make something really good (in regards to performance, accessibility, responsiveness, cross browser-compatibility) in the time allotted for such frontend work. All while additionally trying to stay on top of the current trends, and changes inside our own ecosystems because of the rapidly changing landscape. Way too often still youâ€™re confronted with some form of digital design (be it Sketch, Figma or Adobe XD) on the one hand, and data structures that are the result of decisions that were made in your absence, when choosing and building the generator and APIs on the other hand. Itâ€™s your job then to create a component from that, hopefully creating something re-usable, which is expected to be universally understood by everyone to be the same thing. And did you know that the same component is supposed to work on the blog, too? But it should look and behave slightly different? A thankless job at best. Man stands face to face with the irrational. He feels within him his longing for happiness and for reason. The absurd is born of this confrontation between the human need and the unreasonable silence of the world.Albert Camus, The Myth of Sisyphus and Other Essays This all, unfortunately, still makes frontend development a pain. While valuable engineering time goes into chasing problems that have been solved a thousand times before. Often even by oneself, just two projects before the current oneâ€¦", "tokens": 341}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "Why just creating a Design System is not the answer, either", "content": "For product teams tasked with starting a Design System today, this also way too often feels like just another added thing on top, thatâ€™s expected to be delivered, en passant. Neglecting that for that to work the focus would have to shift dramatically, adjusting the way frontends are architected, and enabling frontend developers to realise the potential demanded from them. And also fulfill those Design System promises like â€œautomaticâ€ consistency, more efficient development cycles or magically aligned stakeholders. There needs to be a better way to foster the same exchange, longevity and interchangeability between frontend developers and the results of their work! Unlocking the frontend potential, like it has already been unlocked for other parts of the products and pages weâ€™re building! In a world of Design Systems this also means letting the frontend somewhat dictate the rules of engaging with components more, in some places inverting the way we work today. And the attentive reader could have already spotted: we havenâ€™t even really spoken about content strategy, connected content and the influence content creators and editors should have in those architectural decisions. Which for most just reflects the way digital interfaces are built todayâ€¦ with the people working with the resulting software unfortunately being an afterthought. And the results suffering in the process. Only in uniting all those stakeholders in the decision making process will the end result, a tangible page or application that is generating true value for both the user and the creator, be successful.", "tokens": 312}
{"title": "Unlocking the frontend â€“ a call for standardizing component APIs pt.1", "heading": "So what now?", "content": "What was behind every major evolution of the web in the past was people rallying around shared principles, doing something in a more coordinated and repeatable way. Iâ€™m pretty convinced that for the frontend this has to mean some kind of standardization. Standardizing the way components can be compared, the way they expect and consume data, and effective ways of mapping between all of those. Iâ€™ll explore those thoughts in part 2, and try to showcase how weâ€™re trying to solve for this today inside kickstartDS, for our users. And maybe, just maybe, this could someday align with a greater approach to all of this, unlocking not only the true potential of something like kickstartDS, but the potential of the wider frontend development world. How this has impacted our work over the last 15 years? How possible solutions to this could look like? And why we think to be having some potential answers at the core of kickstartDS, today? Read more in part 2, very soon! Also, hit me up on Twitter at @tsnmp to exchange ideas (or to tell me where Iâ€™m possibly getting it all wrong ðŸ˜‹). Would love to hear others takes on this!", "tokens": 252}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Summary", "content": "#tldr Weâ€™ve added extensive documentation around the creation of Design Systems with\n**kickstartDS**. From general intro, foundation articles and component example guides to our main guide **â€œCreate your Design Systemâ€**â€¦ explaining every single step of the process in detail. And for everyone wanting to dive in head first, weâ€™ve added an extensive, best-practice Starter as a Github template! Clone it and kickstart your Design System in just 5 minutes!", "tokens": 104}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Documentation", "content": "The third big pillar of our Open Source release is our documentation (read about Semantic Token in Release Spotlight 1/3, or Container Queries in Release Spotlight 2/3). Why is documentation so important to us? Because we know that just putting your code on GitHub, even using a fitting LICENSE, will not be enough if we really want people to take a serious lookâ€¦ and even more so if considering adoption. Additionally, Design Systems need you to take a lot of decisions. Those can be both highly custom and opinionated. This is why we think explaining our reasoning in detail, especially when we take decisions for you (like using Style Dictionary), is super important. And for areas where there is no clear cut decision to take, we always try to add recommendations (like how to best construct your components to avoid adding technical debt) instead.", "tokens": 174}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Intro and Getting Started", "content": "The â€œIntroduction to kickstartDSâ€œ page, also the index page for the â€œGetting Startedâ€ section, features a short video of us introducing kickstartDS, defines features and aspirations, and introduces the motivation behind creating kickstartDS. Next to that, this section is mainly about giving you a first, good understanding for the context youâ€™d work in when building on kickstartDS. This includes talking about release handling and upgrade processes, the environment involved, how our CLI works, or what packages exist to choose from. It also describes the next steps you could take, after deciding if what youâ€™ve read is to your liking.", "tokens": 140}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Create your Design System guide", "content": "â€œ The guideâ€ â„¢ï¸, where we try to explain the process of creating your Design System atop kickstartDS in detail. Starting from scratch (seriously: an empty directory!) we build up everything needed to have your first Design System release published, ready to be consumed by others! As the guide is quite lengthy, we broke it up into 5 main parts: - Start your Design System - Design Application - Configure Storybook - Add Components - Publish your Design System All the code involved with the guide is also available on GitHub (thereâ€™s one branch per step) for quick referencing, and included in Code Sandboxes alongside the major guide sections. Additionally, our Starter includes the exact same components created here. This makes the guide a great reference if youâ€™re not feeling like following lengthy instructions, but would still prefer a place to look up implementation choices â€œon demandâ€.", "tokens": 192}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Foundations", "content": "Our â€œFoundationsâ€ section describes the basic aspects of all main areas you can find in a Design System, especially when combined with the choices made in kickstartDS to be built upon. Learn about Branding Token, Design Token and Component Token in the â€œTokenâ€ part, the layers of components in â€œComponentsâ€, how to handle â€œLayoutâ€, and which â€œModulesâ€ (collections of components) exist. You can find all of those categories on the foundations index page. Design Token additionally contain distinct pages per token category (Color, Typography, Spacing, Border, Shadow, Depth, Breakpoints), while the layout section includes a selection of examples, ready to copy and pasteâ€¦ both for the Section component included with kickstartDS and our recommendation for more general layout needs in Bedrock Layout Primitives.", "tokens": 181}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Integration", "content": "Every Design system lives and fails with its success in being applied in real projects, the ones actually generating tangible value. Making the application of your Design System as effortless as possible necessarily involves integrating with other frameworks, tooling, processes, libraries and technologies. Regardless of whether you are integrating HTML into your backend (written in e.g. PHP, ASP.NET, Ruby on Rails, etc), or alternatively using React templates directlyâ€¦ combining headless CMS and APIs through something like Gatsby or Next.js, integrations can really speed up that adoption process. We also try to integrate really well out-of-the-box with popular tooling for Design Systems. First and foremost this means providing the best workbench experience possible using Storybook. Be it using addons weâ€™ve written ourselves for JSON Schema support or Component Token, or adding best-practices and configuration you can easily adopt.", "tokens": 188}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Guides", "content": "This is the meat of our documentation! We try to provide detailed guides here, each focused on a particular topic. Main topics currently include: Components, Examples, Migrations, Using our Starter and the Design System Initiative. One special mention should be awarded to our main guide â€œCreate your Design Systemâ€. With that one you start with an empty folder, and build up your Design System piece by pieceâ€¦ always accompanied by explanations. This is the perfect start to learn everything from the ground up! The main guide also provides a great segue to our kickstartDS Design System Starter. If you donâ€™t feel like following a lengthy guide, and prefer to get going with some code immediately, it is the most efficient way of starting your Design System. It contains the exact same code described in our component examples, and said main guide, so those can provide a great reference when going down that route. It is ready to be cloned on GitHub as a template repository, so you could have your own Design System open in your browser in 5 minutes max!", "tokens": 219}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Design System Starter", "content": "Our Design System Starter is the perfect starting point if you want to get going immediately. You get everything described in our guidesâ€¦ and some really nice and helpful integrations (like Bedrock Layout Primitives, Bundling, Playroom, Releases) on top of that. Initial setup only includes 5 super simple steps, that should be done within just 5 minutes, leaving you with a great foundation to start your real Design System work!", "tokens": 90}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Features", "content": "The main features included with our Starter: - Ready-to-start, fully functional Design System - Pre-configured, Semantic Tokenstructure ( Branding Token, Design Token, Component Token) Branding Tokenfile for quick application of CI / CD - Three exemplary components (â€œButtonâ€, â€œHeadlineâ€ and â€œTeaserCardâ€) and a layout element (â€œSectionâ€) - Full page demo, recipe demo and rudimentary demo docs Storybookwith best-practice configuration, kickstartDSintegration Hot reloadfor allcode changes: Design Tokenset, JSON Schema, CSS/ SCSS, JavaScriptand Reacttemplates Playroomintegration for prototyping - Bundling of Design Systemfor use with andwithout React - Automatic, semantic release handling using auto - CI / CD integration for Circle CI", "tokens": 176}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Result", "content": "After successfully cloning the Starter, and following the Getting Started, youâ€™ll be left with a Design System ready to be added to! Where exactly you take it next is pretty much up to you completely. There are some things one would pretty much always want to do (e.g. Customizing Design Token), while others might be optional. In which order you tackle those shouldnâ€™t make a difference, just choose what fancies you the most! You can also have a look at the â€œNext stepsâ€ section of the Starter docs, which give some more detailed pointers on what could come next (for example starting a Design System Initiative)", "tokens": 136}
{"title": "Release Spotlight: Documentation & Starter", "heading": "Feedback", "content": "Weâ€™d love to hear your feedback! Doesnâ€™t matter if you only found a typo in our docs, or maybe your Design System journey came to a screeching halt when following our main guide, or just want to leave some warm words! Feel free to join us on Discord! If thatâ€™s not your cup of tea, you can also reach out to us: - Through the chat widget, included in all of our public facing websites - By writing us an email - By joining us on Twitter - By writing us on WhatsApp", "tokens": 114}
{"title": "Anatomy | kickstartDS docs", "heading": "Branding Token", "content": "Branding Token are the most basic, and high-level, elements influencing a component. As they were used to initialize your Design Token, they will also be mapped into your Component Token and thus influence how your component will look.", "tokens": 49}
{"title": "Anatomy | kickstartDS docs", "heading": "Component Token", "content": "Component Token map your Design Token set and your semantic token to your components in layers. Variants and variations are layered on base variants, allowing for easy customization while always having great defaults as a baseline.", "tokens": 43}
{"title": "Anatomy | kickstartDS docs", "heading": "(S)CSS", "content": "Component styles are written in SCSS and named following the BEM methodology. To prevent class name collision, kickstartDS component class names are prefixed with c for content components or l for layout components.", "tokens": 44}
{"title": "Anatomy | kickstartDS docs", "heading": "Container Queries", "content": "All components are fully responsive. Because we don't know where they will be used, we don't use media queries, but container queries. For browsers that do not yet natively support container queries, we provide a narrow polyfill.", "tokens": 50}
{"title": "Anatomy | kickstartDS docs", "heading": "JavaScript", "content": "Most components are pure and do not require additional JavaScript in the client. For interactive components, a JavaScript module is loaded separately. This module is written in vanilla JavaScript and works with any frontend framework and even without a framework.", "tokens": 48}
{"title": "Anatomy | kickstartDS docs", "heading": "Initialization", "content": "kickstartDS uses Mutation Observer to initialize components when they appear on the page. A component script is a JavaScript class with the static property identifier. A component with the HTML attribute ks-component=\"{identifier}\" is then initialized with the appropriate class.", "tokens": 56}
{"title": "Anatomy | kickstartDS docs", "heading": "Lazy loading", "content": "Component scripts are loaded only when the component is on the page or dynamically added. You can go further and load the script only when the component scrolls into the viewport by simply adding the lazyload class to the component.", "tokens": 47}
{"title": "Anatomy | kickstartDS docs", "heading": "Event-Handling", "content": "Components can communicate with each other via a PubSub event bus. Anyone can participate in the event bus; it is publicly available at window._ks.radio and can therefore also be used to communicate with the \"outside world\" or to send events from outside into components.", "tokens": 58}
{"title": "Anatomy | kickstartDS docs", "heading": "HTML / Markup", "content": "Markup is the normalizing factor, it's what ultimately defines what a component looks like in the browser. We use React as a templating language to write templates, but they generate HTML in the end... and as our JavaScript / TypeScript is written outside of React, you can easily use kickstartDS in HTML, or by adding it into your legacy backend / code-base (for example PHP, .NET, etc). You could also re-implement components in another templating layer like Vue.js or Angular, as long as the resulting HTML stays the same, and the component API is followed.", "tokens": 131}
{"title": "Anatomy | kickstartDS docs", "heading": "JSON Schema", "content": "A component can have multiple options that affect its appearance. These options (or props) are defined in JSON Schema and form the component API. _16{_16\"$schema\": \"http://json-schema.org/draft-07/schema#\",_16\"$id\": \"http://schema.kickstartds.com/base/divider.schema.json\",_16\"title\": \"Divider\",_16\"description\": \"Dividers bring clarity to a layout by grouping and dividing content in close proximity.\",_16\"type\": \"object\",_16\"properties\": {_16\"variant\": {_16\"title\": \"Style of the divider\",_16\"type\": \"string\",_16\"description\": \"Choose a variant for the divider\",_16\"enum\": [\"default\", \"accent\"],_16\"default\": \"default\"_16}_16}_16} JSON Schema is a common and widely used format to describe (and validate) data structures and can be easily converted to other formats (such as TypeScript types, Storybook stories or Sanity schemas). kickstartDS uses the component schemas e.g. for generating the React prop types.", "tokens": 265}
{"title": "Recipes | kickstartDS docs", "heading": "Recipes", "content": "The recipes in a design system are like real life examples to showcase common patterns and best practice usage. Recipes provide a brief overview on how components can be used and combined to create reusable interaction elements. Or as BRad Frost explain in his blog Recipe components are specific compositions of design system components (for the most part) that are to be consistently used across a product, but arenâ€™t agnostic enough to live in the design system. Source: bradfrost.com We'll start adding recipe examples here!", "tokens": 107}
{"title": "Frameworks | kickstartDS docs", "heading": "Frameworks", "content": "Integration with common React frameworks can really speed up adoption, and make the difference between a successful Design System... and one that fails! Integration with common React frameworks can really speed up adoption, and make the difference between a successful Design System... and one that fails!", "tokens": 56}
{"title": "Examples | kickstartDS docs", "heading": "Examples", "content": "Those are guides showing, in detail, how you could potentially create components. They should act as inspiration, and hopefully you'll develop a feeling for the concepts at play. This should enable you to think freely about those topics when creating new components. It should start to feel natural after following a bunch of them!", "tokens": 65}
{"title": "Rich Text Rendering | kickstartDS docs", "heading": "Rich Text Rendering", "content": "By default, the kickstartDS RichText component accepts markdown as input. There are many cases where data other than markdown needs to be processed, e.g. if you're working with a CMS.", "tokens": 47}
{"title": "Rich Text Rendering | kickstartDS docs", "heading": "Sanity", "content": "Sanity uses Portable Text to store rich text content. To make it work with the kickstartDS RichText component, we can use the RichTexts renderText render function to convert Sanity Portable Text data to react components. _15import { forwardRef } from \"react\";_15import { createProvider } from \"@kickstartds/core/lib/utils\";_15import BlockContent from \"@sanity/block-content-to-react\";_15import {_15RichTextContext,_15RichTextContextDefault,_15} from \"@kickstartds/base/lib/rich-text\";_15_15const renderPortableText = (text) => ;_15_15const PortableRichText = forwardRef((props, ref) => (_15_15));_15_15export default createProvider(RichTextContext, PortableRichText);", "tokens": 186}
{"title": "Depth | kickstartDS docs", "heading": "Depth", "content": "The token can be found in depth.json. |Token||Description| |For modal elements that overlap the default content| box-shadow.json tokens.css The token can be found in depth.json. |Token||Description| |For modal elements that overlap the default content|", "tokens": 63}
{"title": "Components | kickstartDS docs", "heading": "Components", "content": "Components are the main building blocks for any user interface. Using a reusable component library will enhance your product development workflow by reducing design and tech debt and speeding up the process. Components are the main building blocks for any user interface. Using a reusable component library will enhance your product development workflow by reducing design and tech debt and speeding up the process.", "tokens": 72}
{"title": "Create your Design System | kickstartDS docs", "heading": "Overview", "content": "In this guide we'll get your first Design System, based on kickstartDS of course, off the ground in just 5 rather simple steps! You could say that this is the main guide for kickstartDS, as it branches out into a bunch of sub guides in the process. Hopefully giving you a well-rounded overview over everything offered and possible in the end. While also creating the draft for your first Design System in the process! This guide can act as a great reference, too. If you're struggling somewhere, just look up the section concerned with that part of the setup! And if following such a long guide (it's quite comprehensive) seems daunting, we also have a starter you can use to have something running in no time (okay, okay... it will take you 5 minutes, but not more!). You can always come back to specific sections here then! The starter also includes exactly the same components that are created in this guide, it just adds more features and configuration to your Design System. Just keep this page in mind as a great overview and intro point into kickstartDS in general! The main steps involved go as follows: - Start your Design System - Design Application - Configure Storybook - Add Components - Publish your Design System The resulting Design System will obviously not be finished by the end of this guide, but you'll have everything set up to start on the real work. We'll add links along the way when it makes sense, calling out concepts at play, or processes to use, to find and refine your own personalized worfklow with kickstartDS, and ultimately your own Design System (stuff like choosing an initial component set for your Design System). We also recommend having a look over at our guide for the \"Design System Initiative\", which concerns itself with questions like: - What actually ismy Design System? - Which components do I reallyneed? - How could I find out, which components I'll need? - Who should be involvedin that endeavour? - How to choose a good place to start? This will not be strictly needed for this guide, though. So feel free to just continue on!", "tokens": 437}
{"title": "Create your Design System | kickstartDS docs", "heading": "1. Start your Design System", "content": "In this step you'll either create a new project entirely, or learn which basics to add to your existing project to get started! Start: Go to step 1. A rough outline: See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/1 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 126}
{"title": "Create your Design System | kickstartDS docs", "heading": "2. Design Application", "content": "We will create your initial Design Token set by applying your corporate design, as a reduced set of Branding Token. We'll then fine-tune this, at least as much as sensibly possible in such a guide. We also compile a first semantic Design Token set with our newly created Style Dictionary. Start: Go to step 2 A rough outline: - Overview - Apply branding - kickstartDS Integration - Result - Next Step See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/2 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 173}
{"title": "Create your Design System | kickstartDS docs", "heading": "3. Configure Storybook", "content": "We add Storybook here, which includes installing and configuring all the addons we suggest to use. This also includes some we've written ourselves, to really get the most out of kickstartDS. We'll also add those, and add integration with kickstartDS (tokens, icons, etc). You will end with a fully configured Storybook. Start: Go to step 3 A rough outline: - Overview - Install Storybook - Configure Storybook - Review changes - Result - Next Step See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/3 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 190}
{"title": "Create your Design System | kickstartDS docs", "heading": "4. Add Components", "content": "In this part we'll add 4 exemplary components to illustrate the 4 main ways of adding a component to kickstartDS. A Button to show adaptation, a Headline to show customization, a TeaserCard to show creation, and finally a Section for extension. We'll then add a recipe, demonstrating that concept, combining those 4 components into one big article teaser component! This should hopefully equip you with all the weapons needed to start creating your very own components! We'd love to hear how it went! Start: Go to step 4 A rough outline: - Establish structure - Component implementation - Adding an article teaser recipe - Result - Next Step See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/4 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 216}
{"title": "Create your Design System | kickstartDS docs", "heading": "Result", "content": "This concludes setting up your own Design System from scratch. Hopefully everything made sense, and you were able to learn about kickstartDS, the reasoning behind decisions taken, and how best to approach the creation of components in a Design System-y way. You can find all the code for this guide, the one also embedded in the Code Sandboxes above, on Github here: https://github.com/kickstartDS/ds-guide There are branches on that repository containing the result for every major step of this guide: - Start your Design Systemon branch step/1 - Design Application on branch step/2 - Configure Storybookon branch step/3 - Add Components on branch step/4 - Publish your Design System coming soon... You can also have a look at our Design System Starter, which, while including the same components this guide added, also adds lots of additional features out-of-the-box for you.", "tokens": 192}
{"title": "Create your Design System | kickstartDS docs", "heading": "Next Steps", "content": "Your next steps will depend heavily on your unique circumstances. But to give some pointers to resources that could help in the most common scenarios: |Question||Description||Link| What should I build next? |If you need a process that helps in identifying |Design System requirements, and in ultimately deciding on what components need to be built, in which order they should be built... and what a good pilot project for your Design System could look like. |Design System Initiative| Selecting component processes |Background about when to choose which component creation approach, and what should be taken into consideration. this, for example, can have great impact on the technical debt added.||Components| How will this integrate? |Learn about potential integrations that can be leveraged to integrate your |Design System into different systems, like headless CMS, or technologies, like Next.js or Gatsby. |Integrations| I need more support! |If you feel like need more support, or just a helping hand, feel free to have a look at the services we offer around |Design Systems. These are in no way a requirement to setup your Design System, but we're always happy to help! |Services| I want to leave feedback |If you have feedback that you want to share with us, or just want to hang out in our small |Design System community, head over to our Feedback page. We love to hear from you! |Feedback|", "tokens": 296}
{"title": "Integration | kickstartDS docs", "heading": "Integration", "content": "There's one thing every Design System shares: it only generates value when being applied! And as a Design System also needs to be able to stand on its own, applying it in projects always means integrating it in some way... into something you actually build websites, interfaces or apps with. That's why we, from the very start, tried to find abstractions that can help in that. One core aspect of this is using JSON Schema to encode component APIs. This structure is especially useful when connecting headless CMS systems (like Sanity, Contentful, Storyblok, etc) or other Design System adjacent tooling (like Uniform.dev, Knapsack.cloud, Backlight.dev). Next to using good abstractions, we also try to build as many integrations as possible ourselves. Both to make adoption easier, and to give inspiration on how to best leverage kickstartDS. It also generates great feedback on how to improve our core further, making it adaptable in as many contexts as possible. While those types of integrations help with adoption, there are also integrations meant to improve the developer experience (DX) when working on the Design System itself. One big category there would be integrating well with Storybook. We've written some addons to aid in that ourselves, but also try to always provide best-practice configuration and recommendations for your setup! See below for a list of integratons already built, that can be used today. Or hit us up if you feel like there is something that is obviously missing! We also have some details on our main website about integrations.", "tokens": 327}
{"title": "Integration | kickstartDS docs", "heading": "React", "content": "React React as our templating language of choice offers great integration capabilities, and we've built some additional ones on top of those... to help you even more when creating your own components.", "tokens": 42}
{"title": "Components | kickstartDS docs", "heading": "Overview", "content": "There are a lot of different basic ways of building a component with kickstartDS. And then there's combinations of those basic ones, to create more complex ones! We try to give you an overview over the main, basic processes that can be involved when creating a component for your Design System. That doesn't mean that these are exclusively what you should do. There are other ways of approaching things, and it is highly encouraged to use components as you see fit. That extends to the ways you customize them, in the end we're just using widely accepted concepts and best practices that should never get into your way. Nonetheless, there are some processes that we've found to be pretty universal. They also align really well with the way kickstartDS is built... reducing created technical debt, and minimizing overall effort required to get a good, consistent component in tune with your Design System: All of these workflows currently involve using kickstartDS components as your foundation, even if customizing their React template in the process. It's completely possible to just use our conventions around having a component API (using JSON Schema) for structure, using Design Token and Component Token for design and layout and CSS / SCSS to connect both. And that last one is optional, you can use any approach to CSS, as long as you're using the semantic Design Token as required. That way you completely and explicitly own how the template of a component is constructed, without involving any kickstartDS base components. Even better, you can stay compatible with them... as long as you have a matching component API (for example using exclusively your own markup for your Button, but being able to use it in all other existing kickstartDS base components by providing API compatibility through JSON Schema). Every process is described in roughly the same way, this should helpfully aid in recognizing differences, while also finding your way around more efficiently. You can also freely combine all of those processes, as they are very similar in nature... and described with composability in mind. We start by giving a short definition, followed by talking about the process itself a bit. This is always followed by descriptions of the two or three main steps involved. Finally we add some background info about the technical debt added that way, and link some example component guides that match that process type. Every process has the steps \"Component Definition\" and \"Component Creation\". And in the case of creating a component, an additional step \"Component Mapping\". Accompanying each general guide is a corresponding example component guide, illustrating the process in detail for a demo component: Adapt a component: Adapt Buttoncomponent Customize a component: Customize Headlinecomponent Create a component: Create TeaserCardcomponent Extend a component: Extend Sectioncomponent", "tokens": 557}
{"title": "Components | kickstartDS docs", "heading": "Adapt a component", "content": "This is the most basic way of building up a kickstartDS base component. We already have eyed up a specific component, that we want to adapt into our own Design System. We just reduce the number of properties we use in our own adaptation of the selected component. We can also rename properties (to be a better fit for our own use), or even the component itself. It's pretty normal to end up with multiple components being based on the same kickstartDS base component in the end, but with each having a unique name and component API... thus fulfilling a much more specialized and semantic function in your Design System (for example having both a LinkButton and a NativeButton in your Design System, both based on the kickstartDS Button behind the scenes). General structure: - Component Definition - Component Creation Our React template imports kickstartDS components, and rewires them to our own component API. Start adapting kickstartDS components are meant to be specialized, but general purpose, components in that way. This is also the reason for every other of the processes including the expectation of also adapting the kickstartDS base components (or more specifically: their component API).", "tokens": 239}
{"title": "Components | kickstartDS docs", "heading": "Create a component", "content": "Instead of already having a kickstartDS base component in mind, we start with \"just\" a concept for a componnent. We narrow that concept down, find a matching component in kickstartDS and then massage its properties to fit our use case, just like established by \"Adapt a component\". General structure: - Component Definition - Component Mapping - Component Creation The React template imports kickstartDS components, and rewires them to our own component API.", "tokens": 99}
{"title": "Components | kickstartDS docs", "heading": "Customize a component", "content": "Unlike with adaptation, we do start out with a kickstartDS base component in mind. But it's still missing a crucial feature we need, or one of its features needs a little adjustment to work for us. This means while also following everything established by \"Adapt a component\", we potentially add new, custom properties to our component API that were not part of the original kickstartDS base component. General structure: - Component Definition - Component Creation We can't just re-use existing kickstartDS exports here. Instead we custommize the React template by copying the original markup and adding our own modifications on top.", "tokens": 128}
{"title": "Components | kickstartDS docs", "heading": "Extend a component", "content": "While customizing a component allows adding or mutating functionality directly localized to your selected kickstartDS base component, we use composition when extending a component. To combine features of multiple kickstartDS base components, without actually changing React templates or markup. General structure: - Component Definition - Component Creation We import multiple kickstartDS base components for our React template, and rewire them to our own component API.", "tokens": 85}
{"title": "Components | kickstartDS docs", "heading": "Component Definition", "content": "This is always started with a small intro, and introduces an example component that is used throughout that guide to illustrate the key concepts at play. It's divided into two parts itself: - Purpose, and - Structure", "tokens": 45}
{"title": "Components | kickstartDS docs", "heading": "Purpose", "content": "Every component you add to your Design System should have a clear purpose. This section is about defining that purpose, and introduces the options and restrictions introduced by the chosen processes. We also define a fitting purpose for our example componnent.", "tokens": 51}
{"title": "Components | kickstartDS docs", "heading": "Structure", "content": "Following the purpose, we narrow down on the options and fields our component will need to fulfill that purpose. How we actually go about that will depend on the chosen process again. But it will always end in explicitly writing down your components properties, each with a name (e.g. label), type (e.g. string) and short description (e.g. Text used on button).", "tokens": 83}
{"title": "Components | kickstartDS docs", "heading": "Component Creation", "content": "We bring our structure to life here, by defining our components component API through JSON Schema. We then add a React template parameterized with those properties, wiring them up to kickstartDS base components as needed. JSON Schema definition First a JSON Schema encoding your structure into a component API is created. This can range from copying existing, re-used properties from kickstartDS base components to writing wholly new schemas. React template The TypeScript types generated by our component API get used to create the JSX needed to render your component. This usually involves importing some kickstartDS base components. We then wire our properties to those base components. In the case of customizing a component we will not use the export / template of the customized base component... instead we copy its markup and add our modifications to it.", "tokens": 168}
{"title": "Components | kickstartDS docs", "heading": "Technical debt added", "content": "Different ways of using components and best practices in kickstartDS, to create your own Design System, result in different technical debt being accrued. Simply using a kickstartDS components, maybe renaming a few of their properties, doesn't add much technical debt in the case of upgrades to kickstartDS, or your own code base... because they are minimally invasive in that sense. But when customizing a component, and especially it's rendered markup, you inherit that technical debt. In case that component gets changed in the future, you will have to manage the migration. Changing the markup of a component means a Breaking Change in kickstartDS, and we will always provide a detailed migration guide in those cases... but it's more technical debt nontheless. We try to illustrate the ways each proccess adds such technical debt to your Design System code base.", "tokens": 178}
{"title": "Frequently Asked Questions | kickstartDS docs", "heading": "How can I debug components re-rendering too often / in an infinite loop?", "content": "When being confronted with a case of components re-rendering way too often (compared to your expectation, and the necessity to do so), or even re-rendering in an infinite loop, you can try adding the following dependency to your setup to debug why specific components were actually re-rendered: https://github.com/welldone-software/why-did-you-render For a more detailed intro, see: https://medium.com/welldone-software/why-did-you-render-mr-big-pure-react-component-2a36dd86996f", "tokens": 140}
{"title": "Frequently Asked Questions | kickstartDS docs", "heading": "How can I solve", "content": "SyntaxError: Unexpected token 'export'? The kickstartDS components are shipped as EcmaScript modules (ESM). To use them in a Next.js project, they have to be transpiled to CommonJS modules (CJS). While Next.js doesn't transpile modules that are installed via NPM, you need to customize the Babel configuration or use the next-transpile-modules plugin (recommended).", "tokens": 95}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Adapt", "content": "Button component This guided example shows how you'd often add components to your Design System that use a kickstartDS base component pretty directly. This mostly includes components that are needed in every Design System, and that typically also get added with the same name (like our Button here). Even while directly using the component, including its name, from kickstartDS, you'll want to find the correct set of properties for your own use case. Components in kickstartDS come equipped with properties for a wide range of possible use cases, so it makes sense to reduce those to the ones you really need... to make components easier to understand, use and reason about! We call this type of workflow Adaptation. Learn more about it in our dedicated guide about it. If you're unsure about something, have a look over there. We go into more background detail there about what we're doing here. Not touching the actual markup generated by components let's us get by without adding any custom styling ( CSS / SCSS) to it. We simply reuse the already existing Design Token and component structure.", "tokens": 220}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Overview", "content": "This is how the result of this guide will look like: It will only need two simple steps for that: - Component Definition, and - Component Creation For more details about those steps, have a look at the guide about different component processes and their shared structure.", "tokens": 55}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Purpose", "content": "There are some straight foward things we'd want to do with a button in our Design System. Most obvious ones would probably be putting a label on it, and making the target of it available for users. If the target is set, the resulting button should look like one, but use the a tag semantically. It should just be a styled, but native,  otherwise. Additionally we'll want to be able to influence the size of a button, and be able to choose from a limited set of variants. We'll use the options offered by kickstartDS 1:1 for the size property ( small, medium, large). But for variant we opt to define our own naming, further removing how a button looks from the naming scheme (like outline, clear, etc) and going for straight priority with primary, secondary and tertiary. Finally, being able to mark a button as disabled should be possible!", "tokens": 187}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Structure", "content": "Defining the structure of a component means finding the component API for it: |Property||Type||Description| |Label shown on the button| |Target that should be linked| |Variant of button used| |Size the button should be shown in| |Whether the button should be shown as disabled| Fields that should be required are marked with a *. While directly helping us get a better grasp on our new component, these will also be used to write our JSON Schema later!", "tokens": 101}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "2. Component Creation", "content": "We like to colocate components. This means to have all involved files next to each other in the same folder; the template ( .jsx / .tsx), potential CSS / SASS ( .css / .scss), JavaScript ( .js / .ts), our JSON Schema component definition ( .schema.json), and so on. So we start by creating the directory src/components/button, from our Design System repository root: _1mkdir -p src/components/button This is the folder we'll add new files to in the coming few paragraphs. JSON Schema definition First file we'll create is the JSON Schema definition, encoding the structure we've defined for our component before:", "tokens": 152}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Add basic info describing component", "content": "We start by adding a title, description and $id attribute. The correct $id depends on your Design System configuration. We'll assume you've created components before, living under the schema prefix http://schema.mydesignsystem.com.", "tokens": 55}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Create", "content": "label and target fields... Both fields are straight-forward string type properties, so we just document them a bit! We do mark target by setting format to uri, though, to enable validation later on.", "tokens": 45}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Finished", "content": "JSON Schema Let's have a look at our completed JSON Schema definition. This concludes creating the JSON Schema. When running the schema generation in our Design System again, we should now automatically end up with a corresponding type definition to be used in creation of the template in the next step: How your schema generation is started might change depending on your setup. If you've followed our \"Create your Design System\" guide before, or want to add it like we do, follow this section of it closely. React template As the final step for this example, we'll add the template. This will be a purely functional React component, mapping our component structure (as defined in the JSON Schema) to the original component we're basing our work off of; the kickstartDS Storytelling component.", "tokens": 164}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Start with a boilerplate", "content": "Again we'll start with a very basic skeleton for our React component. We're using TypeScript here ( .tsx), but it works the same with plain JSX ( .jsx).", "tokens": 44}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Add correct typings", "content": "correct typings Import and add generated props from ButtonProps.ts. Generated by our JSON Schema, these guarantee you're matching your expected component structure while implementing. In combination with TypeScript this enables auto-complete and auto-fix for even better DX! (see here, at the very end of that section, for more details) We also include and forward a reference to the underlying  with forwardRef, and allow HTMLAttributes to be passed to the root element.", "tokens": 101}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Add", "content": "Button component 1/5 Now we'll import and add the kickstartDS Button component. To start, we'll use the hard-coded properties of the solid Button variant from our kickstartDS Design System.", "tokens": 45}
{"title": "Adapt `Button` component | kickstartDS docs", "heading": "Storybook setup", "content": "This guide assumes you're using a set up like described in our Create your Design System guide! Be sure to adapt commands and configuration to your use accordingly, when following this part! Add the following file to your src/components/button folder:", "tokens": 53}
{"title": "Component Token | kickstartDS docs", "heading": "Component Token", "content": "Component Token are a representation of values associated with a specific component. They by default inherit from Design Token. Whenever possible, we recommend to keep pointing these to the foundational token, rather than change into hard values such as hex codes. Nevertheless you can use these to fully match a components appearance to a given design layout or specification. Screenshot to illustrate the use of token on component level.", "tokens": 80}
{"title": "ECMAScript 6 (ES6)", "heading": "ECMAScript 6 (ES6)", "content": "ES6 is the specific flavour of JavaScript we're writing for it's much improved module support, making 100% vanilla JavaScript solutions a reality. It is also much more terse and expressive in its syntax (iterators, destructuring, arrow functions, etc). As every piece of code being run in a website built on kickstartDS components is developed in a bespoke fashion, being able to rely on such best practives while also staying complete compatible and performant. As a result, component JavaScript can be used completely independent from the underlying framework or technology, and has its own dedicated build process for optimal code splitting and bundling. Why we care? Read more, or chat with us, to learn how this helps create consistent frontend interfaces", "tokens": 153}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "Summary", "content": "Finally, the wait is over â€¦ today we are very proud to announce the Open Source release of kickstartDS. Itâ€™s been roughly one year since we started to go to market by publishing our first website, and we are thrilled to now share the kickstartDS core with everyone in the Design System community.", "tokens": 68}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "Why have we decided to go Open Source?", "content": "Some of you might have read my post on why we are creating kickstartDS. Today, I can proudly say that we reached the next big milestone of our mission to democratize Design Systems. Last year we started to implement kickstartDS for selected pilot customers, keeping the source behind closed doors. We wanted to validate technical decisions taken, and learn how developers interact and adapt kickstartDS. During that time, while doing user research, presenting our ideas and solutions to developers, we often heard that they really like itâ€¦ and that they would love to test it by directly installing â€œthe packageâ€. Well, who would go for a no-name, closed solution to build up something highly important like their Design System? Open Source is the way! A couple of months ago we took the decision to share all our learnings and practices, wrapped up in the baseline of what kickstartDS is today. We want to continue that learning journey. That will be even easier with people working with kickstartDS independently, who hopefully also share their experiences and stories with us in the process. That is what weâ€™d like to encourage users to do. Just try our setup guideâ€¦ and once you own your Design System based on kickstartDS, really make it your own. Tell us how you adapted it towards your individual needs, even how you named your components, how you get along with it adoption are super interesting to us! So please share it with us and the community.", "tokens": 309}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "Help democratize Design Systems!", "content": "The term Design System describes a broad topic, growing more and more momentum. Where large organizations today mostly have problems with the adoption or governance of theirs, in small to medium enterprises the problem often already is to get a Design System started at all. For example, when standard frameworks are too difficult or complex to adapt, when stakeholders need to be won in a time when frontend experts are a rare good. The approach is doomed and will lead to compromised technical solutions; consuming even more time and budget. Today quite some companies are already tackling similar problems. Talking of Knapsack.cloud, Backlight.dev, Specify, Supernova and many more, here. They all deliver value to simplify workflows for setup, integration, documentation and management of Design Systems. This is all super helpful in spreading the love about Design Systems to teams out there, and is a huge benefit to the process side of things. But you usually still need to create or import all of your components, which means that you still have some hard work before to you yourself, before finally benefitting from these tools. Thereâ€™s also a lot (knowledge and work) going into the setup of a Design System (semantic tokens, hardened components, etc) thatâ€™s not solved by those tools, yet.", "tokens": 268}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "Setting up a code first Design System has never been easier", "content": "To help you getting started quickly, we created documentation guiding you through the installation process of your first Design System built with kickstartDSâ€¦ in just 5 rather simple steps. The main steps will go as follows: - Start your Design System - Design Application - Configure Storybook - Add Components - Publish your Design System Although the resulting Design System will obviously not be finished by finishing these steps, youâ€™ll have everything set up to start on the real work.", "tokens": 106}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "The essential part", "content": "At that point you already got rid of some of the core challenges. Plus, this might even give you the mental freedom to tackle the unique components to your organizations actual needs. Thinking of such components â€¦ usually, every company has content to display. On their website, on marketing or landing pages, in their intranet or documentation, you name it. You can now start developing the perfect â€œHero Visual Componentâ€ with our basic Open Source components or you can skip even that by relying on our complex content components, which you can easily buy for a few bucks to add as additional building blocks for your freshly created Design System. That package, additionally, really puts you in the driving seatâ€¦ speeding up the ride for even the most individual and complex cases youâ€™ll want to solve, the â€œnext component your organization needsâ€. (this refers to Dan Mallâ€™s talk on Convergeâ€™22, available through their registry here)", "tokens": 198}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "Whatâ€™s next?", "content": "Now that kickstartDS is public we look ahead to its future with an open mind. We still have to work on many details to let our documentation really shine, for example. As we want to explain the underlying concepts in-depth. And since everyone is now free to install, test and use kickstartDS we believe in the great openness of the Design System community. We rely on your feedback by adapting to your needs, so that kickstartDS will really become the Design System starter digital teams like to work with. Releasing kickstartDS doesnâ€™t mean that the development is completed. We have lots of ideas in mind. Features or modules which may find the way into the portfolio, thinking of telemetry, adapters, transformers and much more based on our Component API.", "tokens": 162}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "Not to forget: a Design System is nothing without systems using it!", "content": "A Design System is there to generate value, to support the organization to better reach its objectives. Naturally there will be product or feature teams using it. About that, a 6th Step could and maybe even should be added to the setup process of the Design System.", "tokens": 67}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "Step 6: Apply your Design System", "content": "Whilst setting up kickstartDS you made quite a lot of decisions adapting the library to your organizationsâ€™ specific needs. You decided which properties every component needs, how to name components, and much more. What would you say if we told you: you can even add a CMS, using these exact Design System components, with just a handful of clicks? Where your editor immediately benefits from all your decisions, because the properties of components in the editor UI are always aligned with those from your Design System. We offer adapters for some well-known content management systems already, e.g. Sanity.io, NetlifyCMS, Storyblok, Contentful and even WordPress. One more reason why we think: relying on kickstartDS when building your Design System is of huge value for you and the Open Source community, who can start building more adapters and implementations on top of kickstartDS to simplify the process of applying Design Systems.", "tokens": 199}
{"title": "kickstartDS is Open Source now. Letâ€™s start to democratize Design Systems today", "heading": "The importance of the growing Design System community", "content": "Thinking about the best thing we could achieve with kickstartDS, and as already written in this postsâ€™ headline: do our part in democratizing Design Systems. The more people know about kickstartDS, the more organizations use it, the more developers build Design Systems based on it, the better it will become in the future. Helping organizations adopt best practices, and hopefully help everyone to get their Design System that decisive bit faster, while having fun doing it! Join our Discord community to share feedback, ask us questions and start any discussion around kickstartDS. Take a look at kickstartDS on GitHub, and tell us what you think.", "tokens": 142}
{"title": "React | kickstartDS docs", "heading": "Use the button's children as label", "content": "_11import { forwardRef } from 'react';_11import { Button as KdsButton } from '@kickstartds/base/lib/button';_11_11export const Button = forwardRef(({ children, ...props }, ref) => (_11 children} />_11);_11_11// Usage_11_11Click me_11;", "tokens": 86}
{"title": "React | kickstartDS docs", "heading": "Allow markdown in label", "content": "_14import { forwardRef } from 'react';_14import { Button as KdsButton } from '@kickstartds/base/lib/button';_14import ReactMarkdown from 'react-markdown';_14_14export const Button = forwardRef((props, ref) => (_14 }_14/>_14));_14_14// Usage_14;", "tokens": 88}
{"title": "React | kickstartDS docs", "heading": "Replace with Context", "content": "_40import { forwardRef } from 'react';_40import {_40Button as KdsButton,_40ButtonContext,_40ButtonContextDefault,_40} from '@kickstartds/base/lib/button';_40import { ContentBox } from \"@kickstartds/base/content-box\";_40import ReactMarkdown from 'react-markdown';_40_40const Button = forwardRef((props, ref) => (_40 }_40/>_40));_40_40export const ButtonProvider = (props) => (_40_40);_40_40// Usage_40_40_40_40_40// Works also with buttons nested in other components_40_40<ContentBox_40image=\"/image.jpg\"_40ratio=\"16:9\"_40alignement=\"left\"_40topic=\"Hey!\"_40link={_40variant: \"solid\",_40size: \"medium\",_40label: \"Click me\" // <- !!_40}_40/>_40", "tokens": 230}
{"title": "Privacy policy", "heading": "1) Information on the Collection of Personal Data and Contact Details of the Controller", "content": "1.1 We are pleased that you are visiting our website and thank you for your interest. On the following pages, we inform you about the handling of your personal data when using our website. Personal data is all data with which you can be personally identified. 1.2 The controller in charge of data processing on this website, within the meaning of the General Data Protection Regulation (GDPR), is ruhmesmeile GmbH Schumannstr. 15 53113 Bonn Deutschland Tel.: +49 228 688 966-20 E-Mail: mail@ruhmesmeile.com. The controller in charge of the processing of personal data is the natural or legal person who alone or jointly with others determines the purposes and means of the processing of personal data. 1.3 The controller has designated a data protection officer for this website. He can be reached as follows: Tom Dalhoff SchaafenstraÃŸe 25 50676 Cologne Germany Email: datenschutz@ruhmesmeile.com 1.4 This website uses SSL or TLS encryption for security reasons and to protect the transmission of personal data and other confidential content (e.g. orders or inquiries to the controller). You can recognize an encrypted connection by the character string https:// and the lock symbol in your browser line.", "tokens": 282}
{"title": "Privacy policy", "heading": "2) Data Collection When You Visit Our Website", "content": "When using our website for information only, i.e. if you do not register or otherwise provide us with information, we only collect data that your browser transmits to our server (so-called \"server log files\"). When you visit our website, we collect the following data that is technically necessary for us to display the website to you: - Our visited website - Date and time at the moment of access - Amount of data sent in bytes - Source/reference from which you came to the page - Browser used - Operating system used - IP address used (if applicable: in anonymized form) Data processing is carried out in accordance with Art. 6 (1) point f GDPR on the basis of our legitimate interest in improving the stability and functionality of our website. The data will not be passed on or used in any other way. However, we reserve the right to check the server log files subsequently, if there are any concrete indications of illegal use.", "tokens": 202}
{"title": "Privacy policy", "heading": "3) Contacting Us", "content": "3.1 Zendesk Pseudonymized data is collected and stored on this website using technologies from Zendesk Inc, 1019 Market St, San Francisco, USA (www.zendesk.com) for the purpose of web analysis and to operate the live chat system for responding to live support requests. User profiles can be created under a pseudonym from these pseudonymized data. For this purpose, cookies may be used. Cookies are small text files that are stored locally in the cache of the visitor's internet browser. The cookies enable, among other things, the recognition of the internet browser. If the information collected in this way relates to personal data, it is processed in accordance with Art. 6 (1) point f GDPR, on the basis of our legitimate interest in effective customer service and statistical analysis of user behavior for optimization purposes. The data collected with Zendesk technologies will not be used to personally identify the visitor to this website and will not be combined with personal data about the bearer of the pseudonym without the separately-given consent of the person concerned. To avoid the storage of Zendesk cookies, you can set your Internet browser in a way that cookies can no longer be stored on your computer in the future or cookies that have already been stored are deleted. However, disabling all cookies may result in functional limitations when using the web site. You can deactivate the collection and storage of data for the purpose of creating a pseudonymized user profile at any time with effect for the future by sending us your objection by e-mail to the e-mail address stated in the imprint. 3.2 Calendly This website uses the software \"Calendly\" of the provider Calendly, LLC, BB&T Tower, 271 17th St NW, Atlanta, GA 30363, USA to provide an online appointment booking function. For the purpose of scheduling appointments, first name, surname and email address (and telephone number if a telephone appointment is requested) are collected in accordance with Art. 6 Para. 1 lit. b DSGVO and transmitted to Calendly in accordance with Art. 6 para. 1 lit. f GPDR on the basis of our legitimate interest in effective customer management and efficient appointment management and will be stored there for the purpose of organizing appointments. This may also involve data transfer to the servers of Calendly, LLC, in the USA. After the appointment has been held or after the agreed appointment period has expired, your data will be deleted by Calendly. We have concluded an order processing agreement with Calendly, in which we oblige Calendly to protect the data of our customers in accordance with the legal requirements. Details of Calendly's data protection policy can be found here: https://calendly.com/pages/privacy 3.3 When you contact us (e.g. via contact form or e-mail), personal data is collected. Which data is collected in the case of a contact form can be seen from the respective contact form. This data is stored and used exclusively for the purpose of responding to your request or for establishing contact and for the associated technical administration. The legal basis for processing data is our legitimate interest in responding to your request in accordance with Art. 6 (1) point f GDPR. If your contact is aimed at concluding a contract, the additional legal basis for the processing is Art. 6 (1) point b GDPR. Your data will be deleted after final processing of your enquiry; this is the case if it can be inferred from the circumstances that the facts in question have been finally clarified, provided there are no legal storage obligations to the contrary.", "tokens": 754}
{"title": "Privacy policy", "heading": "4) Commentary Function", "content": "As a user you can subscribe to the follow-up comments. You will receive a confirmation e-mail to ensure that you are the owner of the specified e-mail address (double opt-in procedure). The legal basis for data processing in the case of subscribing to comments is Art. 6 (1) point a GDPR. You can unsubscribe from current comment subscriptions at any time with effect for the future. Please refer to the confirmation e-mail for further information on the option for unsubscribing.", "tokens": 108}
{"title": "Privacy policy", "heading": "5) Use of Client Data for Direct Advertising", "content": "Subscribe to our e-mail newsletter If you register for our e-mail newsletter, we will regularly send you information about our offers. The only mandatory data for sending the newsletter is your e-mail address. The provision of further data is voluntary and will be used to address you personally. We use the so-called double opt-in procedure for sending the newsletter. This means that we will only send you an e-mail newsletter once you have expressly confirmed that you consent to receiving newsletters. We will then send you a confirmation e-mail asking you to confirm that you wish to receive the newsletter in future by clicking on an appropriate link. By activating the confirmation link, you give us your consent for the use of your personal data pursuant to Art. 6 (1) point a GPPR. When you register for the newsletter, we store your IP address entered by your Internet service provider (ISP) as well as the date and time of registration for the purpose of tracing any possible misuse of your e-mail address at a later date. The data collected by us when you register for the newsletter is used exclusively for the promotional purposes by way of the newsletter. You can unsubscribe from the newsletter at any time via the link provided for this purpose in the newsletter or by sending a corresponding message to the responsible person named at the beginning. After unsubscribing, your e-mail address will be deleted from our newsletter distribution list immediately, unless you have expressly consented to further use of your data, or we reserve the right to a more extensive use your data which is permitted by law and about which we inform you in this declaration. Sending the newsletter to existing customers If you have provided us with your e-mail address when purchasing products, we reserve the right to regularly send you offers for products similar to those already purchased by e-mail. Pursuant to Section 7 (3) German law against unfair competition, we do not need to obtain separate consent from you. In this respect, data processing is carried out solely on the basis of our legitimate interest in personalized direct advertising pursuant to Art. 6 (1) point f GDPR. If you have initially objected to the use of your e-mail address for this purpose, we will not send you an e-mail. You are entitled to object to the future use of your e-mail address for the aforementioned advertising purpose at any time by notifying the controller named at the beginning of this document. In this regard, you only have to pay the transmission costs according to the basic tariffs. Upon receipt of your objection, the use of your e-mail address for advertising purposes will cease immediately.", "tokens": 543}
{"title": "Privacy policy", "heading": "6) Web Analysis Services", "content": "6.1 Google (Universal) Analytics This website uses Google (Universal) Analytics, a web analytics service provided by Google Ireland Limited, Gordon House, 4 Barrow St, Dublin, D04 E5W5, Ireland (\"Google\"). Google (Universal) Analytics uses \"cookies\", which are text files placed on your computer, to help the website analyze how users use the site. The information generated by the cookie about your use of this website (including the abbreviated IP address) is usually transferred to a Google server and stored there and may also be transferred to the servers of Google LLC. in the USA. This website uses Google (Universal) Analytics exclusively with the extension \"_anonymizeIp()\", which ensures anonymization of the IP address by shortening it and excludes the possibility of direct personal reference. Through the extension, your IP address will be shortened by Google within member states of the European Union or in other signatory states of the Agreement on the European Economic Area before. Only in exceptional cases will the full IP address be transferred to a server of Google LLC. in the USA and shortened there. On our behalf, Google will use this information to evaluate your use of the website, to compile reports on the website activities and to provide us with further services related to the use of the website and the Internet. The IP address transmitted by your browser within the framework of Google (Universal) Analytics is not combined with other Google data. Via a special function called \"Demographics\", Google Analytics also enables the compilation of statistics with statements about the age, gender and interests of site visitors based on an evaluation of interest-related advertising and with the use of third-party information. This allows the definition and differentiation of user groups of the website for the purpose of target-group-optimized marketing measures. However, data sets collected via \"Demographics\" cannot be assigned to a specific person. Details on the processing operations initiated and on Google's handling of data collected from websites can be found here: https://policies.google.com/technologies/partner-sites?hl=en All the processing described above, in particular the setting of Google Analytics cookies for reading information on the terminal device used, is only carried out if you have given us your express consent in accordance with Art. 6 Para. 1 letter a GDPR. Without this consent, the use of Google Analytics during your visit to our website will not take place. You can withdraw your consent at any time with effect for the future. To exercise your right of withdrawal of consent, please deactivate this service in the \"Cookie-Consent-Tool\" provided on the website. We have concluded a data processing agreement with Google for the use of Google Analytics, which obliges Google to protect the data of our site visitors and not to pass it on to third parties. For the transmission of data from the EU to the USA, Google relies on so-called standard data protection clauses of the European Commission, which are intended to ensure compliance with the European data protection level in the USA. Further information about Google (Universal) Analytics can be found here: https://policies.google.com/privacy?hl=en&gl=en 6.2 - Hotjar This website uses the Hotjar web analysis service of Hotjar Ltd. Hotjar Ltd. is a European company based in Malta (Hotjar Ltd, Level 2, St Julians Business Centre, 3, Elia Zammit Street, St Julians STJ 1000, Malta, Europe Tel.: +1 (855) 464-6788). This tool enables us to retrace movements on our website, on which Hotjar is deployed (so-called heatmaps). For example, it explains how far users scroll and which buttons they click and how often. Furthermore, it is possible, when using this tool, to get feedback directly from our website users. In this way, we will be provided with valuable information to make our websites even faster and more customer friendly. We pay particular attention to the protection of your personal data when using this tool. Therefore, we only can retrace which buttons you click and how far you scroll. Areas of sites that may contain personal information about you or third parties are automatically hidden by Hotjar and cannot be retraced at any time. All processing described above, in particular the reading of information on the end device used, is only carried out if you have given us your express consent to do so in accordance with Art. 6 (1) point a GPDR. Without this consent, Hotjar will not be used during your visit to the website. You can revoke your consent at any time with effect for the future. To exercise your revocation, please deactivate this service in the \"Cookie Consent Tool\" provided on the website. With the help of a \"Do Not Track Headers\", Hotjar, alternatively gives every user the opportunity to prevent the Hotjar tool from being used, so that no data about the visit of the respective website is recorded. This is a setting that supports all common browsers in the respective current version. To this end, your browser sends a request to Hotjar, demanding the tracking of the respective user to be deactivated. If you visit our website with different browsers/computers, you must use the \"Do Not Track Header\" for each browser/computer separately. For more detailed instructions and information about your browser, please refer to: https://www.hotjar.com/opt-out. For more information about Hotjar Ltd. and the Hotjar tool, please refer to: https://www.hotjar.com The privacy policy of Hotjar Ltd. can be found at: https://www.hotjar.com/privacy", "tokens": 1172}
{"title": "Privacy policy", "heading": "7) Site functionalities", "content": "Use of YouTube Videos This website uses the YouTube embedding function for display and playback of videos offered by the provider YouTube, which belongs to Google Ireland Limited, Gordon House, 4 Barrow St, Dublin, D04 ESW5, Ireland (\"Google\"). To this end, the extended data protection mode is used to ensure, according to provider information, that user information will only be stored once the playback function of the video is started. When the playback of embedded YouTube videos is started, the provider sets \"YouTube\" cookies to collect information about user behavior. According to indications from YouTube, the use of those cookies is intended, among other things, to record video statistics, to improve user-friendliness and to avoid improper actions. If you are logged in to Google, your information will be directly associated with your account when you click on a video. If you do not wish to be associated with your profile on YouTube, you must log out before activating the button. Google saves your data (even for users who are not logged in) as usage profiles and evaluates them. You have the right to object to the creation of these user profiles, whereby you must contact YouTube to exercise this right. When using YouTube, personal data may also be transmitted to the servers of Google LLC. in the USA. Regardless of whether the embedded video is played back, a connection to the Google network \"double click\" is established when visiting this website. This may trigger further data processing beyond our control. All processing described above, in particular the setting of cookies for the reading of information on the end device used, will only be carried out if you have given us your express consent to do so in accordance with Art. 6 (1) point a GDPR. Without this consent, Youtube-Videos will not be used during your visit to the website. You can revoke your consent at any time with effect for the future. To exercise your revocation, please deactivate this service in the \"Cookie Consent Tool\" provided on the website. Further information on YouTube's privacy policy can be found at: www.google.com/policies/privacy/. 7.1 Zoom We use the Zoom service of Zoom Video Communications Inc, 55 Almaden Blvd, Suite 600, San Jose, CA 95113, USA (hereinafter \"Zoom\") to conduct online meetings, video conferences and/or webinars. When using Zoom, different data will be processed. The extend of the processed data depends on the data you provide before or during your participation in an online meeting, video conference or webinar. When using Zoom, data of the communication participants is processed and stored on Zoom servers. This data may include your registration data (name, e-mail address, telephone (optional) and password) and meeting data (topic, participant IP address, device information, description (optional)). In addition, visual and audio contributions of the participants, as well as voice inputs can be processed in chats. When processing personal data necessary for the performance of a contract with you (this also applies to processing operations which are necessary for the performance of pre-contractual measures), Art. 6 (1) point b GDPR constitutes the legal basis. If you have given us your consent for the processing of your data, the processing will be carried out based on Art. 6 (1) point a GDPR. Consent granted can be revoked at any time with effect for the future. Otherwise, the legal basis for the processing of data when conducting online meetings, videoconferences or webinars is our legitimate interest pursuant to Art. 6 (1) point f GDPR in the effective conduct of online meetings, webinars or videoconferences. For more information about Zoom's use of data, please refer to Zoom's privacy policy at https://zoom.us/docs/de-de/privacy-and-legal.html", "tokens": 793}
{"title": "Privacy policy", "heading": "8) Tools and Miscellaneous", "content": "This website uses a so-called \"cookie consent tool\" to obtain effective user consent for cookies and cookie-based applications that require consent. The \"cookie consent tool\" is displayed to users in the form of an interactive user interface when they access the page, on which consent for certain cookies and/or cookie-based applications can be given by ticking the appropriate box. Through the use of the tool, all cookies/services requiring consent are only loaded if the respective user provides the corresponding consent by ticking the corresponding box. This ensures that such cookies are only set on the respective end device of the user if consent has been granted. The tool sets technically necessary cookies to save your cookie preferences. Personal user data is generally not processed. If, in individual cases, personal data (such as the IP address) is processed for the purpose of storing, assigning or logging cookie settings, this is done in accordance with Art. 6 (1) point GDPR on the basis of our legitimate interest in legally compliant, user-specific and user-friendly consent management for cookies and thus in a legally compliant design of our website. Further legal basis for the processing is Art. 6 (1) point c GDPR. As the responsible party, we are subject to the legal obligation to make the use of technically unnecessary cookies dependent on the respective user consent. Further information on the operator and the setting options of the cookie consent tool can be found directly in the corresponding user interface on our website.", "tokens": 300}
{"title": "Privacy policy", "heading": "9) Rights of the Data Subject", "content": "9.1 The applicable data protection law grants you the following comprehensive rights of data subjects (rights of information and intervention) vis-Ã -vis the data controller with regard to the processing of your personal data: - Right of access by the data subject pursuant to Art. 15 GDPR: You shall have the right to receive the following information: The personal data processed by us; the purposes of the processing; the categories of processed personal data; the recipients or categories of recipients to whom the personal data have been or will be disclosed; the envisaged period for which the personal data will be stored, or, if not possible, the criteria used to determine that period; the existence of the right to request from the controller rectification or erasure of personal data or restriction of processing personal data concerning the data subject or to object to such processing; the right to lodge a complaint with a supervisory authority; where the personal are not collected from the data subject, any available information as to their source; the existence of automated decision-making, including profiling and at least in those cases, meaningful information about the logic involved, as well as the significance and envisaged consequences of such processing for the data subject; the appropriate safeguards pursuant to Article 46 when personal data is transferred to a third country. - Right to rectification pursuant to Art. 16 GDPR: You have the right to obtain from the controller without undue delay the rectification of inaccurate personal data concerning you and/or the right to have incomplete personal data completed which are stored by us. - Right to erasure (â€œright to be forgottenâ€) pursuant to Art. 17 GDPR: You have the right to obtain from the controller the erasure of personal data concerning you if the conditions of Art. 17 (2) GDPR are fulfilled. However, this right will not apply for exercising the freedom of expression and information, for compliance with a legal obligation, for reasons of public interest or for the establishment, exercise or defense of legal claims. - Right to restriction of processing pursuant to Art. 18 GDPR: You have the right to obtain from the controller restriction of processing your personal data for the following reasons: As long as the accuracy of your personal data contested by you will be verified. If you oppose the erasure of your personal data because of unlawful processing and you request the restriction of their use instead. If you require the personal data for the establishment, exercise or defense of legal claims, once we no longer need those data for the purposes of the processing. If you have objected to processing on grounds relating to your personal situation pending the verification whether our legitimate grounds override your grounds. - Right to be informed pursuant to Art. 19 GDPR: If you have asserted the right of rectification, erasure or restriction of processing against the controller, he is obliged to communicate to each recipient to whom the personal date has been disclosed any rectification or erasure of personal data or restriction of processing, unless this proves impossible or involves disproportionate effort. You have the right to be informed about those recipients. - Right to data portability pursuant to Art. 20 GDPR: You shall have the right to receive the personal data concerning you, which you have provided to us, in a structured, commonly used and machine-readable format or to require that those data be transmitted to another controller, where technically feasible. - Right to withdraw a given consent pursuant to Art. 7 (3) GDPR: You have the right to withdraw your consent for the processing of personal data at any time with effect for the future. In the event of withdrawal, we will immediately erase the data concerned, unless further processing can be based on a legal basis for processing without consent. The withdrawal of consent shall not affect the lawfulness of processing based on consent before its withdrawal. - Right to lodge a complaint pursuant to Art. 77 GDPR: Without prejudice to any other administrative or judicial remedy, you have the right to lodge a complaint with a supervisory authority, in particular in the Member State of your habitual residence, place of work or place of the alleged infringement if you consider that the processing of personal data relating to you infringes the GDPR. 9.2 RIGHT TO OBJECT IF, WITHIN THE FRAMEWORK OF A CONSIDERATION OF INTERESTS, WE PROCESS YOUR PERSONAL DATA ON THE BASIS OF OUR PREDOMINANT LEGITIMATE INTEREST, YOU HAVE THE RIGHT AT ANY TIME TO OBJECT TO THIS PROCESSING WITH EFFECT FOR THE FUTURE ON THE GROUNDS THAT ARISE FROM YOUR PARTICULAR SITUATION. IF YOU EXERCISE YOUR RIGHT TO OBJECT, WE WILL STOP PROCESSING THE DATA CONCERNED. HOWEVER, WE RESERVE THE RIGHT TO FURTHER PROCESSING IF WE CAN PROVE COMPELLING REASONS WORTHY OF PROTECTION FOR PROCESSING WHICH OUTWEIGH YOUR INTERESTS, FUNDAMENTAL RIGHTS AND FREEDOMS, OR IF THE PROCESSING SERVES TO ASSERT, EXERCISE OR DEFEND LEGAL CLAIMS. IF WE PROCESS YOUR PERSONAL DATA FOR DIRECT MARKETING PURPOSES, YOU HAVE THE RIGHT TO OBJECT AT ANY TIME TO THE PROCESSING OF YOUR PERSONAL DATA WHICH ARE USED FOR DIRECT MARKETING PURPOSES. YOU MAY EXERCISE THE OBJECTION AS DESCRIBED ABOVE. IF YOU EXERCISE YOUR RIGHT TO OBJECT, WE WILL STOP PROCESSING THE DATA CONCERNED FOR DIRECT ADVERTISING PURPOSES.", "tokens": 1152}
{"title": "Privacy policy", "heading": "10) Duration of Storage of Personal Data", "content": "The duration of the storage of personal data is based on the respective legal basis, the purpose of processing and - if relevant â€“ on the respective legal retention period (e.g. commercial and tax retention periods). If personal data is processed on the basis of an express consent pursuant to Art. 6 (1) point a GDPR, this data is stored until the data subject revokes his consent. If there are legal storage periods for data that is processed within the framework of legal or similar obligations on the basis of Art. 6 (1) point b GDPR, this data will be routinely deleted after expiry of the storage periods if it is no longer necessary for the fulfillment of the contract or the initiation of the contract and/or if we no longer have a justified interest in further storage. When processing personal data on the basis of Art. 6 (1) point f GDPR, this data is stored until the data subject exercises his right of objection in accordance with Art. 21 (1) GDPR, unless we can provide compelling grounds for processing worthy of protection which outweigh the interests, rights and freedoms of the data subject, or the processing serves to assert, exercise or defend legal claims. If personal data is processed for the purpose of direct marketing on the basis of Art. 6 (1) point f GDPR, this data is stored until the data subject exercises his right of objection pursuant to Art. 21 (2) GDPR. Unless otherwise stated in the information contained in this declaration on specific processing situations, stored personal data will be deleted if it is no longer necessary for the purposes for which it was collected or otherwise processed.", "tokens": 338}
{"title": "JSON Schema | kickstartDS docs", "heading": "Storybook JSON Schema Addon", "content": "Displays associated JSON Schema documentation using a rich JSON Schema Explorer interface, and adds a validating JSON Code Editor with semantic auto-complete to interact with your components, and copy configurations with ease. JSON Schema Explorer is based on the excellent Atlassian JSON Schema Viewer. It was slightly modified to generate bundles that can be imported for partial use, like this addon does. JSON Code Editor is based on @monaco-editor/react. The editor is connected to your story state / args, so changing props through Controls is reflected in the code shown. Vice-versa if you edit the JSON, and the result is valid according to the schema, your changed args are applied to the story, too. Show me a working demo (click on the JSON Schema addon tab) View the addon on Github: https://github.com/kickstartDS/storybook-addon-jsonschema Or directly on Storybooks page: https://storybook.js.org/addons/@kickstartds/storybook-addon-jsonschema", "tokens": 224}
{"title": "JSON Schema | kickstartDS docs", "heading": "What it's for", "content": "Three things you can use this addon for: - Explore associated JSON Schema documentation, in a nicely organized fashion in the JSON Schema Explorer - Configure components through Controls, copy the resulting JSON as a starting point or template for API-usage / data generation purposes in the JSON Code Editor - Paste JSON to validate data or preview component state in the JSON Code Editor", "tokens": 78}
{"title": "JSON Schema | kickstartDS docs", "heading": "Getting started", "content": "Prerequesite: Your components need to have JSON Schema files associated with them. Additionally schemas need to be dereferenced already, as $ref-resolution is not (a tested) part of this addon (yet? ... let us know in the issues if you need this). First step is to install the addon: _1$ yarn add --dev @kickstartds/storybook-addon-jsonschema Second step, register the addon inside your .storybook/main.js (just add it to the list): _3module.exports = {_3addons: ['@kickstartds/storybook-addon-jsonschema'],_3}; Third step, export the schema as component- or story parameter: _20export default {_20title: 'Button',_20component: Button,_20parameters: {_20jsonschema: {_20$schema: 'http://json-schema.org/draft-07/schema#',_20$id: 'https://my-components/button.schema.json',_20type: 'object',_20properties: {_20primary: {_20type: 'boolean',_20default: false,_20},_20label: {_20type: 'string',_20},_20},_20},_20},_20}; For a detailed explanation on how to add this to your project, have a look at part three of our \"Create your Design System\" guide.", "tokens": 326}
{"title": "Legal notice", "heading": "Legal notice", "content": "kickstartDS is a service provided by ruhmesmeile GmbH Registered office of the company: Bonn Court of registration: Amtsgericht Bonn Register No: HRB 20812 VAT identification number according to Â§ 27a of Value Added Tax Act: DE 295835353 Schumannstr. 15 53113 Bonn Phone: +49 228 688 966-20 Fax: +49 228 688 966-28 hello@kickstartds.com Responsibilities: Responsible for content as per Â§ 6 MDStV: Daniel Ley Authorised shareholder representative: Daniel Ley, Jonas Ulrich Platform of the EU Commission regarding online dispute resolution: https://ec.europa.eu/consumers/odr The Seller is neither obliged nor prepared to attend a dispute settlement procedure before an alternative dispute resolution entity.", "tokens": 174}
{"title": "Blog â€“ releases, updates, background info // kickstartDS", "heading": "Welcome to the kickstartDS Blog", "content": "Here we keep you up to date on releases, updates and background info About kickstartDS Background Meta Framework About kickstartDS Documentation Open Source Release Spotlight About kickstartDS Components Frontend Release Spotlight About kickstartDS Open Source Release Spotlight Token About kickstartDS Background Components COSS Open Source About kickstartDS Design System Service Background Frontend Demo Frontend Background Components Frontend Components About kickstartDS Background Dig deeper â›ï¸", "tokens": 95}
{"title": "Add a Recipe | kickstartDS docs", "heading": "Add a Recipe", "content": "This will follow shorty, please come back soon. It's part of \"4. Components\" of the main \"Create your Design System\" guide. Please come back soon! This will follow shorty, please come back soon. It's part of \"4. Components\" of the main \"Create your Design System\" guide. Please come back soon!", "tokens": 76}
{"title": "Release Spotlight: Container Queries", "heading": "Summary", "content": "#tldr: Container Queries are another new feature coming with the Open Source release of kickstartDS. Itâ€™s a proposed feature for CSS that allows the styling of elements to be based on the size of the container in which they are placed, rather than the size of whole browser frame. This is important for Design Systems because it allows for more flexibility and modularity in the design of components.", "tokens": 87}
{"title": "Release Spotlight: Container Queries", "heading": "Container Queries are the perfect evolution", "content": "In the past everyone had to rely on Media Queries when adapting the design and layout of components, especially those displaying content. When thinking about Design Systems, everyone wants to have fully-fluid components, which automatically adapt to their surrounding layout or grid. CSS Container Queries finally take care of this long-lasting pain. Therefore we, very early on, decided to rely on the use of Container Queries, even though the support in browsers is still incomplete, as of today. We believe it wonâ€™t take long until it will be fully supported natively, and until then we already smooth over the currently remaining gaps with really slim polyfills. We can also already see that it was the right decision, when thinking about a starter kit for Design Systems, in the first projects utilizing them. Lately more and more articles (like this good one) also surfaced, talking about Container Queries and their use for Design Systems.", "tokens": 197}
{"title": "Release Spotlight: Container Queries", "heading": "What makes Container Queries so great?", "content": "With Container Queries frontend developers can create overarching grid layouts with components in them that automatically adjust to the size of the container they are placed in, rather than having to be restricted to (and by) Media Queries â€¦ to apply styles based on the size of the entire viewport. This allows developers to create components, developed in isolation, that can adapt to different screen sizes and devices, making them more efficient and consistently useful. Ultimately this means that a component can be used in a greater variety of contexts. Which in turn makes it easier to create flexible, responsive designs that work and improve the user experience of a product, page or interface overall.", "tokens": 139}
{"title": "Release Spotlight: Container Queries", "heading": "How we approach it in kickstartDS", "content": "Components in kickstartDS are distinct units of interface, that shouldnâ€™t make any assumptions about where theyâ€™re used. They should just use up all the space given to them in a responsive and efficient way. This makes it necessary to add dedicated layout functionality to your Design System, to help users to actually create pages and interfaces out of your offered components. We offer the Section for this purpose, especially when constructing websites, because it has some really nice convenience features implemented to aid in that. It is comparable to an â€œinvisible componentâ€, specialized for giving you control over the targeted layout of your page, and providing context to your components / content. You can control the Gutter and Mode. While Gutter controls the amount of spacing between components, Mode is a parameter to decide on the general layout of items inside a Section. Using Mode you can choose between different display modes for your components: evenly split in a grid-like style, what we call a tile layout, evenly stretched with the default mode or vertically stacked with the list mode. Take a look into our documentation to see some more examples. For more general requirements, not covered by our Section, we recommend using Bedrock Layouts. It integrates nicely with kickstartDS way of thinking about token, have a look at our docs section about it to learn more about hooking those two up.", "tokens": 286}
{"title": "Release Spotlight: Container Queries", "heading": "Container Queries are here to stay", "content": "We want to do everything to encourage people to create their own Design System. Our best practices and design decisions, of all different kinds, should hopefully help in simplifying the process and setup. Itâ€™s why we also use semantic token as one core concept presented in last weekâ€™s release spotlight. With Container Queries we now showcase the use and implementation of another future-proofing functionality with this, to get the perfect fit for your components, regardless of the layout they are placed into. Let me quote Brad Frostâ€™s view on Layout & Grid in Design Systems before you hit our docs to check it out on your own - Design system developers create fully-fluid components and use container query syntaxto manage each componentâ€™s breakpoints. - Design system developers provide layout and grid components (outlined above) for common layout solutions. - Design system consumers do one of the following: a) Use design system-provided layout and grid components in their products b) Create product-specific custom layouts and grid solutions - Consumers drop design system components into ds-provided or custom layouts, and those components Just Work, irrespective of the layout they are placed into.", "tokens": 248}
{"title": "Release Spotlight: Container Queries", "heading": "Try it now", "content": "I hope that sparked your curiosity, and just increases your desire to try it out on your own. The best place to start are our docs, which will get their own, final Release Note soon. If you have any questions, just join our Discord community or drop us an email to hello@kickstartds.com", "tokens": 68}
{"title": "Migrations | kickstartDS docs", "heading": "Migrations", "content": "There's currently only a single migration available. Have a look at it here for upgrade unstruction for kickstartDS 2.0.0: Upgrade 2.0.0 guide Integration with common React frameworks can really speed up adoption, and make the difference between a successful Design System... and one that fails!", "tokens": 65}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Summary", "content": "#tldr: this post explains and presents the Design System Initiative. Read the what, the why and for whom it might be the best path to kickstarting a design system.", "tokens": 41}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "But first, what is a design system?", "content": "To provide some shared framing, what we refer to when speaking about design systems is a library of coded components which itself is usually part of a broader platform of shared principles, processes, tools and assets, typically the brand portal of a company. The design system serves as the single point of truth and empowers digital teams to create seamless, brand-consistent and unified experiences. Here is NN/g: Nielsen Norman Groupâ€™s description: Design Systems â€“ also known as â€œpattern librariesâ€ or â€œcomponent librariesâ€ â€“ promote quality, consistent UX design across products; and expedite the work of designers, developers, and anyone else working on a digital service. Itâ€™s important to realize that every design system should be the result of different stakeholders within an organization, often sharing the same objectives, but each with their very own perspective. The main user group is normally a multi-disciplinary team of designers, front-end developers and UX. They are the ones primarily caring for, maintaining and sharing the design system. But without the collaboration and contribution of mostly all parties involved in digital product and service creation, such a system will fail tremendously fast. We believe that every organization even running only a few digital experiences will already benefit from a design system. So, when should you â€¦", "tokens": 271}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "â€¦consider initializing a design system?", "content": "Our research showed, that most companies considering to launch a design system, want to (re-)launch a major digital touch point, like their main website or an important new product or service. The larger the organization the more ineffective work without a design system becomes. Often these companies are driven by the following indicators in regards to productivity, quality, accessibility and performance: - Why do we or our agency need to invest money into re-creating the same UI design again and again? - Why does no one want to re-use existing assets? - Why arenâ€™t they working with the new infrastructure? - Can we improve speed-to-market with the new system? - Why is every little update taking so much time and resources? - Why do so many customers complain about inconsistencies? - Why canâ€™t we change the logo/colors and re-use it for our other brands? - Why do we need to refactor everything to match accessibility needs? I bet you have your own questions, some of which probably match the ones above.", "tokens": 220}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Choosing the right starting point", "content": "The scope of starting a design system can easily feel overwhelming, and it is tough to know, and feel confident, when and where to start. This is where can be there for you, to support you and your team. Let me introduce our process and how we, in collaborating with you, would tackle that task. We call this a â€œdesign system initiativeâ€. This is a proven approach with a series of one-to-two-hour workshops, in which we work our way through the thick jungle of topics and questions with you.", "tokens": 117}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Getting the design system initiative started", "content": "During the initiative we usually run around seven to nine workshops including stakeholder mapping, exploring your current inventory as the baseline to synthesize to what should be real core components, in parallel we will sound out a strategy for the technical implementation and ultimately, we will identify a product serving as the potential pilot project. We will adapt the phases and workshops to your individual needs. Therefore the initiative will start with a â€œclassicâ€ kickoff workshop with your core team, or the people who currently own that responsibility. No need for C-level yet. During that first workshop we introduce our process and guide you through all the steps in more detail. On the one hand, that is for you to get familiar with us, and on the other hand of course for us to get to know you better. We want to learn how you want to communicate with us and the stakeholders, and what your expectation towards the initiative is.", "tokens": 190}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Talking of stakeholders â€¦", "content": "A design system is not only a product serving other products, but in the best case also also a medium facilitating communication throughout the whole organization. You need buy-in from all important stakeholders, otherwise this or any other initiative initializing a design system will not succeed. Creating awareness of the shared goals and suitable ways to get the stakeholders involved is helpful to make progress and push things forward. You want the organization to adopt and grow the design system already at an early-stage. That is why we investigate this very early in the process. In the stakeholder workshop we gain a common understanding on why we need to single out and involve specific stakeholders. Next we collect lean persona like cards of the stakeholders. Which we map towards their involvement in a design system overall in the following step. From finding personas who need to take part in decisions to people who just need to be informed on a regular cadence. We also want to identify the stakeholders who need to participate in the next workshops.", "tokens": 202}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Getting your hands dirty", "content": "The series of workshops is continued by digging through all the components being used by all digital products the client has. We completely explore your frontend landscape, to inventory and cluster all existing components. Sometimes this step was already performed by internal designers or developers, and possibly led to asking the kickstartDS team for their support. However, this collection and overview will help you to understand what you have, what you might need and make it more likely that everyone, including the important stakeholders, will see the inconsistencies at a single glance. At the end of this workshop all the items will be analyzed and reviewed to decide on relevant elements.", "tokens": 130}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Split it up! Identification and technology", "content": "After washing our hands, having just dug up all that inconsistent and dusty stuff, we usually start two separate streams: the process of identifying future design system components, while also discussing options for the technical implementation with the IT and operations teams. The identification process will be prepared by us upfront, as an input for the next workshop. Starting from the inventory we will synthesize and unify components, to be specified through tokens and component propertiesâ€¦ to later match the needed layout recipes. In parallel we will work on the implementation strategy. Discussing which tech stack fits best, or what might be the preferred tool chain and build pipeline setup. How future components can be integrated, which process and / or policy needs to be adopted, etc. As you might guess, this is very unique within each organization.", "tokens": 167}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Coming back together", "content": "Although components might be developed in isolation, we prefer to again collaborate with you after we turned our focus away for the identification and systematical preparation of future design system components. Meeting again we will share and iterate on our proposal how to structure each element. This will help you to better understand the underlying principles and the architecture for the core of your design system. Which is super important! We might, for example, discuss how to name elements and their options, to shape your design systemsâ€™ shared vocabulary.", "tokens": 106}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Finding the right pilot", "content": "Although the launch of your most preciously held project (like your main website, as mentioned in the beginning) may have been one, or even the main, reason you wanted to make use of a design systemsâ€™ benefits, we all know that this is not the best first case, due of a multitude of reasons. Nevertheless, together with you we want to solve a real problem. The design system will neither solely succeed due to its comprehensiveness, nor its technical depth in implementation. Together we find a use case where we can solve an existing problem without touching business-critical systems. This will foster engagement with the design system at an early stage and you might already be able to identify potential future advocates. A successful start also raises interest, but also questions and sometimes fears. Good thing is: it fosters communication. Which means that more and more people will be getting involved.", "tokens": 182}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "The kickstartDS check", "content": "Oftentimes a significant part of the identified components are already contained in our kickstartDS starter kit. Especially when the pilot project is content driven and no data rich power user interface. With everything learnt, we will check if kickstartDS would be a solid solution for you to kickstart your own design system. I will promise you, that we will be trustful and honest, and weâ€™ll not just try to sell ourselves as the one and only solutionâ€¦ even if it might not fit at all. If kickstartDS does not match your needs, we will recommend other solutions, or we can advise you further how to individually implement the components. But as everything done up to this point was completely independent of one specific way of implementing it, it will provide you with the right ammunition to tackle this challenge either way!", "tokens": 173}
{"title": "How our initiative workshop series helps customers to decide for or against building a design system", "heading": "Sorryâ€¦ that got deeper than I thought. So let me sum up:", "content": "The Design System Initiative helps you and your team to evaluate the key stakeholders and the necessary inventory, while ultimately, jointly, identifying a design system pilot. Please let me know what experiences you made when considering and initializing a design system from scratch. Or even after the first or second attempt failed. No worries, that happens to mostly every organization. Welcome to the club! ðŸ•º", "tokens": 91}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Create", "content": "TeaserCard component This guided example show how to find a fitting, existing kickstartDS base component for one of your use cases, to repurpose it. Meaning: you start with some requirements, match an existing component, find a fitting new name for the use case, and give it a new purpose by greatly restricting and rewiring its options for the new context. Even while using the component rather directly from kickstartDS, you'll want to find the correct set of properties for your own use case. Components in kickstartDS come equipped with properties for a wide range of possible use cases, so it makes sense to reduce those to the ones you really need... to make components easier to understand, use and reason about! We call this type of workflow Creation. Learn more about it in our dedicated guide about it. If you're unsure about something, have a look over there. We go into more background detail there about what we're doing here. Not touching the actual markup generated by components let's us get by without adding any custom styling ( CSS / SCSS) to it. We simply reuse the already existing Design Token and component structure.", "tokens": 236}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Overview", "content": "This is how the result of this guide will look like: It will only need three simple steps for that: - Component Definition, - Component Mapping, and - Component Creation For more details about those steps, have a look at the guide about different component processes and their shared structure.", "tokens": 60}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Purpose", "content": "We want to be able to flexibly tease content in a unified way. We think it should feel clean and modern, by looking like a card component. Otherwise, we'd just want to add the obvious things to such a card... headline, text, a link and optionally a cover image. It would also be important to us that the component supports being inverted, as that's a feature we've used in other parts of our Design System extensively (for example our Section). Components working together nicely, and sharing the same overarching concepts is a key tenant of using a Design System! We give our component the name TeaserCard.", "tokens": 129}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Structure", "content": "Defining the structure of a component means finding the component API for it: |Property||Type||Description| |Headline for the teaser card| |Body text for the teaser card| |(Optional) image to display as cover| |Show inverted version of card?| |Target that should be linked| Fields that should be required are marked with a *. While directly helping us get a better grasp on our new component, these will also be used to write our JSON Schema later!", "tokens": 102}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "2. Component Mapping", "content": "Next we want to search for components that could be of use in assembling this new one. This might be a single, big component that more or less directly fits our use case, or alternatively a combination of components that could serve as the basis by combining them. This will then serve as our kickstartDS base component, which will be adjusted to fit our needs!", "tokens": 77}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Matching it", "content": "From a quick glance, our TeaserBox component seems like it might fit the bill quite nicely! It has options for a headline ( topic), text ( text), inverted ( inverted) and image ( image), and we can simplify its link for our target. It's inverted feature is also based on the general kickstartDS component and Design Token functionality, fulfilling that requirement of ours: For a complete overview of the available options, take a look at the TeaserBox component API here: https://www.kickstartds.com/storybook/?path=/docs/base-teaser-box--linked-with-button", "tokens": 130}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Adjustments", "content": "This only gives us a rough sketch, though. We still need to adjust the example code to exactly fit our needs. In the process we will hard-code a bunch of options, because we're only interested in a specific set of them. The rest can be set to default values, which don't need to become part of the component API.", "tokens": 73}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Start with an existing", "content": "TeaserBox component variant We'll start by copying the JSX code for the Linked With Button variant of our TeaserBox component, from here: https://www.kickstartds.com/storybook/?path=/docs/base-teaser-box--linked-with-button _21", "tokens": 67}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Remove all of the unneeded stuff", "content": "There are a bunch of properties that are completely optional in the copied JSX, or ones which just state the default value of that property anyway. Those can be freely removed. In the case of our TeaserCard, we drop ratio and some of the link options! _9", "tokens": 64}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Add some demo content", "content": "Now we just need to enter some \"real\" content, and we've successfully recreated what we set out to do in the start. At least for the markup part! _9", "tokens": 42}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "3. Component Creation", "content": "We like to colocate components. This means to have all involved files next to each other in the same folder; the template ( .jsx / .tsx), potential CSS / SASS ( .css / .scss), JavaScript ( .js / .ts), our JSON Schema component definition ( .schema.json), and so on. So we start by creating the directory src/components/teaser-card, from our Design System repository root: _1mkdir -p src/components/teaser-card This is the folder we'll add new files to in the coming few paragraphs. JSON Schema definition First file we'll create is the JSON Schema definition, encoding the structure we've defined for our component before:", "tokens": 158}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Add basic info describing component", "content": "We start by adding a title, description and $id attribute. The correct $id depends on your Design System configuration. We'll assume you've created components before, living under the schema prefix http://schema.mydesignsystem.com. ", "tokens": 56}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Finished", "content": "JSON Schema Let's have a look at our completed JSON Schema definition. This concludes creating the JSON Schema. When running the schema generation in our Design System again, we should now automatically end up with a corresponding type definition to be used in creation of the template in the next step: How your schema generation is started might change depending on your setup. If you've followed our \"Create your Design System\" guide before, or want to add it like we do, follow this section of it closely. React template As the final step for this example, we'll add the template. This will be a purely functional React component, mapping our component structure (as defined in the JSON Schema) to the original component we're basing our work off of; the kickstartDS Storytelling component.", "tokens": 164}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Start with a boilerplate", "content": "Again we'll start with a very basic skeleton for our React component. We're using TypeScript here ( .tsx), but it works the same with plain JSX ( .jsx).", "tokens": 44}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Add correct typings", "content": "correct typings Import and add generated props from TeaserCardProps.ts. Generated by our JSON Schema, these guarantee you're matching your expected component structure while implementing. In combination with TypeScript this enables auto-complete and auto-fix for even better DX! (see here, at the very end of that section, for more details) We also add HTMLAttributes to the type signature for the props that we'll pass through to the native HTML element underneath.", "tokens": 100}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Add", "content": "TeaserCard component 1/5 Now we'll import and add the kickstartDS TeaserBox component. To start, we'll use the hard-coded properties of the Linked With Button TeaserBox variant from our kickstartDS Design System.", "tokens": 54}
{"title": "Create `TeaserCard` component | kickstartDS docs", "heading": "Storybook setup", "content": "This guide assumes you're using a set up like described in our Create your Design System guide! Be sure to adapt commands and configuration to your use accordingly, when following this part! Add the following file to your src/components/teaser-card folder:", "tokens": 56}
{"title": "Upgrading | kickstartDS docs", "heading": "Upgrading", "content": "We generally try to avoid Breaking Changes, and thus the need for explicit migration. We've tried very hard to find abstractions for the core of kickstartDS that enable exactly those easy, forward-compatible changes. But as with all software that's meant to last, some more heavy changes will eventually be needed, for example to accomodate changing needs or standards. In that case we will have a dedicated migration guide ready for that Breaking Change in version. Additionall we'll support upgrades / migrations through our kickstartDS CLI, as much as possible!", "tokens": 118}
{"title": "Upgrading | kickstartDS docs", "heading": "Some background information", "content": "To give some general context to versioning and releases with kickstartDS, you might read through the following paragraphs to gain a deeper understanding. Those cover some specifics (like changelog generation), but with a focus on the details pertaining to migration of code, and navigation of complementary information.", "tokens": 62}
{"title": "Upgrading | kickstartDS docs", "heading": "Semantic versioning with Auto", "content": "Versioning is done semantically, closely following SemVer. So Breaking Changes will be expressed in the initial number of the version (we're currently on 2.x) To further improve ease of use, and add consistency through good defaults, we use Auto to generate releases based on semantic version labels on pull requests on our Github repository. Learn more about this in our Contribution-Guide, detailling this process of Github Discussions, Issues, Pull Requests, Canaries and releases.", "tokens": 105}
{"title": "Upgrading | kickstartDS docs", "heading": "Automatic Changelog generation", "content": "Changelogs are generated on a per module basis (current modules include: core, base, blog, form, content). Each module has its own CHANGELOG.md in its package root. For example, see the CHANGELOG.md for the core module on our Github repository: https://github.com/kickstartDS/kickstartDS/blob/master/packages/components/core/CHANGELOG.md Formatting of commits follows Conventional Commits, enabling structured grouping by change type in generated CHANGELOG.md files, and consistent entry of commit info through CLI hooks and linting integration: https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional", "tokens": 171}
{"title": "Upgrading | kickstartDS docs", "heading": "Github and npm releases", "content": "Additionally you can explore all releases through either our Github releases page, or by viewing all packages and release channels on npm. This can give you a quick overview over current stable releases, upcoming feature-related releases, or even cutting edge work on future versions to test out early. Lastly you'll find Canary releases, used to enable early testing of bugfix changes or new features, in an isolated fashion. Canary releases get generated for every branch of our Github repository automatically. They get applied the same build processes like the stable master branch, or the next branch with upcoming features, enabling visual regression testing and the aforementioned automatic releases for local reproducability. As work on bugs and features always occurs on branches, this enables continous quality control from the start. To learn about our packages in more detail, have a look at the Packages page.", "tokens": 173}
{"title": "Roadmap | kickstartDS docs", "heading": "Roadmap", "content": "As we just released kickstartDS with the first version of this documentation, we know, that we still have to work on many details to let our documentation shine. As we want to explain the underlaying concepts in-depth. The roadmap shall provide an overview of the versions to inform you on what we are working on or what is in the pipe for future releases. If you are missing something, ping us at hello@kickstartds.com or text us on Discord.", "tokens": 100}
{"title": "Roadmap | kickstartDS docs", "heading": "Community", "content": "We try to have a healthy, friendly and active community. As we believe in the great openness of the Design System community. We rely on your feedback by adapting to your needs, so that kickstartDS will really become the Design System starter, digital teams and the community like to work with. Although it's still quite small, this also enables us to respond to requests in a very hands-on fashion. Feel free to join us on Discord! If that's not your cup of tea, you can also reach out to us: - Through the chat widget, included in all of our public facing websites - By writing us an email - By joining us on Twitter - By writing us on WhatsApp", "tokens": 142}
{"title": "Upgrade to 2.0.0 | kickstartDS docs", "heading": "Usage of", "content": "breakpoints helper for layouts Remove the current @use from your SASS: _7@use '@kickstartds/core/source/core/breakpoint';_7_7.content {_7@include breakpoint.media('>xl') {_7--ks-spacing-xl: 8em;_7}_7} Replace it with a standard media query for this: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries Like this: _5@media (min-width: 75em) {_5.content {_5--ks-spacing-xl: 8em;_5}_5} Where xl in our case equates to 75em. You can use the CSS Properties generated for you, to help still writing maintainable media queries. For example: _1--ks-breakpoints: '{\"phone\":\"36em\",\"tablet\":\"48em\",\"laptop\":\"62em\",\"desktop\":\"75em\"}';", "tokens": 227}
{"title": "Design Token | kickstartDS docs", "heading": "Design Token", "content": "Design Token are the smallest building blocks, the core pieces of a design system. Design Token in kickstartDS are stored in a JSON format and can be transformed to be used on any platform.", "tokens": 42}
{"title": "Design Token | kickstartDS docs", "heading": "Core Token", "content": "_8\"color\": {_8\"primary\": \"#05566a\",_8\"primary-inverted\": \"#ecff00\",_8\"background\": \"#fff\",_8\"foreground\": \"#050505\",_8\"link\": \"#5D5DD5\",_8\"link-inverted\": \"#C6C6FF\"_8}, Explore all color Token", "tokens": 84}
{"title": "Design Token | kickstartDS docs", "heading": "Semantic Token", "content": "Semantic Token reference core Token and suggest an intended use for it. Because of this their names should never reference the value but only what the Token is intended for. They have a high level of abstraction. A typical name could be color-background or shadow-floating-hovered. The kickstartDS Token taxonomy relies on the article Naming Token in Design Systems by Nathan Curtis, who really is the number one mate in the design systems space. Thank you for sharing you passion and knowledge, this is really empowering the DS community ðŸ™", "tokens": 114}
{"title": "React | kickstartDS docs", "heading": "React", "content": "React as our templating language of choice offers great integration capabilities, and we've built some on top of those... to help you even more when creating your own components. React as our templating language of choice offers great integration capabilities, and we've built some on top of those... to help you even more when creating your own components.", "tokens": 74}
{"title": "Welcome to the kickstartDS docs | kickstartDS docs", "heading": "Sitemap", "content": "Quick access to all pages of our main docs sections: Getting Started Section overview:Open Getting Started section Guides Section overview: - Guides - Create your Design System - Components - Examples - Migrations - Using our Starter - Design System Initiative Concepts Section overview:Open Concepts section", "tokens": 57}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "About", "content": "The kickstartDS Design System Starter is your most efficient way of kickstarting a Design System. It creates a ready-to-use Design System, only waiting for you to put your stamp on it! Next to some additional features and configuration, the content of this starter is strongly aligned with our main guide \"Create your Design System\". This means you can use that guide as a detailed reference for the way stuff works, and learn about the reasoning behind those decisions.", "tokens": 96}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Overview", "content": "This Starter repository can serve as the starting point for your own Design System. It only includes minimal, but illustrative, example components and integrations. The selected components should be useful in every Design System by themselves, but they're specifically used to showcase features and best practices at play in kickstartDS, and to make it easier for you to just add stuff to an already working, well-oiled system. We have extensive documentation building up most of the code you'll find in this starter from scratch. The respective guide \"Create your Design System\" can thus serve as a great reference whilst exploring this starter on your own, or when having specific questions about a feature or integration.", "tokens": 140}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Feature list", "content": "The following is a list of included features, that are pre-configured for immediate use: - Ready-to-start, fully functional Design System - Pre-configured semantic token structure ( Branding Token, Design Tokenand Component Token) Branding Tokenfile for quick application of CI / CD - Three exemplary components ( Button, Headlineand TeaserCard) and a layout element ( Section) - Full page demo, recipe demo and rudimentary demo docs Storybookwith best-practice configuration, kickstartDSintegration, addons and composition Hot reloadfor allcode changes: Design Tokenset, JSON Schema, CSS/ SCSS, JavaScriptand Reacttemplates Playroomintegration for prototyping - Bundling of Design Systemfor use with andwithout React - Automatic, semantic release handling using auto - CI / CD integration for Circle CI See the dedicated section about the main features below for more detailed descriptions.", "tokens": 187}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Installation", "content": "There's not really anything you need to install globally to use kickstartDS. But as it is Node.js based, you'll have to have that at the ready. This starter (just like the rest of kickstartDS) tracks the current LTS release, switching to new ones as soon as all the tooling has stabilized.", "tokens": 71}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Install Node.js with nvm", "content": "We recommend managing your local Node.js versions using nvm. Read through the corresponding section in our docs. To learn more generally about the optimal environment to work with kickstartDS have a look at the Environment page in our docs.", "tokens": 54}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "1. Create from template", "content": "First thing is creating your repository based on this template. This will be the repository you manage your Design System in, your central source of truth! Just follow this excellent guide by Github themselves: Creating a repository from a template Alternatively you can also just fork / clone the repository, and host your code how- and wherever you like. There's no further dependency on Github here... it's just convenient. As a last step, simply clone your freshly made repository, and switch into its directory in preparation for the next step.", "tokens": 109}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "2. Update", "content": "package.json After checkout, you should start by adding some meta info to package.json... like name for the name of your project. Among other things, this will also decide the name your Design System will be published under in npm. Other fields you might want to change include: version, description, homepage, license and author. Have a look at the npm docs for package.json for all the juicy details. And while at it, you should probably also change the author in the following files: COPYRIGHT.md LICENSE-APACHE LICENSE-MIT README.md .autorc", "tokens": 126}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "3. Add your own logo", "content": "Last thing to do before installing and starting everything is to replace the placeholder logo with your own one. Just replace static/logo.svg, and you should be good to go!", "tokens": 44}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Other image formats", "content": "If you don't have a .svg file for your logo (you really should have one!), you can just put that file into the static/ folder, and change the reference in .storybook/themes.js to point to that instead.", "tokens": 55}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "4. Install dependencies", "content": "Continue by checking your Node.js version (or execute nvm use if you opted for the nvm route) with node --version. It should output 16.14 for this starter. Follow this with a yarn or npm install: _1yarn install _1npm install This should set up all the needed dependencies. It could take a while the first time around, so while that's running... why not take a peek at the features section?", "tokens": 96}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "5. Start", "content": "Storybook When the installation of dependencies is done, everything should be ready to start your own Design System for the very first time: _1yarn start Storybook should automatically open in your preferred browser, showing you a demo \"Welcome\" page with some dummy content. yarn start here is actually an alias starting all configured watch tasks, in parallel to also starting Storybook in watch mode. This ensures that whatever file you edit, you should have hot reload while working on your code! Have a look at the next section for inspiration on what the next steps could look like on the journey to your customized Design System.", "tokens": 126}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Next steps", "content": "Where you take it next is pretty much up to you completely. There are some things one would pretty much always want to do (e.g. Customizing Design Token), while others might be optional. In which order you tackle those shouldn't make a difference, just choose what fancies you the most!", "tokens": 65}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Customizing", "content": "Design Token When getting started with your Design System, you will find the current Design Token set to be pretty bland and boring... this is because you are looking at the default, pretty much unstyled versions of components. There are two concepts involved with design and token application in kickstartDS: Branding Token: Small set of expressive values to seed your initial Design Tokenset Design Token: Managed Style Dictionarycontaining your semantic Design Tokenset Branding Token are set in src/token/branding-token.json, while your Design Token set lives at src/token/dictionary. Initialization of token happens through yarn init-tokens, while compiling your Design Token set to Component Token (among other formats) is done by running yarn build-tokens. Component Token are the third type of token involved, but those only come into play later. They are not concerned with the general styling / theming of your Design System, but rather map your Design Token set to components in a layered way. To learn more about this process, follow the section \"2. Design Application\" of our \"Create your Design System\" guide.", "tokens": 234}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Adding components", "content": "As described in the intro to this README, the components already included serve as a great example on how to leverage kickstartDS. But obviously you will want to add your own components, suited to exactly your needs! We have to tried to outline this process of component creation, and all its aspects, in our documentation. All the components included with this starter get created in part of \"4. Add Components\" of our main guide \"Create your Design System\". You can use that guide to cross-reference the thought process behind the components already included, and it should give you a good idea on how to approach your own ones. You can have a look at all the component examples in our guides here, or learn about the involved processes in more detail in the \"Components\" subsection. Futher, all the aspects making up a component are described as part of the \"Component\" subsection under \"Foundations\". If unsure on what components you actually need, or which ones to tackle first, you could investigate starting your own Design System Initiative. We also wrote about it in a blog post, and offer support in executing one... if you still feel like you need a helping hand!", "tokens": 241}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Dig into our docs", "content": "We have added a lot of links to specific docs sections in all the other paragraphs already. But they deserve a special mention here. Creating a Design System can be both highly custom and opinionated. This is why we think explaining our reasoning in detail, especially when we take decisions for you (like using Style Dictionary), is super important. And for areas where there is no clear cut decision to take, we always try to add recommendations (like how to best construct your components to avoid adding technical debt) instead. Some quick links to get you started: |Link||Description| |https://www.kickstartds.com/docs/||Start page, good intro to the general structure of our docs| |https://www.kickstartds.com/docs/intro/||Super general introduction of |kickstartDS, including YouTube explanation |https://www.kickstartds.com/docs/foundations/||Foundational info about the structure and architecture of |kickstartDS |https://www.kickstartds.com/docs/integration/||Info about the ways |kickstartDS integrates with other tooling and systems |https://www.kickstartds.com/docs/guides/||Focused guides, categorized into the main areas of a |Design System |https://www.kickstartds.com/docs/guides/create/||Main guide, also a great reference for the reasoning behind this starter| |https://www.kickstartds.com/docs/feedback/||All the ways you can provide feedback to us, which we value a lot!|", "tokens": 336}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Features", "content": "This starter is already quite rich in features that are enabled out-of-the-box for you.. To give you some orientation, while also describing the intention behind features, and ensuring you can actually make the most out of your Design System.. Design Token integration One important part of a Design System is having a well structured and semantic token system in place.. Learn about customizing your Design Token set in our dedicated section above, helping you to adapt your own branding / CI / CD.. Design Token can be initialized by changing the values in src/token/branding-token.json and calling yarn init-tokens, and compiled to CSS Custom Properties by running yarn build-tokens.. While yarn init-tokens generates your Design Token set in src/token/dictionary, yarn build-tokens reads it from there, and outputs the resulting formats (which CSS Custom Properties is just one of) according to your Style Dictionary config.. We already include a minimal Style Dictionary configuration as part of our CLI, but you can overwrite this configuration by adding a sd.config.cjs to your repository root.. Explore that file for details on the formats configured in this starter (the path the format output is written to can be influenced by setting buildPath): |Platform||Description| css |Creates a |Design Token converted to CSS Custom Properties, using the naming structure expected by Component Token in html HTML icon sprite (learn more), that is needed when integrating raw HTML (e.g.. into PHP, ASP.NET, or similar).. Also serves as the central icon file read by the storybook-design-token addon.. Added as jsx React version of the same file as the one above, this should be used when working with React directly.. Called storybook |Writes a selection of files (|storybook-design-token addon js |This also creates a file (|Storybook, to add some light theming to your instance based on your Design Token set.. Also included is a set of Storybook pages documenting your Design Token set, using aforementioned storybook-design-token addon.. You can find them in docs/tokens, feel free to adjust them to your liking!. You can also have a look at our Figma token file visualizing exactly that token structure: To learn more about Design Token and their support in kickstartDS read our first release spotlight: Release Spotlight: Semantic Token.. Storybook integration Some aspects of our integration with Storybook were already covered by the last section about Design Token integration..", "tokens": 520}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "When you need Providers", "content": "When you're building a page or application using React, you will need to add those Providers to your central layout there! Bedrock Layout Primitives integration For the most common use cases we include the Section component with kickstartDS, and it's adapted for this Design System starter, too. It even includes some customizations here, as described in our component example guide \"Extend Section component`. The Section component is especially well suited for marketing and landing pages. It provdides general layout options (\"horizontal slices\" on a page) for components to be put in. You can see all available options here: Storybook Docs for Section. We also cover the Section, and some example uses, in more detail in our \"Layout\" section of the docs. When you have more general layout needs, not covered by simply using a Section component, we usually recommend using Bedrock Layout Primitives for those cases. We think it meshes really well with our approach to Design Token, you simply connect your existing Design Token set to their theming approach. We already provide such an integration with this starter. You can read about this combination in more detail on our \"Foundations\" page about Bedrock Layout Primitives. To learn more about Bedrock Layout Primitves and why, when and how to use it with kickstartDS, and when Container Queries might actually be preferrable, you can also read our second release spotlight: Release Spotlight: Container Queries. Playroom integration We're big proponents of prototyping interface as close to your real Design System as possible. For developers, and even code-affine designers, we really love the DX Playroom by seek-oss offers for this. This is why we've included a Playroom integration with this starter (and because it's actually really easy to do with the way kickstartDS is set up) at playroom.config.js. There's some configuration in Storybooks .storybook/preview.js, and all components that should be enabled need to be added in src/playroom/components.ts. We also added Bedrock Layout Primitives support out-of-the-box, there. To change the included Snippets edit src/playroom/snippets.ts, and to change the theme integration (or even to add multiple themes / white-label testing capabilities to it) have a look at src/playroom/FrameComponent.tsx and the folder src/playroom/themes. Finally, TypeScript support for all your (and our kickstartDS base) components is also already configured. This enables auto-complete for all components, making it really easy and playful to discover components and their properties! Start your Playroom: _1yarn playroom", "tokens": 568}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Combined use with Storybook", "content": "You can even use Playroom in your Storybook as an addon, just be sure start Playroom before starting Storybook. Because you guessed it: it's already set up!", "tokens": 41}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Bundling", "content": "With this starter we want to cover the complete life-cycle of a Design System. This includes Bundling and Release handling. We also want to show what we mean when we say kickstartDS is framework-agnostic. Because you can either use a Design System based on kickstartDS by working with React templates directly, or by alternatively using CSS and JavaScript bundles to be used with the raw markup generated by components... both cases are covered in this starter. It's also quite common for both types of usage to coexist for your Design System. Your main marketing page might be built with a headless CMS and a modern stack using React, while some arcane internal tooling might still use PHP for its templating. This setup enables you to serve both! All bundling is handled by the dist:* tasks in package.json. ", "tokens": 173}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Bundling for", "content": "for HTML usage CSS bundling with Dart Sass is done by the dist:sass script in package.json. Just be sure to add all needed component CSS to src/dist.scss, the compiled output will live at dist/index.css. JavaScript bundling with esbuild is done by the dist:js script in package.json. As with CSS, be sure to add all needed component JavaScript to src/dist.js, the compiled output will live at dist/index.js. Next to all that configuration, as a start the included \"Integration\" Story describes this process to potential developers using your Design System this way. ", "tokens": 135}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Release handling", "content": "Release handling for this starter is configured to use auto, and its semantic versioning. We use this setup for kickstartDS itself, you can learn more about it in our documentation. Configuration is added in .autorc, and if you want to enable releases as part of your CI / CD... you can use Circle CI with the included configuration file at .circleci/config.yml. We will probably expand on this section, when we have a better picture of everyones setup and needs!", "tokens": 104}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Visual Regression Testing with Chromatic", "content": "One of the relatively undocumented features is Visual Regression Testing with Chromatic. This is prepared to be usable with yarn chromatic (also compatible with CI / CD) in package.json.", "tokens": 45}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Components", "content": "As described in the very intro to this README, all the included components should be immediately useful in pretty much every Design System, but they're also specifically used to showcase features and best practices at play in kickstartDS, and to make it easier for you to just add stuff to an already working, well-oiled system:", "tokens": 70}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Recipes", "content": "We added one recipe to give you an idea on how you could use those. We've added an ArticleTeaser recipe, as one entry in the more general Article recipe category. Recipes are useful to show how your existing components can be re-used, re-mixed and re-applied to new use cases, avoiding the creation of many specialized components. They serve as great inspiration for consumers of your Design System, while also slightly nudging in a certain direction by the examples you decide to showcase!", "tokens": 105}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Pages", "content": "There is one Page currently included with this starter in src/pages/Demo.story.jsx, added to Storybook by src/pages/Pages.stories.jsx.", "tokens": 41}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Docs", "content": "There are two docs pages (the Welcome page and the Integration page), and documentation for all token from your Design Token set, included with this starter. Feel free to add further docs pages to your Design System in docs/.", "tokens": 47}
{"title": "kickstartDS Design System Starter | kickstartDS docs", "heading": "Scripts", "content": "Short descriptions for all of the scripts entries in package.json: |Script||Link||Description| |Features > |Storybook integration |Compile |Design Token set first, run |Features > |Design Token integration |Compile |Design Token set according to |Features > Release handling||Run |Visual Regression Tests with Chromatic |Features > Bundling > Bundling for |React usage |Build all the components for |React usage |Features > Bundling||Copy | |Features > Bundling > Bundling for |React usage |Copy | |Features > Bundling||Copy | |Features > Bundling||copy | |Features > Bundling > Bundling for |HTML usage |Build |CSS using Dart Sass |Features > Bundling||Process |JSON Schema files, copy result to TypeScript types |Features > Bundling||Build component |JavaScript using esbuild |Next steps > Customizing |Design Token |Initialize |Design Token set using |Features > |Playroom integration |Start all watch tasks before starting |Playroom |Features > |Playroom integration |Starts |Playroom in watch mode |Features > |Playroom integration |Builds |Playroom for deployment |Features > Release handling||Runs before publishing a release, resets |Design Token set and then runs all |Features > |Storybook integration |Compile |CSS for use in Storybook (when not bundled for distribution) |Features > |Storybook integration |Compile |CSS for Storybooks manager, enables the light theming capabilities added |Features > |Storybook integration |Run all the | |Features > |Storybook integration |Dereference |JSON Schema, to inline all references ( Storybook Controls) easier |Features > |Storybook integration |Generate |TypeScript types based on your component API |Getting started (in 5 minutes)||Start everything in watch mode, and then start |Storybook in watch mode, too |Getting started (in 5 minutes)||Alias for default |Storybook start script |Features > |Design Token integration |Extracts |Component Token from component CSS / SCSS, so they can be displayed in our addon |Features > |Storybook integration |Compile |CSS for use in Storybook in watch mode |Features > |Storybook integration |Compile |CSS for Storybooks manager in watch mode |Features > |Storybook integration |Run all the schema scripts in parallel, when a |JSON Schema changes |Features > |Design Token integration |Compile |Design Token set and extract Component Token when a tokens CSS / SCSS file changes |Features > |Design Token integration |Compile |Design Token set when a Style Dictionary file changes", "tokens": 560}
{"title": "Quarterly Design System and Frontend Podcast Roundup â€“ Q1/22", "heading": "Summary", "content": "#tldr Read our roundup of podcasts released in the first quarter of 2022. Everything related to Design Systems, Frontend development and headless CMS / Jamstack.\nIâ€™m listening to quite a collection of podcasts regularly, as I just love to learn about new stuffâ€¦ and what others are building. And sometime at the end of last year I decided to favorite all those episodes that were really interesting to me. So this will be the obvious bias hereâ€¦ ðŸ˜…\nBut maybe this turns out to be useful for others, let me know!\n**Podcast themes include:** Design Systems, Frontend, UI, React, headless CMS, Jamstack\nAnd Iâ€™ve added everything I starred in April so far, tooâ€¦ for good measure ðŸ˜‰", "tokens": 163}
{"title": "Quarterly Design System and Frontend Podcast Roundup â€“ Q1/22", "heading": "Podcasts featured:", "content": "PodRocket:https://podrocket.logrocket.com/ (12 episodes) JS Party:https://changelog.com/jsparty (5 episodes) devtools.fm:https://devtools.fm/ (3 episodes) JavaScript Jabber:https://javascriptjabber.com/ (3 episodes) Thatâ€™s my JAMstack:https://thatsmyjamstack.com/ (3 episodes) JAMstack Radio:https://www.heavybit.com/library/podcasts/jamstack-radio/ (2 episodes) Front End Happy Hour:https://www.frontendhappyhour.com/ (2 episodes) Console DevTools Podcast:https://console.dev/podcast/ (2 episodes) This also means (at least for me) that PodRocket takes the crown for most listened podcast of the quarterâ€¦ and by quite the margin, too! ðŸš€ On to the monthly overview:", "tokens": 198}
{"title": "Quarterly Design System and Frontend Podcast Roundup â€“ Q1/22", "heading": "April", "content": "April 15th, 2022 PodRocket: â€œRemix with Chance Stricklandâ€ Hosts: Kate Trahan, Kaelan Cooter Guest: Chance Strickland Length: 26m 8s Link: https://podrocket.logrocket.com/remix April 14th, 2022 devtools.fm: Episode #28 â€œSteve Sewell â€“ Builder.io, partytown, Qwik, mitosisâ€ Hosts: Andrew Lisowski, Justin Bennett Guest: Steve Sewell Length: 01h 06m Link: https://devtools.fm/episode/28 April 14th, 2022 JAMstack Radio: Ep. 99 â€œHeadless Commerce Engine with Sebastian Rindom and Nicklas Gellner of Medusaâ€ Host: Brian Douglas Guests: Sebastian Rindom, Nicklas Gellner Length: 28m 01s Link: https://www.heavybit.com/library/podcasts/jamstack-radio/ep-99-headless-commerce-engine-with-sebastian-rindom-and-nicklas-gellner-of-medusa/ April 8th, 2022 Front End Happy Hour: Episode 147 â€œDebugging Asynchronous JavaScript â€“ Awaiting My Drinkâ€ Hosts: Ryan Burgess, Jem Young Guest: Jenn Creighton Length: 44m 56s Link: https://www.frontendhappyhour.com/episodes/debugging-asynchronous-javascript-awaiting-my-drink/ April 6th, 2022 PodRocket: â€œStorybook with Chantasticâ€ Hosts: Kate Trahan, Noel Minchow Guest: Chantastic Length: 51m 59s Link: https://podrocket.logrocket.com/storybook April 5th, 2022 PodRocket: â€œKendoReact with Kathryn Grayson Nanzâ€ Hosts: Kate Trahan, Noel Minchow Guests: Kathryn Grayson Nanz Length: 42m 39s Link: https://podrocket.logrocket.com/kendoreact April 1st, 2022 PodRocket: â€œAgnosticUI with Rob Levinâ€ Host: Paul Mikulskis Guest: Rob Levin Length: 30m 12s Link: https://podrocket.logrocket.com/agnosticui", "tokens": 482}
{"title": "Quarterly Design System and Frontend Podcast Roundup â€“ Q1/22", "heading": "March", "content": "March 29th, 2022 PodRocket: â€œSPAs, island architecture, and the future of development with Ryan Carniato and Dylan Pierceyâ€ Hosts: Kate Trahan, Noel Minchow Guests: Ryan Carniato, Dylan Piercey Length: 51m 00s Link: https://podrocket.logrocket.com/island-architecture March 29th, 2022 JavaScript Jabber: React Component and State Management â€“ JSJ 526 Hosts: AJ Oâ€™Neal, Charles Wood, Dan Shappir Length: 01h 8m Link: https://javascriptjabber.com/react-component-and-state-management-jsj-526 March 18th, 2022 JS Party: Episode #217 Going full-time on Eleventy Hosts: Jerod Santo, Nick Nisi Guest: Zach Leatherman Length: 58m 00s Link: https://changelog.com/jsparty/217 March 18th, 2022 PodRocket: Polaris: The Shopify design system with Alex Page and Yuraima Estevez Hosts: Kate Trahan, Noel Minchow Guests: Alex Page, Yuraima Estevez Length: 50m 51s Link: https://podrocket.logrocket.com/shopify March 16th, 2022 PodRocket: Final Form with Erik Rasmussen Hosts: Kate Trahan, Paul Mikulskis Guest: Erik Rasmussen Length: 41m 32s Link: https://podrocket.logrocket.com/final-form March 11th, 2022 PodRocket: Accessibility with Ben Myers Host: Kate Trahan, Brendan Downing Guest: Ben Myers Length: 39m 20s Link: https://podrocket.logrocket.com/accessibility March 8th, 2022 PodRocket: Composing layouts with Travis Waith-Mair Hosts: Kate Trahan, Noel Minchow Guest: Travis Waith-Mair Length: 40m 35s Link: https://podrocket.logrocket.com/composing-layouts March 4th, 2022 JS Party: Episode #215 Remix helps bridge the network chasm Hosts: Kevin Ball, Ali Spittel, Divya Guest: Kent C. Dodds Length: 01h 13m Link: https://changelog.com/jsparty/215 March 4th, 2022 devtools.fm: Episode #25 Anthony Fu â€“ Vue, Vite, Vitest, UnoCSS Hosts: Andrew Lisowski, Justin Bennett Guest: Anthony Fu Length: 52m 30s Link: https://devtools.fm/episode/25 March 3rd, 2022 Console DevTools Podcast: Designing dev products Host: David Mytton Guest: Ellen Chisa Length: 32m 45s Link: https://console.dev/podcast/s02e09-designing-dev-products-ellen-chisa-boldstart/", "tokens": 604}
{"title": "Quarterly Design System and Frontend Podcast Roundup â€“ Q1/22", "heading": "February", "content": "February 25th, 2022 JS Party: Episode #214 Vitest && Slidev Hosts: Jerod Santo, Nick Nisi Guests: Anthony Fu, Patak Length: 55m 00s Link: https://changelog.com/jsparty/214 February 23rd, 2022 PodRocket: Slinkity with Ben Holmes Hosts: Kate Trahan, Paul Mikulskis Guests: Ben Holmes Length: 32m 59s Link: https://podrocket.logrocket.com/slinkity February 11th, 2022 JS Party: Episode #212 A deep-dive on Vite Hosts: Amal Hussein, Nick Nisi Guest: Evan You Length: 01h 14m Link: https://changelog.com/jsparty/212 February 9th, 2022 Thatâ€™s my JAMstack: REMIX! Tamas Piros on islands architecture, Astro and media usage Host: Bryan Robinson Guest: Tamas Piros Length: 28m 52s Link: https://thatsmyjamstack.com/episodes/tamas-piros-remix/ February 9th, 2022 PodRocket: Modern React with Paige Niedringhaus Host: Kate Trahan, Noel Minchow Guest: Paige Niedringhaus Length: 50m 00s Link: https://podrocket.logrocket.com/modern-react February 6th, 2022 Front End Happy Hour: TypeScript migration â€“ Strict type of cocktails Host: Ryan Burgess Guests: Sumana Mohan, Joe King Length: 48m 22s Link: https://www.frontendhappyhour.com/episodes/typescript-migration-strict-type-of-cocktails/ February 4th, 2022 JS Party: Episode #211 A Solid option for building UIs Hosts: Ryan Burgess, Jem Young, Stacy London Guests: Sumana Mohan, Joe King Length: 55m 00s Link: https://changelog.com/jsparty/211 February 3rd, 2022 Console DevTools Podcast: Devtools investing Host: David Mytton Guest: Ed Sim Length: 30m 38s Link: https://console.dev/podcast/s02e05-devtools-investing-ed-sim-boldstart/", "tokens": 473}
{"title": "Quarterly Design System and Frontend Podcast Roundup â€“ Q1/22", "heading": "January", "content": "January 27th, 2022 JAMstack Radio: Ep. #95, Islands Architecture with Ben Holmes of Slinkity Host: Brian Douglas Guest: Ben Holmes Length: 27m 58s Link: https://www.heavybit.com/library/podcasts/jamstack-radio/ep-95-islands-architecture-with-ben-holmes-of-slinkity/ January 26th, 2022 PodRocket: MUI with Olivier Tassinari Host: Ben Edelstein Guest: Olivier Tassinari Length: 31m 43s Link: https://podrocket.logrocket.com/mui January 25th, 2022 JavaScript Jabber: Virtual DOM and the React Way, Part Deux â€“ JSJ 518 Hosts: Aimee Knight, AJ Oâ€™Neal, Dan Shappir, Steve Edwards Length: 01h 32m Link: https://javascriptjabber.com/virtual-dom-and-the-react-way-part-deux-jsj-518 January 21st, 2022 devtools.fm: Yang Zhang â€“ Plasmic Hosts: Andrew Lisowski, Justin Bennett Guest: Yang Zhang Length: 57m 04s Link: https://devtools.fm/episode/22 January 18th, 2022 JavaScript Jabber: Can JAMstack do REAL Web Apps? with James Q Quick â€“ JSJ 517 Host: AJ Oâ€™Neal, Charles Wood, Steve Edwards Guest: James Q Quick Length: 01h 20m Link: https://javascriptjabber.com/can-jamstack-do-real-web-apps-jsj-517 January 12th, 2022 Thatâ€™s my JAMstack: Raymond Camden (REMIX) on the amazing expansion of the Jamstack ecosystem and how far weâ€™ve come Host: Bryan Robinson Guest: Raymond Camden Length: 27m 31s Link: https://thatsmyjamstack.com/episodes/raymond-camden-remix/ January 04th Thatâ€™s my JAMstack: Salma Alam-Naylor on shipping, learning, and rendering in the Jamstack Host: Bryan Robinson Guest: Salma Alam-Naylor Length: 27m 59s Link: https://thatsmyjamstack.com/episodes/salma-alam-naylor/ And if youâ€™re missing one from the list, one youâ€™ve enjoyed a lot, let me know on Twitter! Always happy to add another one to my subscriptions ðŸ™‚", "tokens": 523}
{"title": "Component Modules | kickstartDS docs", "heading": "Component Modules", "content": "kickstartDS comes with different component modules which are all built on top of each other. Experience all modules and its compontents with all their properties and possibities in our Storybook.", "tokens": 42}
{"title": "Component Modules | kickstartDS docs", "heading": "Core Module", "content": "Open Source The Core Module is principally the base layer of any kickstartDS instance. It contains no components which you can grab and use further it is rather the foundation for every layout by beholding a Container Component, at least that s what we call it. Its speciality is the usage of container queries. If you want to learn more about this, take a deeper look into the according information at mozilla.org: CSS Container Queries", "tokens": 92}
{"title": "Component Modules | kickstartDS docs", "heading": "Base Module", "content": "Open Source The kickstartDS Base Module is our comprehensive component library enabling development teams to create consistent and brand compliant web frontends super efficiently. It contains a solid set of default components being the building blocks to create your Design System from the scratch, code first!", "tokens": 55}
{"title": "Component Modules | kickstartDS docs", "heading": "Blog Module", "content": "Open Source A Design System is nothing without a system applying it. That's why we created a simple set of components to empower you creating a blog to bring kickstartDS into action. The Blog Module contains five rich components, Check 'em in the Storybook. Content Module Closed As the perfect addition to our Open Source Base, we offer a closed Content Module. In almost every project teams need to structur and layout content. Be it your next landing or marking page, your main website, a CMS-project or whenever content is key. The Content Module includes seven rich components: like the famous hero visual, Components for quotes, contact-cards, storytelling etc. â€” everything you need to build beautiful content experiences following your very indivisual design decisions. The components from the content Module are ready-made, with well-curated options and connected to the underlaying design and component tokens. You can get a glimpse of what is meant by checking this blog post.", "tokens": 200}
{"title": "Component Modules | kickstartDS docs", "heading": "kickstartDS Content Module", "content": "The perfect addition to our Open Source base The Content Module includes seven rich components: Hero visual, Quote, Storytelling etc. â€” everything you need to build beautiful content experiences or to enrich your existing Design System", "tokens": 45}
{"title": "Component Modules | kickstartDS docs", "heading": "Do you miss something?", "content": "We are working on further modules. And you can too! Join our community and let us know which components you miss. Or share the phantastical things you have built based on kickstartDS.", "tokens": 45}
{"title": "Guides | kickstartDS docs", "heading": "Guides", "content": "Guides provide instructions on how to get the most out of kickstartDS to create your own Design System. Let us know which guide you are actually missing. Guides provide instructions on how to get the most out of kickstartDS to create your own Design System. Let us know which guide you are actually missing.", "tokens": 66}
{"title": "5. Publish your Design System | kickstartDS docs", "heading": "Summary", "content": "Create your Design System5. Publish your Design System5. Publish your Design System We're currently in the process of writing this part! Please come back later, it shouldn't take long!", "tokens": 44}
{"title": "Token | kickstartDS docs", "heading": "What are Token?", "content": "Token are the smallest building blocks of a design system. Based on the values they store, they are usually used across multiple tools and platforms to ensure consistence and matching brand identity. Because Token are described abstraction, the defined values can change without disturbing the designer or developer experience. The single source of truth to name and store a design decision, distributed so teams can use it across design tools and coding languages. -W3C Design Token Community Group", "tokens": 93}
{"title": "Token | kickstartDS docs", "heading": "Inherit Token Level", "content": "kickstartDS differentiates between Branding, Design and Component Token. Whereas described above Design Token store values e.g. color, typography, spacing, animation, etc., Branding Token are are very small token subset to setup your corporate design in lightspeed. Component Token represent the properties and values that are contained in a component, e.g. container, label text, icons, and states.", "tokens": 86}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Create", "content": "Interstitial component This guided example show how to find a fitting, existing kickstartDS base component for one of your use cases, to repurpose it. Meaning: you start with some requirements, match an existing component, find a fitting new name for the use case, and give it a new purpose by greatly restricting and rewiring its options for the new context. Even while using the component rather directly from kickstartDS, you'll want to find the correct set of properties for your own use case. Components in kickstartDS come equipped with properties for a wide range of possible use cases, so it makes sense to reduce those to the ones you really need... to make components easier to understand, use and reason about! We call this type of workflow Creation. Learn more about it in our dedicated guide about it. If you're unsure about something, have a look over there. We go into more background detail there about what we're doing here. This also means that, for this example, we'll get by without any additional styling needed. We'll live off of everything already set in place by our existing Design Token and component structure.", "tokens": 233}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Overview", "content": "More concretely: what we're building up to in this example... and for the sake of imagination, assume this was what your designer cooked up: This will be done in three simple steps: - Component Definition, - Component Mapping, and - Component Creation For more details about those steps, have a look at the guide about different component processes and their shared structure.", "tokens": 77}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Requirements", "content": "This guide assumes that you already have a working Design System, that is based on kickstartDS, running. If that's not the case, follow our Create your Design System guide . Additionally you'll need access to our Content module, to use the Storytelling component this guide is based on.", "tokens": 62}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "kickstartDS Content Module", "content": "The perfect addition to our Open Source base The Content Module includes seven rich components: Hero visual, Quote, Storytelling etc. â€” everything you need to build beautiful content experiences or to enrich your existing Design System", "tokens": 45}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Purpose", "content": "We want to create an element that can be interjected into otherwise monotone content. To direct focus, or present alternatives, to the main body of content. We'll probably need to be able to define a title and some body content. Additionally, we want to add some flavour to the component by using noticeable design variations, not typically found in our other components. Adding a static background image to the component could be nice touch! Finally being able to add a link with a link target ( link.target) and and link text ( link.text) will be needed, but they should be optional.", "tokens": 125}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Structure", "content": "This would leave us with the following properties (API) for our new component. Required fields are marked with a : |Property||Type||Description| |Title to show| |Body content to display| |Page to link to| |Text to use for the link| Fields that should be required are marked with a . While directly helping us get a better grasp on our new component, these will also be used to write our JSON Schema later!", "tokens": 94}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "2. Component Mapping", "content": "Next we want to search for components that could be of use in assembling this new one. This might be a single, big component that more or less directly fits our use case, or alternatively a combination of components that could serve as the basis by combining them. This will then serve as our kickstartDS base component, which will be adjusted to fit our needs!", "tokens": 77}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Matching it", "content": "From a quick glance, our Storytelling component seems like it might fit the bill quite nicely! It has options for a title ( box.headline) and body ( box.text), supports some RTE-like formatting for our body, and has a wide range of possible design adjustments: mainly background colors & images, an optional foreground image and a bunch of possible arrangements of those. This would also enable us to add a nice-looking background image to the whole component by using a combination of its attributes backgroundImage and backgroundColor: For a complete overview of the available options, take a look at the Storytelling component API here: https://www.kickstartds.com/storybook/?path=/docs/content-storytelling--image", "tokens": 154}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Adjustments", "content": "This only gives us a rough sketch, though. We still need to adjust the example code to exactly fit our needs. In the process we will hard-code a bunch of options, because we're only interested in a specific set of them. The rest can be set to default values, which don't need to become part of the component API.", "tokens": 73}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Great components", "content": "Sed diam nonumy eirmod tempor invidunt Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.", "tokens": 73}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Start with an existing", "content": "Storytelling component variant We'll start by copying the JSX code for the Image variant of our Storytelling component, from here: https://www.kickstartds.com/storybook/?path=/docs/content-storytelling--image", "tokens": 54}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Remove all of the unneeded stuff", "content": "There are a bunch of properties that are completely optional, mainly those having their values undefined or null in the copied JSX, or ones which just state the default value of that property anyway. Those can be freely removed. We'll also not be utilizing the image, at least for now!", "tokens": 66}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Hard-code static, required properties", "content": "We add nice values for backgroundColor and backgroundImage, invert everything with ks-inverted to make it pop, and change some alignments for the box, as well as make the headline \"louder\" by styling it as a h1.", "tokens": 59}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "3. Component Creation", "content": "We like to colocate components. This means to have all involved files next to each other in the same folder; the template ( .jsx / .tsx), potential CSS / SASS ( .css / .scss), JavaScript ( .js / .ts), our JSON Schema component definition ( .schema.json), and so on. So we start by creating the directory src/components/interstitial, from our Design System repository root: _1mkdir -p src/components/interstitial This is the folder we'll add new files to in the coming few paragraphs. JSON Schema definition First file we'll create is the JSON Schema definition, encoding the structure we've defined for our component before:", "tokens": 152}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Start with just the boilerplate for a component definition", "content": "This includes all necessarily required values for a valid component definition in kickstartDS. To learn more about our use of JSON Schema, read our Foundations page about it.", "tokens": 46}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Add basic info describing component", "content": "We start by adding a title, description and $id attribute. The correct $id depends on your Design System configuration. We'll assume you've created components before, living under the schema prefix http://schema.mydesignsystem.com. ", "tokens": 56}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Add object to hold", "content": "link properties This will hold our properties target and text. We add them to their own object to indicate that they're used to be together, thus hinting at their combined usage.", "tokens": 41}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Finished", "content": "JSON Schema Let's have a look at our completed JSON Schema definition. This concludes creating the JSON Schema. When running the schema generation in our Design System again, we should now automatically end up with a corresponding type definition to be used in creation of the template in the next step: How your schema generation is started might change depending on your setup. If you've followed our \"Create your Design System\" guide before, or want to add it like we do, follow this section of it closely. React Template As the final step for this example, we'll add the template. This will be a purely functional React component, mapping our component structure (as defined in the JSON Schema) to the original component we're basing our work off of; the kickstartDS Storytelling component.", "tokens": 164}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Start with a boilerplate", "content": "Again we'll start with a very basic skeleton for our React component. We're using TypeScript here ( .tsx), but it works the same with plain JSX ( .jsx).", "tokens": 44}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Add correct typings", "content": "correct typings Import and add generated props from InterstitialProps.ts. Generated by our JSON Schema, these guarantee you're matching your expected component structure while implementing. In combination with TypeScript this enables auto-complete and auto-fix for even better DX! (see here, at the very end of that section, for more details)", "tokens": 75}
{"title": "Create `Interstitial` component | kickstartDS docs", "heading": "Destructure", "content": "props We also need to add our own properties, so we'll destructure props. We'll just pass through everything HTMLDivElement related! While at it, some dummy markup for our properties is added.", "tokens": 45}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Overview", "content": "Setting up your own Design System can be done in one of two ways: - By creating a new project for your Design System to live in, or - by adding everything to an existing project", "tokens": 41}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Create new project", "content": "Start in a fresh directory inside your terminal. This should be the directory all your Design System code will live in, and that will also be pushed to a Git host, later on. It shouldn't include a .git folder, yet! We'll use ~/projects/my-design-system here, with ~ denoting the users' home directory. First, let's create a Git repository: _5$ mkdir -p ~/projects/my-design-system_5$ cd ~/projects/my-design-system_5$ git init_5_5> Initialized empty Git repository in ~/projects/my-design-system/.git/", "tokens": 138}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Working with the terminal", "content": "If any of the commands related to git or npm / node fail for you, or you need help working with the terminal, have a look at our Getting Started page about Environment configuration. Additionally you might not use nvm for Node version management. Just skip those sections, and ensure the correct version for your project is installed and active! Next we'll add a .gitignore file to the repository, that will be built up through the following sections to exclude generated code files: _1touch .gitignore Add the node_modules folder to it for now: Then we'll add a .nvmrc file specifying the use of Node 16.14 for this project (this is the version kickstartDS currently works off of) to our project root: Call nvm use right after, to activate the correct Node and npm versions: _4$ nvm use_4_4> Found '~/projects/my-design-system/.nvmrc' with version <16.14>_4> Now using node v16.14.2 (npm v8.19.2) Finally we'll make it a valid npm package, too: _4$ npm init_4_4> About to write to ~/projects/my-design-system/package.json:_4> ... Enter the prompted information, and you'll end up with a package.json describing your freshly made npm package. Use dist/index.js for the entry point, this is where our bundled code will live. The rest is pretty much up to your liking! It should look roughly like this: With this you can continue with Add to existing project. From here on out the steps will be the same. You'll just find that, in comparison to having an existing project, you'll probably not find any of the steps to be optional!", "tokens": 379}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Add to existing project", "content": "In your terminal, switch to the project that you want to add kickstartDS to first. We'll be adding some dependencies, some glue code and configuration to hook everything up. Some of the following steps might be optional for your personal setup, so feel free to skip them. For example: you might already have React installed in your project, so you wouldn't have to complete that part of the setup!", "tokens": 87}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "`npm` vs `yarn` vs ...", "content": "In this guide we'll be using yarn as our package manager of choice. Feel free to use your preferred solution instead. For more details see our page about Environment configuration. For example: if you were using npm, and you'd encounter the following command to run yarn add react@17 react-dom@17... just replace yarn with npm and run npm add react@17 react-dom@17 instead.", "tokens": 91}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Add", "content": "React If your project was not using React before, you should add a compatible version ( kickstartDS currently uses React 17) of it now: _1yarn add react@17 react-dom@17", "tokens": 46}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Result", "content": "Our repository is initialized. We can now connect it to a Git host, or just continue with the guide without pushing our code to a registry. If you'd like to learn more about Git hosts, see our Environments page about it.", "tokens": 51}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Next Step", "content": "We'll continue by applying our branding to kickstartDS, which will result in a bunch of token files ( JSON) being added to the project. This will also give us the opportunity to set up Storybook, and get a first visual representation of our Design System in the browser!", "tokens": 60}
{"title": "1. Start your Design System | kickstartDS docs", "heading": "Code Sandbox", "content": "See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/1 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 86}
{"title": "Release Spotlight: Semantic Token", "heading": "Summary", "content": "#tldr: Design Token are all the rage these days. In almost every channel from the Design System space, you can feel a crispy white noise around the broad topic of Design Token. We also put in a lot of effort when refactoring our Token structure in kickstartDS for our latest release. It might look over-engineered on a first glimpse, but we understand ourselves as a meta framework for Design System creation and therefore want to provide you best practice defaults.", "tokens": 101}
{"title": "Release Spotlight: Semantic Token", "heading": "Branding, Design & Component Token", "content": "Token are the smallest building blocks of a Design System. Based on the values they store, they are usually used across multiple tools and platforms to ensure consistency and matching brand identity. kickstartDS differentiates between Branding, Design and Component Token. Whereas Design Token store values e.g. color, typography, spacing, animation, etc., Branding Token come in handy offering a structured approach towards applying your companyâ€™s brand identity or corporate design at one single spot with maximum efficiency. Component Token represent the properties and values that are contained in a component, e.g. controlling how its container, label text, icons, and states look. Since we are publicly open source now, the great thing is, that you can check out that structure on your own in our repo.", "tokens": 164}
{"title": "Release Spotlight: Semantic Token", "heading": "We fully rely on", "content": "semantic token within kickstartDS With this release we implemented semantic token, which is a rather modern concept that mainly involves naming tokens by their intended use. Some teams refer to these with names like alias tokens or purpose tokens, all describing basically the same concept of including intention in the token name, in comparison to just naming it by its current value (like â€œcolor-redâ€). Example:  $background-color-success vs $background-color-green I donâ€™t want to go into more detail in this post, as these concepts are already very much explored by well known people from the community ðŸ˜‰ For example Nathan Curtis article: https://medium.com/eightshapes-llc/naming-tokens-in-design-systems-9e86c7444676 Other valuable reads are from Lukas Oppermann and Dannie Damato https://uxdesign.cc/naming-design-tokens-9454818ed7cb https://blog.damato.design/posts/tokens-as-intents/", "tokens": 231}
{"title": "Release Spotlight: Semantic Token", "heading": "Base scales vs Semantic Token", "content": "As described in the paragraph above semantic token are the concept we apply when building components, whereas base scales are another concept we use as the input for your semantic token. You choose your semantic token from a set of base values and scales, think of those as the painters palette, making sure thereâ€™s a lot of re-use (aliasing) in your Design Token. In turn enabling efficient, consistent changes to your semantic token. There are scales for different kinds of token, such as color or spacing for example. A base scale for these token is generated by default. You can edit the scales when applying to fully match your brandâ€™s identity.", "tokens": 142}
{"title": "Release Spotlight: Semantic Token", "heading": "Structured token following Style Dictionary format", "content": "Taking the code perspective: token in kickstartDS are structured using JSON, following the Style Dictionary format. Style Dictionary is an Open Source tool developed by Amazon that allows you to define styles once, in a way for any platform or language to consume. With Style Dictionary you can manage Design Token and organize them into collections of JSON files. In addition, you can export those organized tokens to many platforms, tools or integrations by using its so-called transform groups to generate technology-specific formats or deliverables. Side note: we are eagerly awaiting the release of the W3C Design Token Group format, with the intention with following it whenever it is finally decided. Using such an established approach with Style Dictionary in the meantime allows to benefit from its general community adoption, a lot of extensions, plugins and automation already being written for you.", "tokens": 174}
{"title": "Release Spotlight: Semantic Token", "heading": "Themes for Bootstrap, MaterialUI, TailwindCSS, Fiori and others", "content": "Facilitating Style Dictionary, we can use its transform groups to derive and generate themes for 3 rd party component libraries such as Bootstrap, MUI or even SAP Fiori. We are working on ready-to-use examples to help you distribute your Design Token and assets into these environments. Weâ€™ve started with early tests on this, but the goal is to provide ready-made configurations. Giving you a great starting point by having best practice connections between themed solutions like MUI and your Design Token.", "tokens": 120}
{"title": "Release Spotlight: Semantic Token", "heading": "Style native mobile Apps through token", "content": "As you might have noticed already most of that transformation-stuff is made possible by Style Dictionary. Hence, similar configurations can be set up to apply token for their usage in native apps in Android or iOS.", "tokens": 48}
{"title": "Release Spotlight: Semantic Token", "heading": "CSS Custom Property transform group", "content": "Custom properties are the bedrock of our component implementation when it comes to encoding design and layout. We transform your Style Dictionary into a set of those CSS Custom Properties, which are then layered onto components in the form of Component Token. So a â€œButtonâ€ may use one semantic color token for its label text by default (â€œâ€“ks-text-color-interface-interactiveâ€), but in a different variant an â€œAlertButtonâ€ might be specifically layered with a semantic color token signifying a problem (one based on â€œâ€“ks-color-negativeâ€), while still re-using the rest of the default â€œButtonâ€ token mapping.", "tokens": 145}
{"title": "Release Spotlight: Semantic Token", "heading": "Synchronization of Design Token from Figma", "content": "Since Figma still does not offer a full, native integration or treatment of Design Token, we are working on a synchronization from Figma to JSON. You might be familiar with the Figma Token plugin or tools like Specify for this dynamic exchange between design and code. We are currently working on a solution, as a perfect addition and fit for the Token structure in kickstartDS, to also make this part of the design process efficient and easy like squeezing a lemon. Unlike hassling around with configurations to be adjusted, or concepts not quite fitting your intention, this will be opinionated and tailor-made to the way weâ€™ve approached token in kickstartDS.", "tokens": 143}
{"title": "Release Spotlight: Semantic Token", "heading": "Multibrand-theming and layering with kickstartDS", "content": "You can declare Design Token for each of your brands/themes within a layered instance of kickstartDS. You or your DesignOps team can specify which component for which brand should be based on the core components, or instead be fully customized for that specific use caseâ€¦ keeping it from polluting the (shared) core. And if itâ€™s just another layer of paint for one of your sub-brands, you can even get away with just defining an additional token set. No further coding required!", "tokens": 110}
{"title": "Release Spotlight: Semantic Token", "heading": "Make it yours!", "content": "In reference to what I wrote in the intro of this post, kickstartDS is meant to be a meta framework for Design System creation. Start by applying your branding and corporate design to kickstartDS in roughly two steps: - Use a reduced set of Branding Token to generate your initial Design Token set - Fine tune the resulting Design Token set to closely fit your corporate identity Once your Design Token are generated, the Design System will already have the broad look and feel of the targeted Corporate Design. However, you probably still need to tweak some little details to make it match up perfectly with your brand requirements. More than just adapting token, you should also adapt our base components and start making them your own. By default our components come with a huge set of properties. You choose which of these props you really need, how you want to name them, and thus how you want to synthesize it towards your own requirements. You can also create wholly new components based only on following kickstartDSâ€™ systematic approach, without actually using base components.", "tokens": 213}
{"title": "Release Spotlight: Semantic Token", "heading": "Ultimately, adapt and make the default process yours", "content": "We propagate code first, when talking about the source of truth of Design Systems. Users interact with coded components, not with the (Figma, Adobe XD or Sketch) design files which are often the starting point for exploration of the component use cases or even full-page layouts to be adopted by the developers. Depending on which handover process you have implemented and how deeply designers interact with developers, handling Design Token through Style Dictionary generates high value for both parties. It gives designers the power to keep owning their design decisions, as developers usually, for example, do not like to decide which color to use (one more reason to rely on semantic tokens). Those decisions then will be transformed into JSON, which makes those files the ultimate source of truth, working in both directions.", "tokens": 163}
{"title": "Release Spotlight: Semantic Token", "heading": "Try it now", "content": "I hope that we could tickle your curiosity and light up the desire to try it out on your own. The best place to start are our docs, which might get their own Release Spotlight soon. https://www.kickstartds.com/docs/guides/create/ If you have any questions, just join our Discord community or drop us an email to hello@kickstartds.com", "tokens": 85}
{"title": "Component API | kickstartDS docs", "heading": "Component API", "content": "Our Component API simplifies processes within the development tool chain by being low-code and increasing the frontend developer experience (DX) and making Design System adoption anti challenging. With â€žJSON schemaâ€œ we lower barriers to a huge number of other softwares Simplification and automation of processes: - adapters to connect headless CMS or interface builders - automatic validation for quality assurance - automatic typing and IDE-completion - generation of documentation inside Storybook We'll heavily expand upon this section, soon. Please come back soon for more JSON Schema goodness!", "tokens": 115}
{"title": "Next.js | kickstartDS docs", "heading": "Next.js", "content": "We've already implemented a bunch of Next.js based apps and pages using kickstartDS successfully. It's compatible pretty much out-of-the-box, only some slight transpilation may be needed (see below on how to do that). Next.js is a flexible React framework that gives you building blocks to create fast web applications. There's some obvious overlap between Next.js and kickstartDS in the choice of React as the frontend technology. We also benefit from some key concepts implemented in our components React templates when building Next.js based pages and apps. To learn more about Next.js, visit their official website.", "tokens": 133}
{"title": "Next.js | kickstartDS docs", "heading": "Features", "content": "Some of those React concepts that are at the core of kickstartDS components: - Use of Context / Provider - Use of renderProps - Purely functional components For some real world examples on how this can help you: - see how to replace Rich Text(like Markdown) in all kickstartDScomponents - see how to replace Imagehandling in all kickstartDScomponents", "tokens": 82}
{"title": "Next.js | kickstartDS docs", "heading": "Transpilation", "content": "Transpilation of our packages is needed because we deliver components as ES Modules. Those are not natively understood by Next.js. Additionally we have import statements loading component CSS inside of those exported components that you'll import. Those will also have to be processed by the Next.js pipeline, which by default ignores node_modules where your kickstartDS dependencies live. We recommend using next-transpile-modules for transpilation.", "tokens": 93}
{"title": "Next.js | kickstartDS docs", "heading": "Configuration", "content": "To add transpilation to your Next.js based project, first add the npm dependency: _1yarn add next-transpile-modules Then add the following code snippets to your next.config.js, at your projects root: There's a great chance that file already includes configuration for your project. In that case, make sure (as the official docs mention) to include withTM as the outermost plugin. To learn more about Next.js plugins and next.config.js, see the official Next.js docs on that.", "tokens": 115}
{"title": "Next.js | kickstartDS docs", "heading": "Using other / additional modules", "content": "If you're using other kickstartDS dependencies, you'll have to add them to that list above. For example, when using @kickstartds/form, @kickstartds/content and @kickstartds/blog, too:", "tokens": 55}
{"title": "Next.js | kickstartDS docs", "heading": "Interested?", "content": "If you want to know more, feel free to get in contact! We'll flesh out this part of our documentation soon, you may also sign up for a notification when this is done.", "tokens": 41}
{"title": "Great components inside kickstartDS", "heading": "Summary", "content": "*#tldr:* in this post Iâ€™ll try to provide some background info on the power of **kickstartDS components**. They are especially powerful once customized to your brands corporate design. They come with lots of options, so you donâ€™t need to either invent or deal with limitless variants like in other frameworks. You can even specify or limit design variations based on different token sets or across multiple brands or layers.\nis what we promise and tell you on our homepage.", "tokens": 106}
{"title": "Great components inside kickstartDS", "heading": "What does that mean?", "content": "In kickstartDS components are designed to be the foundation of your design system. That is the reason we put all our experience into building base components containing the most used variants, without blowing up the complexity with a multitude of unneeded options right from the get-go. We rely on design and component tokens, which are already regarded as a standard by most, when talking about design systems. You can easily use our base set of components to assemble any page layout for all content-driven frontend. Every component in kickstartDS comes with its own options. These options help you to configure the basic settings. For example: if you use a component containing a headline, you can easily configure the alignment, headline-level and more. Since experienceable documentation is very important to us, you can utilize the Storybook â€˜Controlsâ€™ panel to test and preview all possible changes. Check out the following clip for a micro-example: This already is pretty cool and helpful! You can try it out on your own in our live Storybook. But it gets even better when digging deeper into the â€œ Sectionâ€ component from the clip before. You can configure the complete lookâ€™nâ€™feel, like deciding on the background color and decorative patterns for the section in question. Always in compliance with the rules and limitations formalized by your own design system: I hope you start to see where weâ€™re coming from, when weâ€™re talking about great components. And what you youself could expect to enjoy when working with our components. Especially how well-curated component options, connected with carefully chosen design and component tokens, give you a nice expressive workbenchâ€¦ all while providing safety, by keeping you inside set (design system) guard rails in regards to branding and consistency. Getting back to the documentation part: the JSON Schema we write as part of every kickstartDS component, used to e.g. make the components configurable in Storybook, also helps to provide a base layer of options for you to connect to the headless CMS of your choosing. Placing all these powerful options in the hands of your editors and content creators! But that is something weâ€™ll shine the spotlight on in another, dedicated blog entry. Letâ€™s instead take a look at one more example, a mighty component included with our design system starter kit:", "tokens": 487}
{"title": "Great components inside kickstartDS", "heading": "The hero visual ðŸ¦¸", "content": "A hero visual usually is an oversized banner image that is placed in the top section of a website. It is immediately prominent and catches the userâ€™s attention at a first glance. Oftentimes it promotes the unique selling proposition, and contains the main call to action of the page. In comparison to other frontend frameworks, you should really only need one visual component to be the hero of all of your touch points. Adapting to all your needs while still keeping it simple. For us that is the â€œVisualâ€ component. Tailwind UI, as one counter-example, offers 9 ready-made components for the hero layout alone. With kickstartDS you donâ€™t need that much of a selection. And thinking Design System-wise you shouldnâ€™t want or need that many options, either (â€œbutâ€¦ which one should I use?â€). You want to provide one set of design rules to apply for all hero image-type usage. Once this is set up, each editor can decide on his own on what is the best way to promote his content, always staying in compliance with your brand guidelines and promoting overall consistency. This is just one more example of what differentiates our components, making them a great experience for all parties involved.", "tokens": 264}
{"title": "Great components inside kickstartDS", "heading": "More brands, more logos, more colors, all ruled by the same components", "content": "Most companies own subsidiaries and hence have a real need to care about multiple brands, including all necessary design and layout related decisions. Here, too, you can rely on the kickstartDS base components, customized to match your major brands design. Starting with those as a foundation and layering additional decisions on top in a controlled and measured way, down towards even your smallest sub-brand â€¦ using a different set of colors, fonts or shapes. We call this multi-brand theming and design system layering. As with those aspects of centralized design rules mentioned in the section about the hero visual, by using kickstartDS all components really do share one common, reusable core. You can declare design tokens for each of your brands within a layered instance of kickstartDS. You or your DesignOps team can specify which component for which brand should be based on the core components, or instead be fully customized for that specific use caseâ€¦ keeping it from polluting the (shared) core. This balance of flexibility and efficiency when dealing with multiple variations of your design system will be the final example of this post, detailing what we think makes components great. Do you agree that those are important parts of what makes a great component? Please let me know what you think?!  btw: as we are super convinced by the component tokens principleâ€¦ we even wrote our own Storybook addon (to inspect and interact with said tokens in a dedicated Storybook panel) which you can download and use for free! ðŸ¤—", "tokens": 319}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "kickstartDS is the Open Source starter kit for Design Systems", "content": "A low-code framework and comprehensive component library enabling digital teams to create consistent and brand compliant web frontends super efficiently. Easy like squeeeeezing a lemon The simple truth", "tokens": 46}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Own a Design System without years of investment", "content": "No vendor lock-in! You create your own repo having the code installed, so youâ€™re not locked-in. You own it! It is your Design System. You own whatever you build. Itâ€™s yours to do what you want.", "tokens": 62}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Number of decisions available to you", "content": "directly use best practice defaults given by kickstartDS, or make it your own in detail Use them as solid building blocks, adapt and improve them as needed. From design tokens to full customization. Read why our components are great. Component properties encode decisions, rooted in reality, pre-solving everyday problems for you. Directly engage with components through Storybooks rich interface. Of course we have design token â€“ colors, fonts, sizes and iconography. Additionally, component token provide a solid base layer of defaults for you to mutate.", "tokens": 116}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Open Source framework for Design System creation", "content": "For better collaboration between content creators, developers, designers and stakeholders Rely on any framework you want Every kickstartDS component consists of semantic HTML(5), CSS Modules & Properties and JavaScript (ES6). This makes it easy to implement across any framework or even stand alone. Alternatively, use our ready-to-use React components directly in your codebase! Quality user experience A quality UX is defined not only by relevant content and services, it is also a matter of a clear and consistent brand image, with intuitive and usable interaction patterns and features. Use our experience to your advantage! Best in class performance Built for maximum performance. The kickstartDS components runtime, design token system and CSS framework are as lightweight as you need it to be. Stop thinking about build tooling and bundling! Accessible by default kickstartDS provides support for W3Câ€™s WCAG 2.1 spec. We take care that components support touch and keyboard navigation, screen readers and more. And if needed, we can give you pointers for your content!", "tokens": 220}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Great Open Source components", "content": "Components serving as the basic building blocks of your Design Systen kickstartDS is the foundation for your Design System, built with reusable components and tools, guided by clear standards, that can be assembled together to create your products: fast, flexible, responsive, accessible and the best of all: ðŸ‘‰ you can plug it onto every digital touch point you own.", "tokens": 78}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Flexible + easy design application", "content": "One common ground for developers and designers kickstartDS helps developers and designers alike to independently deliver a consistent UX and engaging user interfaces. With kickstartDS teams are able to design, build, and organize UI components better and faster. Using Storybook you make sure every element aligns with all the responsive scenarios your users may encounter!", "tokens": 72}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Design System services", "content": "Together we identify if you need a Design System We offer services to check if your frontend inventory matches with the components kickstartDS offers. This is already the case for more than 90% of our users. We'll assist and empower you to use your Design System on a day to day basis.", "tokens": 64}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Integrations â€“ Stop reinventing the wheel!", "content": "Start with a strong common ground â€“ and integrate fitting solutions as needed With a multitude of existing integrations, common tasks can be reduced to just adding the correct one to the mix! Need a marketing- or landing-page? A blog? Get the page-builder experience with Netlify CMS or Wordpress on our official Gatsby theme. Building a Next.js page? Use our auto-generated GraphQL API, including full documentation! Everything is SSR- and ESM-compatible, too! ... stellar performance included!", "tokens": 116}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "What our customers say", "content": "kickstartDS is a game changer. Its Design System helped our team to improve our brand consistency, while it's pattern library boosted our developers building completely new frontend components. kickstartDS has saved us so much time scaling different white label frontends with the most performant framework I have ever seen. I have rarely seen such a passionated and dedicated team with one shared mission: enhance the developer experience and make frontend first again.", "tokens": 94}
{"title": "kickstartDS â€“ Open Source starter kit and low-code framework for Design Systems", "heading": "Get in contact!", "content": "We would love to hear from you! Every bit and piece of feedback is welcome as we want to learn from you, get to know you better, to evolve kickstartDS to meet your needs. The perfect addition to our Open Source base", "tokens": 52}
{"title": "https://www.kickstartDS.com/cookies", "heading": "Summary", "content": "icon-arrow-down\nicon-arrow-left\nicon-arrow-right\nicon-arrow-up\nicon-browser\nicon-chevron-down\nicon-chevron-left\nicon-chevron-right\nicon-chevron-up\nicon-close\nicon-contact\nicon-date\nicon-download\nicon-email\nicon-facebook\nicon-first-page\nicon-home\nicon-info\nicon-instagram\nicon-last-page\nicon-linkedin\nicon-login\nicon-logout\nicon-map\nicon-move\nicon-person\nicon-phone\nicon-place\nicon-print\nicon-refresh\nicon-search\nicon-share\nicon-stackshare\nicon-star-outline\nicon-star\nicon-time\nicon-twitter\nicon-upload\nicon-whatsapp\nicon-xing\nicon-youtube\nicon-zoom\nZum Inhalt springen\nZur Hauptnavigation springen\nCookie List\nInfo about the cookies in use on our site\nAdjust your cookie preferences\nCookie Settings", "tokens": 247}
{"title": "JavaScript", "heading": "JavaScript", "content": "JavaScript for us has two uses. On the one hand it is the foundation for progressively layered interactivity on a website / interface built with kickstartDS, and on the other hand it's at the core of the \"engine\" powering quality and developer experience in modern web frameworks: build tooling, bundling, semantic versioning, testing, etc. Decision kickstartDS Why we care? Read more, or chat with us, to learn how this helps create consistent frontend interfaces", "tokens": 101}
{"title": "Foundations | kickstartDS docs", "heading": "Foundations", "content": "Foundations are the visual elements needed to create your Design System and its engaging user experiences. You can build up your specifics based on all the best practice defaults given by kickstartDS on token, like color, typography, but also components and layout.", "tokens": 54}
{"title": "Foundations | kickstartDS docs", "heading": "kickstartDS Content Module", "content": "The perfect addition to our Open Source base Interested? Contact us! The The Content Module includes seven rich components: Hero visual, Quote, Storytelling etc. â€” everything you need to build beautiful content experiences or to enrich your existing Design System", "tokens": 52}
{"title": "kickstartDS â€“ about us and the team", "heading": "Frontend is our passion", "content": "That is why we baked 20+ years of agency experience into kickstartDS Design Systems- also known as \"pattern libraries\" or \"component libraries\" - promote quality, consistent UX design across products; and expedite the work of designers, developers, and anyone else working on a digital service.", "tokens": 64}
{"title": "kickstartDS â€“ about us and the team", "heading": "Design systems are expensive, hard to maintain, heavy to get started.", "content": "We want companies to save time and budget by minimizing duplicate work and increasing speed-to-market. We want to improve your customer's experience, maintaining brand consistency, providing an accessible and seamless UX across all customer touch points. We help development teams to make it easier to collaborate. Don't you want to own a design system without spending years of development? Well, it is here. Let's kickstartDS it together!", "tokens": 100}
{"title": "kickstartDS â€“ about us and the team", "heading": "Our Origin story", "content": "After 15 years building websites and UI's ourselves, we wanted to improve the way teams collaborate when creating web frontends. That's why we started kickstartDS. We want to share our experience and offer a huge library of best practice patterns and well tested web components. All the while following the principles of the Atomic Design methodology. That's why kickstartDS really is a ready to use framework, to support people and organizations building Design Systems and digital touchpoints. It prevents developers from wasting time setting up the basics, while it enables designers to focus on tricky UI challenges. Jonas Ulrich, Founder and CTO More than 20 years ago I started creating user interfaces and web style guides, corporate design manuals and in the past years the first digital Design Systems. After working in a large tech corporation for a long time I very well know todays problems in gaining and maintaining consistency in UIs. Whilst organizing the regional UX meetup I heard so many design and dev teams complaining about the same frontend problems. That was the reason I co-founded kickstartDS. Knowing that we can create tremendous value for all these frontend creators and the companies they are working for. I am convinced that both parties will benefit from using our solution within their tool chain. And I am more than happy to hear your story! Daniel Ley, Co-Founder + UX Strategist with heart & soul", "tokens": 282}
{"title": "kickstartDS â€“ about us and the team", "heading": "Own a Design System without investing years of development", "content": "kickstartDS is the design system starter kit in which we have already solved all core challenges. No need to setup all the basics before start working on the real stuff. Remove all the assumptions on building your design system, and reduce the risk and effort required to to get started. Let's talk about how kickstartDS can help you.", "tokens": 78}
{"title": "Image Rendering | kickstartDS docs", "heading": "Summary", "content": "icon-arrow-down\nicon-arrow-left\nicon-arrow-right\nicon-arrow-up\nicon-browser\nicon-chevron-down\nicon-chevron-left\nicon-chevron-right\nicon-chevron-up\nicon-close\nicon-contact\nicon-date\nicon-download\nicon-email\nicon-facebook\nicon-first-page\nicon-home\nicon-info\nicon-instagram\nicon-last-page\nicon-linkedin\nicon-login\nicon-logout\nicon-map\nicon-move\nicon-person\nicon-phone\nicon-place\nicon-print\nicon-refresh\nicon-search\nicon-share\nicon-stackshare\nicon-star-outline\nicon-star\nicon-time\nicon-twitter\nicon-upload\nicon-whatsapp\nicon-xing\nicon-youtube\nicon-zoom\nSkip to main content\nFollow our main guide to learn how you can \"Create your Design System\" in just 5 steps:\nOpen guide\nGetting Started\nFoundations\nIntegration\nGuides\nConcepts\nFAQ\nRoadmap\nFeedback\nGitHub\nReact\nImage Rendering\nImage Rendering\nThis guide is coming soon, please come back later!\nPrevious\nReact\nNext\nRich Text Rendering", "tokens": 299}
{"title": "Create a component | kickstartDS docs", "heading": "Overview", "content": "Creating a component differs from \"just\" adapting a component in that it starts out without a specific kickstartDS component already in mind. All but the most obvious components will be implemented following this strategy. And it's the preferrable way to do it, too. You should start out with just a concept of what you actually need. Which components can help in bringing that concept to life should be something you concern yourself with second. This also explains why this has an additional step in \"Component Mapping\", when compared with adapting a component. This is where we will try to match our component API to existing components. This works especially well in 2 cases: - When what you need is actually just a specialized case of one of our existing components. Like when wanting to create an article teaser, you'll probably find a general purpose kickstartDScomponent like the TeaserCardthat matches this signature really well - You have a rather complex component (think something like a more advanced blog head component). Often you'll find those components to be composed of basic building bricks (like Buttons, TagLabels or Headlines) after all, which is where component mapping to kickstartDScomes into the picture again", "tokens": 244}
{"title": "Create a component | kickstartDS docs", "heading": "When zooming in enough, everything starts to look the same", "content": "If you think about it, there's only a limited number of ways information can actually be presented. And oftentimes you'll find there's already preferred versions of doing it out there, what we'd call learned user interface (UI), or just best practices. The Hamburger menu icon would be such an example. Or how certain information is often teased in the form of structured cards. Adhering to that expectation, and not creating unneeded artificial friction, is one big part of delivering a good user experience (UX). We're convinced we can cover a great range of those basic building blocks for you. Allowing you to concentrate on destructuring your requirements, mapping the resulting pieces to kickstartDS components. It's how bigger kickstartDS components like a Storytelling component (using Button, Headline, RichText, etc) are constructed, too. Additionally this can of course also be combined with customization for your own added properties, not part of the used kickstartDS base components (see our Headline component example for that). Or be implemented using extension if the component should expand on some kickstartDS base component (see our Section component example for that). To learn more about the different processes available to you when creating a component with kickstartDS, have a look at the overview page of this section.", "tokens": 278}
{"title": "Create a component | kickstartDS docs", "heading": "Creation process", "content": "You should already have an idea of what you'll need from your component, or some rough image of what it should do. We start by refining those requirements into a component API, which we'll then map to existing kickstartDS base components. This will then serve as our starting point for creating the actual component. There are three main steps in creating a component: - Component definition, - Component mapping, and - Component creation So the main way this differs from adapting a component is in adding \"Component Mapping\", in between \"Component definition\" and \"Component creation\". This is where we'll try to match our component API to existing components. We'll also slightly deviate from it when defining our structure, as we can't just reduce an existing set of component properties here.", "tokens": 159}
{"title": "Create a component | kickstartDS docs", "heading": "Adaptation process as a base line", "content": "If you've read our \"Adapt a component\" guide you probably already know this: This guide expects you to reduce the set of props offered by kickstartDS components, when used as base components. We'll also skip over, or significantly shorten, parts already covered by that guide. If unsure about something, best cross-reference it! Let's start with the definition!", "tokens": 82}
{"title": "Create a component | kickstartDS docs", "heading": "1. Component Definition", "content": "Like the adaptation process we start by defining a component API. But unlike it, we directly write down what we need. We don't start with a blueprint this time. We'll use the TeaserCard component throughout this guide to illustrate concepts. This will not be an exhaustive example, though. For that have a look at our guide \"Create TeaserCard component\". We also have an additional example in \"Create Interstitial component\", but to actually implement that you need access to our kickstartDS content module. But following the thought process behind it can provide values nontheless.", "tokens": 121}
{"title": "Create a component | kickstartDS docs", "heading": "kickstartDS Content Module", "content": "The perfect addition to our Open Source base The Content Module includes seven rich components: Hero visual, Quote, Storytelling etc. â€” everything you need to build beautiful content experiences or to enrich your existing Design System", "tokens": 45}
{"title": "Create a component | kickstartDS docs", "heading": "Purpose", "content": "When thinking about a component that should be part of your Design System, you should already have a strong sense of what that component should be, and what it should accomplish for you. If that's not the case, it probably isn't stable enough yet to be part of a Design System that should find wider adoption. You should probably take a step back first, and maybe start a Design System Initiative to narrow down on what components you'll really need. With that in mind, let's assume that the purpose of our component (the TeaserCard) is to tease content. It should look like a card while doing that, and have the obvious features one would assume a card based component to have. Like a cover image, a link, a headline and some text... with some of those potentially being optional. And because our Design System has an invert feature, it should also be invertible.", "tokens": 184}
{"title": "Create a component | kickstartDS docs", "heading": "Structure", "content": "Before we start implementing, we'll want to define a first rough draft of our component API. Defining a name, a small description and a rough type, per property, goes a long way in keeping the focus on the core of your component. Let's keep using the TeaserCard as an example, with the following properties being the result of pinning down our rough idea: |Property||Type||Description| |Headline for the teaser card| |Body text for the teaser card| |(Optional) image to display as cover| |Show inverted version of card?| |Target that should be linked| Fields that should be required are marked with a *.", "tokens": 138}
{"title": "Create a component | kickstartDS docs", "heading": "2. Component Mapping", "content": "This is the part unique to this way of implementing a component (compared, for example, to adapting a component). We'll match the component to one, or more, kickstartDS base components... and potentially make some slight adjustments.", "tokens": 52}
{"title": "Create a component | kickstartDS docs", "heading": "Matching it", "content": "Matching one or more components means finding components that are part of kickstartDS that can cover your use case, or one part of it. This way you create your component by composition. For our TeaserCard, when looking through all of the existing kickstartDS base components (one great way of doing this is through our Storybook), we identify the TeaserBox as a great candidate. It: - has a topicthat can serve as our headline - takes textfor the body copy - already includes options for a cover ( image), and even some options for it ( ratio, imageSpacing) - can be inverted - and takes a Linkcomponent for link This seems to match really well!", "tokens": 144}
{"title": "Create a component | kickstartDS docs", "heading": "Adjustments", "content": "While just matching a component can already get you pretty far, oftentimes you'll want to make some more adjustments to really make everything fit for you. And while the properties may match up really well, there's still some translation to do to make it work. Comparing TeaserCard and TeaserBox... we don't have to do anything for text, inverted or image, as these already share a name and definition. In the case of headline we just have to rename the prop (from topic). And for target we simplify the existing link object to a single string property... hard coding the rest of the values in the process, while also renaming it.", "tokens": 136}
{"title": "Create a component | kickstartDS docs", "heading": "3. Component Creation", "content": "In the third and final step we'll get to actually create our component. We'll encode the component API by creating its JSON Schema, and create a React template matching our selected properties to the kickstartDS base component. JSON Schema definition We establish the structure of components by creating a JSON Schema for them, defining their component API in code. For an abridged version of that process, have a look at the TeaserCard again: TeaserBox base component This is the \"full\" TeaserBox component API / JSON Schema. We've just reduced the property definitions.", "tokens": 124}
{"title": "Create a component | kickstartDS docs", "heading": "Using multiple components", "content": "This process can also involve using properties from multiple components. For example when building one like the Storytelling component, using Headline, Button and RichText. You can either just merge properties on your root component, or group included components on their own property. Like adding a link to something, which maps to the Button component and some of its properties (as their own object in your JSON Schema). For the full version of creating the TeaserCard have a look at our guide \"Create TeaserCard component\". React template Now that our JSON Schema is defined, we'll automatically get matching TypeScript types for our component. We use those, combined with the types already included with the kickstartDS base component(s), to quickly hook up our set of properties to the mapped component(s). Using auto-complete, and TypeScript telling us about required properties in the mapped component(s), this is done in light speed! To learn more about the tooling that create those types for you, and how to hook it up, see part four of our \"Create your Design System\" guide. Let's continue showcasing this process using our TeaserCard, creating the component template:", "tokens": 243}
{"title": "Create a component | kickstartDS docs", "heading": "Add correct type to component", "content": "correct type to component We need to type our React component to use our JSON Schema, while also making sure native HTML attributes are passed correctly. For the TeaserCard this means also including HTMLAttributes as it maps to a  under the hood. Doing this allows users of your component to enjoy having the same auto-complete and safety when working with your Design System. #", "tokens": 81}
{"title": "Create a component | kickstartDS docs", "heading": "Add parameters to component", "content": "parameters to component Next we add all our components defined properties to its function signature. For properties having a default defined in your component API we add that default here, too. As we also want to pass through all the props not explicitly managed by us we sponge up ...props. ", "tokens": 64}
{"title": "Create a component | kickstartDS docs", "heading": "Destructure additional props", "content": "Coming to our component JSX, we start by passing down (destructuring) the props we're carrying through first. This ensures properties defined in our component API will always take precedence, because they're added after the general props.", "tokens": 51}
{"title": "Create a component | kickstartDS docs", "heading": "Glue component API to base component 1/3", "content": "The simplest cases of connecting props to the base component is when the name of the property is taken from the base component. We can just directly pass those without much thought.", "tokens": 42}
{"title": "Create a component | kickstartDS docs", "heading": "Glue component API to base component 2/3", "content": "In some cases we might have changed the name of a prop. In that instance, we just to have to wire up the renamed property to the originally named base components property.", "tokens": 43}
{"title": "Create a component | kickstartDS docs", "heading": "Glue component API to base component 3/3", "content": "Finally there might be fields where we're using a set of properties of the mapped component(s), but only expose one of those in our own component API... the rest get hard coded. That's the case with our target property, which maps to the link.href property of the TeaserBox. We hard code the required label property to Read more. ", "tokens": 81}
{"title": "Create a component | kickstartDS docs", "heading": "Adding a", "content": "ing a Provider The final part of creating our React component is adding a component Provider for it. As we've adapted a component here, we'll want to make sure that every time another component includes the base component, our own version of it gets used instead. If you're wondering what that Provider we've added last is all about, think about it like this: There may be other components you've built, that themselves use the base Button component by default. For example we might have our own TeaserCard component, based on the kickstartDS TeaserBox which includes a Button. As a means to not having to go through every combination of those component now, making sure our Button actually gets used, you can just change the default Button rendered by adding a single Provider once, instead. Learn more about Providers and React Context in our dedicated page about them. Or look at our \"Create your Design System\" guide, where we add the general setup for Providers. That one also includes some more details on this!", "tokens": 209}
{"title": "Create a component | kickstartDS docs", "heading": "Visual Studio Code component property quick-fix", "content": "Visual Studio Code has a great feature aiding in this workflow, with React components that include TypeScript types... like kickstartDS components do. When adding a \"bare\" component without props to your template, Visual Studio Code will offer you the option to Add missing attributes. This will automatically create all required options for your component. Now you just have to connect your own props to those, while hard-coding the ones you don't plan on exposing as part of your components component API. Just hover the squiggly, red line that should be decorating your component, and choose Quick Fix..., to get to that option (alternatively put your cursor on the component tag and hit Ctrl+.).", "tokens": 148}
{"title": "Create a component | kickstartDS docs", "heading": "Technical debt added", "content": "This way of creating components adds minimal technical debt to your Design System. Not much has been changed around, we just add a small layer on top of the original kickstartDS base component(s). Relevant underlying changes you'll have to look out for: - changes to the base components component API - removal of the base component(s) You're immune to underlying changes to: - the components template (both React, and the resulting HTML) - the design and layout (changes to CSS, SCSSand Design & Component Token) In the case of a changed component API, you should have a look at the corresponding CHANGELOG.md and potential notes in our matching migration guide. You'll probably just need to add a newly added field to your React template, and potentially your own component API if you want to use it. If a field was changed, that might also necessitate some adaption of your own version. Finally a removed field you're actually using would mean adding additional customization to regain that functionality. Have a look at our Headline example guide to see how you'd add your own, new property! Learn more about what we mean by technical debt here on the overview page of this section.", "tokens": 251}
{"title": "Create a component | kickstartDS docs", "heading": "Create", "content": "TeaserCard component In this example component guide we create the TeaserCard component, mapped to the TeaserBox component (part of the @kickstartDS/base module), to tease content in our Design System. We greatly simplify the Button to a single string props, and drastically reduce the rest of the options used, and offered, in our own adaptation of the TeaserBox. This is what the result looks like:", "tokens": 89}
{"title": "Layout | kickstartDS docs", "heading": "Layout", "content": "Layouting helps give context to your components, that were developed in isolation otherwise. They help present and structure your content, supporting consistency across your applications. Layouting helps give context to your components, that were developed in isolation otherwise. They help present and structure your content, supporting consistency across your applications.", "tokens": 63}
{"title": "Why we are creating kickstartDS", "heading": "Summary", "content": "*#tldr:* We want to support you to create one library of components, patterns and tokens to be used in any frontend you need to give your digital touch points a consistent interface. Even shorter: we want to **kickstart your design system** implementation. ðŸ˜Ž **Now you might wonder if or why you need that.**\nLet me provide some background. Jonas, founder of kickstartDS, and I have been working in the digital business all our professional life. We both have made our careers acting in different leading roles during the last two decades. Jonas from a development and tech perspective and I am from UX designers point of view. We both designed or coded patterns for the same things over and over again. Surely, we did rely on different frameworks in the past years. But never ever they met all our needs.\nIn the last years, when I was working for a huge software corporation I was involved in their design system initiative to help creating a unified library at scale, serving hundreds of interfaces. There was quite an energetic and enthusiastic team working on it and after a while we could proudly say that it was adapted globally. In the years before, any other attempt building a pattern library or design system language failed awfully. Mostly because of technical reasons, silo-thinking and poor possibilities to adapt into existing environments. And I heard about the same problems from a lot of people from my network.\nJonas on the other hand developed tons of websites and online shops served equally by dozens of different backend solutions, as you can imagine. In most cases the frontend parts were not quite re-usable for the next job. That already made him and the Ruhmesmeile team develop a pattern library which filled that gap being the base for new frontend projects.\n**The past and present**\nIn all those years we crossed our paths often. Both living and working in the lovely city of Bonn in Germany. We met on meetups, lean coffees, agile events or conferences. We even once shared the offices in very early times as we were working for different companies. Helping and supporting each other with knowledge and tips at any of these times.\nWhen I stepped out of my former Job as UX Strategy Manager, I was looking to join or even create my own startup. A place where I could continue to follow the holistic UX approach of developing a user centric business and a happy place to apply â€œnew workâ€ principles. At that time Jonas and I met again, exchanging on what we are aiming for currently. Ruhmesmeile, the digital agency behind kickstartDS, was hit hard by the Covid-19 crisis, clients stepped back from running projects and it was time to reform the organization.\nWith the ambitious idea of transforming it into a product-led company we decided to join forces and strive for the most modern solution to help SMEs and frontend development teams to build up their design systems putting\n**frontend first!**\nThey just wrote JAM because it sounds better than MJAðŸ˜‰\nMarkup is really important. Whenever new projects are planned people discuss about APIs, backends and other infrastructural topics, but never really about the the frontend. Because often the user interface is a given thing. It comes with the system or it can be put over in the the end. Nowadays experts talk more about JAMstack, where â€œJAMâ€ stands for JavaScript, API and Markup, again putting markup literally in the end. We want to turn this, making the markup something that really matters. Because it is what your users see and interact with. It needs to be seamlessly consistent granting a first class experience. Easily accessible, performant and framework agnostic. It should become the foundation of your design system.\n**We strongly believe in the power of design systems. **\nBecause it fosters a better collaboration and unites the work of design and dev teams and even further it heavily impacts these teamsâ€™ speed and ultimately the full user and customer experience.\nA content management system\nis for managing content,\nnot for content rendering!\nFredi Bach\nWe bundled our knowledge and expertise and wrapped it into kickstartDS. It contains best practice patterns and well tested web components. All the while following the principles of the Atomic Design methodology. Thatâ€™s why kickstartDS really is a ready to use framework, preventing developers from wasting time setting up the basics, while it enables designers to focus on neat UI challenges.\n**Today we are happy to announce the launch of our kickstartDS landing page**\nThis marks a huge milestone for us. We designed our own brand and to get all the things working whilst still finishing customer projects on the other storefront. This includes the work with two pilot customers using our kickstartDS frontend framework to build up their design system.\nBut this is only the starting point. In the last weeks we conducted user interviews to validate our assumptions on how to develop a successful frontend framework which has the ability to scale and to form its very own community. Also the landing page and this blog itself are helpful tools to validate and explore these ideas. We are going to continue our discovery putting you, our customer and user, into the center of our doing.\nTherefore we need your feedback and support! Use this blog, our website or grow into our discord community to start the conversation. We are eager to know what you think, take your wishes or to discuss anything else.\nThank you! ðŸ™ðŸ¼", "tokens": 1139}
{"title": "Bedrock | kickstartDS docs", "heading": "Components vs. Layout", "content": "Components are distinct units of interface, that shouldn't make any assumptions about where they're used. They should just use all the place given to them. This makes it necessary to add dedicated layout functionality to your Design System, to help users actually create pages and interfaces out of your offered components! We offer the Section for this when constructing websites, because it has some really nice convenience features for that! When more flexibility is needed we like to add Bedrock into the mix, which is easily connected to your Design Token set (for example your existing spacings) for a cohesive overall experience.", "tokens": 123}
{"title": "Bedrock | kickstartDS docs", "heading": "Tips & Tricks", "content": "With the switchAt property, precisely responsive layouts can be created. The witdh at which a layout will switch from a row to a column display can be set. Its supported in the Columns, Inline and Split Components.", "tokens": 50}
{"title": "kickstartDS â€“ Design System as a Service, trainings, workshops, etc.", "heading": "Design System services", "content": "kickstartDS is made for productivity. And so are we! We help you getting started. Use our design and consultancy services to support you introducing your design system, including onboarding, training or governance.", "tokens": 45}
{"title": "kickstartDS â€“ Design System as a Service, trainings, workshops, etc.", "heading": "Own a Design System without investing years of development", "content": "kickstartDS is the design system starter kit in which we have already solved all core challenges. No need to setup all the basics before start working on the real stuff. Removing all the assumptions on building your design system, and reduce the risk and effort required to get started. Let's talk about what the kickstartDS team can do for you.", "tokens": 81}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Design System Initiative", "content": "A Design System Initiative is the process an organization undertakes when considering to initialize a Design System. This generally occurs in a couple of steps where usually different kinds of workshops are run. It starts way before the pure design and development process itself by impacting many disciplines and stakeholders within the organization.", "tokens": 61}
{"title": "Design System Initiative | kickstartDS docs", "heading": "What are typical steps of a Design System Initiative?", "content": "We all know, that in every org there are stakeholders to be involoved, different kind of tools from design to development, existing rules and guidelines to consider and new principles to establish. Usable components to build, tokens to create, docs to write and much more. A Design System Initiative includes audits of existing interfaces and a user research process to gain as much insights to make better decisions during the initiative. It is important to know your stakeholders and their involvement as the implementation of a Design System often can become a political journey as well. In the past years, working with clients, the kickstartDS team worked out a workshop format which considers all the important steps and phases. It will be adapted to the individual needs of each company hiring us. We appreciate if you want to know more about our Design System Services here.", "tokens": 174}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Examplary Design System Initiative Process", "content": "During the initiative we usually run around seven to nine workshops including stakeholder mapping, exploring your current inventory as the baseline to synthesize to what should be real core components, in parallel we will sound out a strategy for the technical implementation and ultimately, we will identify a product serving as the potential pilot project.", "tokens": 67}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Kickoff workshop", "content": "The initiative starts with a â€œclassicâ€ kickoff workshop with your core team, or the people who currently own that responsibility. No need for C-level yet. During that first workshop we introduce our process and guide you through all the steps in more detail. On the one hand, that is for you to get familiar with us, and on the other hand of course for us to get to know you better.", "tokens": 87}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Stakeholder Mapping", "content": "You need buy-in from all important stakeholders, otherwise this or any other initiative initializing a Design System will not succeed. You might already know, that it not an individual responsibility: who need to take part in decisions, to people who just need to be informed on a regular cadence. We also want to identify the stakeholders who need to participate in the next workshops.", "tokens": 78}
{"title": "Design System Initiative | kickstartDS docs", "heading": "User Research Phase", "content": "We advice every organization to talk to as much people being involved in product development. Usually this is an on-going task throught the whole initiative process. Goal is to learn the needs, gains and pains from users and consumers of the Design System. Plus, you will better understand the existing design and development processes.", "tokens": 67}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Inventory Mapping", "content": "An important step is performing an analysis and understanding what you will be working with to identify the requirements and prepare a plan. Performing the analysis may consist of: - visual audit and collection of existing elements - identification of common design tokens - identification of common components - documentation and clusterization", "tokens": 59}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Component Identification", "content": "Using the results of the inventory mapping, in this step a comprehensive list of the core components will be synthezised, this might include buttons, dropdowns, tabs, icons, alerts, etc. to be specified through tokens and component properties ... to later match the needed layout recipes.", "tokens": 61}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Implementation Strategy", "content": "A very unique and important next step to each organization is explore which tech stack fits best, or what might be the preferred tool chain and build pipeline setup. Learning how future components can be integrated, which process and / or policy needs to be adopted, etc.", "tokens": 55}
{"title": "Design System Initiative | kickstartDS docs", "heading": "Identification of pilot", "content": "The Design System is made to support solving a real problems. It will neither solely succeed due to its comprehensiveness, nor its technical depth in implementation. The goal of this step is to identify a use case where to apply the Design System in a real environment without touching business-critical systems. This will foster engagement with the Design System at an early stage and it might help to also identify potential future advocates. If you want to read more in-depth what our workshop series includes feel free to visit this blog post.", "tokens": 107}
{"title": "Extend a component | kickstartDS docs", "heading": "Overview", "content": "Extending a component takes a kickstartDS component and expands upon its abilities. But in contrast to customizing a component we don't just add a property, often resulting in changing the markup / template of the involved component in the process. When extending, we add new capabilities to a component by composing it with other components. It involves the same rough steps as adapting a component, but differs from it when it comes to creating the React template. Instead of (only) using the base component directly as imported, and just re-wiring properties, we import and use multiple kickstartDS base components. We also wire our properties into those used different components as needed.", "tokens": 137}
{"title": "Extend a component | kickstartDS docs", "heading": "Customizing vs Extending", "content": "In both processes we add new features to a component, which results in it fitting one of the use cases we have in mind for our Design System. In the case of customizing a component, we either change the way a property of an existing kickstartDS base component behaves, or we add a new property to it altogether. But it's always a change that results in customizing the React component template, too. For example: adding a switchOrder property to the Headline. When extending a component, we take one existing kickstartDS base component and compose it with other kickstartDS base components to gain new functionality. We don't change the React component template in the process. For example: adding call-to-actions to our Section. Both processes can be combined in a component, if needed! This can also be part of creating a component, (see our TeaserCard component example for that). Or be used while customizing a component that expands on some kickstartDS base component (see our Section component example for that). To learn more about the different processes available to you when creating a component with kickstartDS, have a look at the overview page of this section.", "tokens": 244}
{"title": "Extend a component | kickstartDS docs", "heading": "Extension process", "content": "As with the adaptation process, the big assumption here is that you already have a kickstartDS base component in mind. But unlike in that one, we have some requirement or feature that is not covered by it. We almost have a match. Additionally, the change required involves adding other kickstartDS base components into the mix... not changing the involved components themselves. That would be covered by the customization process. Finding your component definition is still very simplified, we just have to add those properties not covered by the base component into the mix ourselves.", "tokens": 112}
{"title": "Extend a component | kickstartDS docs", "heading": "Adaptation process as a base line", "content": "If you've read our \"Adapt a component\" guide you probably already know this: This guide expects you to reduce the set of props offered by kickstartDS components, when used as a base component. We'll also skip over, or significantly shorten, parts already covered by that guide. If unsure about something, best cross-reference it! If you don't have a kickstartDS base component in mind yet, you're probably better served by our guide \"Create a component\". In that guide, you'll start off without a specific component in mind. This means defining a structure (someting you probably have an idea about already) first, and then mapping that structure to a fitting component second. We also have an example for this with \"Create Teaser Card component\". If you're still unsure, then maybe you're still missing a clear picture on what your components should look like. In that case, you should probably take a step back first, and maybe start a Design System Initiative to narrow down on what components you'll really need. There are two main steps in customizing a component: - Component definition, and - Component creation Let's get started!", "tokens": 242}
{"title": "Extend a component | kickstartDS docs", "heading": "1. Component definition", "content": "The extension process starts by defining a component API. As with the adaptation process this mainly means selecting a set of props from the pool of props available through your selected base component. But this time, we'll also add a requirement that's not covered by the base component. We'll use the Section component throughout this guide to illustrate concepts. This will not be an exhaustive example, though. For that have a look at our guide \"Extend Section component\". As our additional requirement, we'll want to be able to add some call-to-actions at the end of a section. That's not something the base Section can do, so we'll add this ourselves.", "tokens": 138}
{"title": "Extend a component | kickstartDS docs", "heading": "Purpose", "content": "There's not a lot different here when compared to the adaptation process. We just mainly keep close to the original purpose of our chosen kickstartDS base component. There should be an exception though, as we have a requirement on our mind that is not part of the component yet. This will probably be part of the purpose of our component. For our Section example, this could mean adding more places of putting call-to-actions being that requirement. Adding it to the Section allows adding one between every section of our website, which should be plenty! Using the Button as a component for those call-to-actions allows for re-use there, too.", "tokens": 135}
{"title": "Extend a component | kickstartDS docs", "heading": "Structure", "content": "We'll also still start by defining a rough draft of our component API here. Let's keep going with our Section component as an example. We're starting with the following properties: |Property||Type||Description| |Width of section to use| |Size of gutter to use| |Layout mode used for section contents| |Allowed content for the section| |Type of background| |Whether to invert the section| |Amount of spacing before the section| |Amount of spacing after the section| |Headline| |Additional Class| |Optional custom component identifier| For the detailed documentation have a look at the Section in our Storybook here: https://www.kickstartds.com/storybook/?path=/docs/base-section--content-boxes One potential set of props, it's also the one used in our guide \"Extend Section component\" if you're wondering, would be the following: |Property||Type||Description| |Headline for the section| |Width of section to use| |Size of gutter to use| |Layout mode used for section contents| |Allowed content for the section| |Style of section, influences background| |Amount of spacing before the section| |Amount of spacing after the section| |Whether to invert the section| |Call-to-actions to show| |Label for the Call to action| |Target for the Call to action| We took width, gutter, mode, content, spaceBefore, spaceAfter and inverted directly, and renamed background to style for our version of the Section. And crucially we add our own property ctas into the mix. We also reduce the complexity of headline significantly... from mapping to all of the Headline properties, to just a single string type prop setting its content. Required fields are marked with a *.", "tokens": 377}
{"title": "Extend a component | kickstartDS docs", "heading": "2. Component Creation", "content": "In the second and final step we'll get to actually create our component. We'll encode the component API by creating its JSON Schema, and create a React template matching our selected properties to the kickstartDS base component. While creating that template, we'll also import additional components and mix them with our original kickstartDS base component to implement our new requirements. JSON Schema definition We establish the structure of components by creating a JSON Schema for them, defining their component API in code. Like with customization we add our own, new property into the mix. For an abridged version of that process, have a look at the Section again (adding our own ctas property):", "tokens": 143}
{"title": "Extend a component | kickstartDS docs", "heading": "Extending multiple properties", "content": "This process can also involve extending a component by adding multiple properties to it. Just repeat all the steps for every property you'll need to add. In general: these guides are mainly meant as basic building blocks, that can be combined and remixed by you to create exactly what you need... even if that's something more complex than described in these basic guides here. For the full version of customizing a Section have a look at our \"Extend Section component\" guide. React template Now that our JSON Schema is defined, we'll automatically get matching TypeScript types for our component. We use those, combined with the types already included with the kickstartDS base component, to quickly hook up our set of properties to the original component. Using auto-complete, and TypeScript telling us about required properties in the base component, this is gets easy like squeezing a lemon! To learn more about the tooling that create those types for you, and how to hook it up, see part four of our \"Create your Design System\" guide. Let's continue showcasing this process using our Section, creating the component template:", "tokens": 229}
{"title": "Extend a component | kickstartDS docs", "heading": "Necessary imports", "content": "The main imports here are the kickstartDS base component Section, our own Button component, and our own components TypeScript types. We use our own Button here, with the assumption that that already got adapted by us. See the \"Adapt Button component\" guide to see how this could look like. But we could just as well have imported another (or even multiple other) kickstartDS base component(s) here.", "tokens": 88}
{"title": "Extend a component | kickstartDS docs", "heading": "Add correct type to component", "content": "We need to type our React component to use our JSON Schema, while also making sure native HTML attributes are passed correctly. For the Section this means including HTMLAttributes, as it maps to a  under the hood. Doing this allows users of your component to enjoy having the same auto-complete and safety when working with your Design System.", "tokens": 74}
{"title": "Extend a component | kickstartDS docs", "heading": "Add parameters to component", "content": "Next we add all our components defined properties to its function signature. For properties having a default defined in your component API we add that default here, too. As we also want to pass through all the props not explicitly managed by us we sponge up ...props.", "tokens": 59}
{"title": "Extend a component | kickstartDS docs", "heading": "Add the actual", "content": "JSX Unlike when directly adapting or creating a kickstartDS base component, we don't just use one base component. We recombine several different base components into a version that fits our needs instead. And unlike customizing, we don't change any kickstartDS base components underlying markup.", "tokens": 62}
{"title": "Extend a component | kickstartDS docs", "heading": "Combining base components 1/5", "content": "This is where we actually extend the original components scope. We apply a small trick here: if there are ctas defined, we'll just add a second section to the output.", "tokens": 42}
{"title": "Extend a component | kickstartDS docs", "heading": "Combining base components 2/5", "content": "Inside that second section, we render all the call-to-actions given to us as Buttons. We choose the variant rendered according to its index (first = primary, etc) in the list.", "tokens": 46}
{"title": "Extend a component | kickstartDS docs", "heading": "Adding a", "content": "Provider The final part of creating our React component is adding a component Provider for it. As we've adapted an existing kickstartDS base component here, we'll want to make sure that every time another component includes that base component, our own version of it gets used instead. If you're wondering what that Provider we've added last is all about, think about it like this: There may be other components you've built, that themselves use the base Section component by default. For example we might have our own Page component, based on the kickstartDS Page which includes a Section. As a means to not having to go through every combination of those component now, making sure our customized Section actually gets used, you can just change the default Section rendered by adding a single Provider once, instead. Learn more about Providers and React Context in our dedicated page about them. Or look at our \"Create your Design System\" guide, where we add the general setup for Providers. That one also includes some more details on this!", "tokens": 209}
{"title": "Extend a component | kickstartDS docs", "heading": "Visual Studio Code component property quick-fix", "content": "Visual Studio Code has a great feature aiding in this workflow, with React components that include TypeScript types... like kickstartDS components do. When adding a \"bare\" component without props to your template, Visual Studio Code will offer you the option to Add missing attributes. This will automatically create all required options for your component. Now you just have to connect your own props to those, while hard-coding the ones you don't plan on exposing as part of your components component API. Just hover the squiggly, red line that should be decorating your component, and choose Quick Fix..., to get to that option (alternatively put your cursor on the component tag and hit Ctrl+.).", "tokens": 148}
{"title": "Extend a component | kickstartDS docs", "heading": "Technical debt added", "content": "This way of creating components adds minimal technical debt to your Design System. Not much has been changed around, we just add a small layer on top of the original kickstartDS base component(s). Relevant underlying changes you'll have to look out for: - changes to the base components component API - removal of the base component(s) You're immune to underlying changes to: - the components template (both React, and the resulting HTML) - the design and layout (changes to CSS, SCSSand Design & Component Token) In the case of a changed component API, you should have a look at the corresponding CHANGELOG.md and potential notes in our matching migration guide. You'll probably just need to add a newly added field to your React template, and potentially your own component API if you want to use it. If a field was changed, that might also necessitate some adaption of your own version. Finally a removed field you're actually using would mean adding additional customization to regain that functionality. Have a look at our Headline example guide to see how you'd add your own, new property! Learn more about what we mean by technical debt here on the overview page of this section.", "tokens": 251}
{"title": "Extend a component | kickstartDS docs", "heading": "Extend", "content": "Section component In this example component guide we extend the Section component (as part of the @kickstartDS/base module) to use it for sections in our own Design System. We greatly simplify the Headline that's part of a Section normally, and add our own ctas property for adding call-to-action Buttons to a Section. This is what the result looks like:", "tokens": 82}
{"title": "Article Teaser recipe | kickstartDS docs", "heading": "Article Teaser recipe", "content": "We're currently finishing up this recipe! It's part of \"4. Components\" of the main \"Create your Design System\" guide. Please come back soon! We're currently finishing up this recipe! It's part of \"4. Components\" of the main \"Create your Design System\" guide. Please come back soon!", "tokens": 71}
{"title": "Setting up a working Design System in less than a day", "heading": "Summary", "content": "#tldr: In this post Iâ€™d like to demonstrate how easy it can be to kick off your own Design System, by just applying some design tokens, and adding a sprinkle of customization, using\n**kickstartDS**. And as weâ€™ve had some recent projects combining Sanity.io and Sanity Studio as the headless CMS, Next.js as the static site generator, and of course **kickstartDS** for the frontend, we thought: Might be a nice idea to simply re-build the Sanity.io landing page, as a showcase. So strap in and follow along!", "tokens": 133}
{"title": "Setting up a working Design System in less than a day", "heading": "Theme and Style application", "content": "In the first step, I wanted to apply some basic style attributes that will roughly dictate the look and feel of the page. I consider this a stepping stone, to establish a first path which further token application can continue down further. I asked myself: do I want something catchy with large fonts and lots of white space? Or do I need a slightly more dense experience, that uses spacing more efficiently, and focuses on delivering information? Have a look at the screenshot below, to get a feel for how this looks:", "tokens": 108}
{"title": "Setting up a working Design System in less than a day", "heading": "Token application", "content": "With all those macro design decisions out of the way, I could now move on with customizing the individual token values, which got generated for me from the theming input I defined before. This is where structured tokens can make or break a Design System. You want a clear and concise purpose for every base level token. What part of what component will be affected by this, seemingly insignificant, change I am making? It is important that this is conveyed through the semantic naming of each token. After configuring the token file for about two hours, the page was already remarkably close to the actual Sanity.io landing page: This is great news, because so far I havenâ€™t even had to customize a single line of code. Iâ€™ve just reused the existing structure to adapt a completely new design!", "tokens": 167}
{"title": "Setting up a working Design System in less than a day", "heading": "Token overrides", "content": "As seen, up until this point I could easily apply tokens without making any real design decisions, the Design System already made those for me, in a sensible and time-saving manner. However, a couple of components were still differing quite a bit from their real-world Sanity.io counterparts. This is mostly due to them having a different intention in this specific design application. A quick example: Letâ€™s say you need a Teaser Box component that is supposed to really catch the attention of the user. However, kickstartDS intends Teaser Boxes to be more of in-page navigational elements. Following this intention, the Teaser Box by default has tokens that are supposed to generate muted background colors. If you want to change the background color to a more intense color, you should pick a new token representative of your intention. In this case we need a background color that is intended to signal interaction, so a good pick would be something like: --background-color-interactive Within this step, Iâ€™ve also integrated some of the foreign (to kickstartDS) components into my new Design System. At that point the pages were starting to look almost identicalâ€¦ I had to re-check the URL to make sure what page I was on ðŸ˜‰", "tokens": 262}
{"title": "Setting up a working Design System in less than a day", "heading": "Customization", "content": "If you want to step outside the foundational layer of design tokens automatically available to you, and get really creative with your styling, you can always just as easily customize the components more directly. I used this to adjust the remaining minor differences the two pages still had. These were details you probably wouldnâ€™t even notice, if you were casually checking the page. But I still decided to adjust them. Et VoilÃ , Iâ€™ve got my very own Sanity.io landing page, fully responsive and entirely done in kickstartDS. And a matching Design System to boot ðŸš€ All it took was: - a couple of hours of work, - 58 token overrides and - 70 lines of CSS Check out the resulting page for yourself: https://bit.ly/3uGievY And for reference, the original: https://www.sanity.io/ Wouldnâ€™t it be nice to now also get a free, ready-to-use headless CMS integration for our newly created page, too? Start to customize with a nice, focussed editor interfaceâ€¦ starting to build out our website? If only we had such a miraculous solutionâ€¦ and I wonder what headless CMS vendor would fit such a descrition ðŸ˜ Btw, did I mention? Thereâ€™ll be a part 2 to thisâ€¦ tell us your guess on what that could possibly entail, for example on Twitter!", "tokens": 291}
{"title": "4. Add Components | kickstartDS docs", "heading": "4. Add Components", "content": "Now we'll get to the meat of it... adding our first set of components based on kickstartDS. Which ones you'll utimately need, and subsequentially build, can vary wildly based on your specific Design System needs. We'll add some exemplary ones now, to illustrate the main ways on offer to do this: Adding a Buttoncomponent based on @kickstartds/base/lib/button, to show the process of adaptingan existing component Adding a Headlinecomponent based on @kickstartds/base/lib/headline, to show the process of customizingan existing component Adding a TeaserCardcomponent based on @kickstartds/base/lib/teaser-box, to show the process of creatinga new component Adding a Sectioncomponent based on @kickstartds/base/lib/section, to show the process of extendingan existing component We'll then build our first recipe, using all of the added components to create a teaser component for articles. Recipes are like loose blueprints, that should serve as an inspiration for how components can be combined and remixed, to fit a multitude of use cases! To learn more about recipes, and different kinds of components, we recommend reading Brad Frosts excellent article on \"design system components, recipes, and snowflakes\". And to bring it full circle, we will add that component to our Welcome page to tease the main pages of our Storybook, as a quick entry for users! Feel free to change these examplary components being implemented around to something you'll actually need instead, if you happen to have something in mind already. We'll try adding some components that are commonly needed, so it should be a good starting point either way! If you want to take a deeper dive on finding your first component set right now, jump over to our guide around the Design System Initiative, and come back to this point later! And if all of this feels overwhelming, or like too much work for you to do on your own or your team, feel free to also have a look at the services we offer around Design Systems and kickstartDS. They're in no way a necessity to use kickstartDS, but we're always happy to help in getting your first Design System, a Design System Initiative or internal DesignOps team off the ground!", "tokens": 472}
{"title": "4. Add Components | kickstartDS docs", "heading": "Establish structure", "content": "Before we get into the components themselves, we need to do a last bit of setup that will be needed by all of them. This includes setting up some React constructs like Providers, that ensure our own components get used everywhere (including when part of another component), hooking up JavaScript and CSS / SCSS integration and compilation, making sure our TypeScript types are available for users of our components, and finally creating some new scripts entries in package.json to improve our own developer experience when working on the Design System.", "tokens": 107}
{"title": "4. Add Components | kickstartDS docs", "heading": "Add component", "content": "Providers All components in kickstartDS come with their own Provider. This enables you to switch component implementations at will. From sweeping changes like switching all Buttons for your own custom Button, including the ones that are part of other, bigger components, or surgical changes like just replacing the Button that gets used in a Teaser Box specifically. To have that benefit for our own users, too, we'll add the same general structure to our Design System here.", "tokens": 95}
{"title": "4. Add Components | kickstartDS docs", "heading": "Aggregate global", "content": "Providers We first create a file Providers.jsx at src/components/. This will import all of our global component providers, which are mainly the ones deep replacing kickstartDS components, and export a single member that can be used to import and integrate all providers at once, reducing the need for copy & pasted code. And as we haven't created it before, it's now time to create src/components: _1mkdir -p src/components ... create the file... _1touch src/components/Providers.jsx ... and add the following content to it: For now this will not do anything, but we'll hook it up to Storybook in the next step... and then subsequently build it up when adding components.", "tokens": 160}
{"title": "4. Add Components | kickstartDS docs", "heading": "Update", "content": ".storybook/preview.js Integration with Storybook is done in .storybook/preview.js again, as this is related to how components are rendered / previewed. Just add the following lines to it:", "tokens": 49}
{"title": "4. Add Components | kickstartDS docs", "heading": "Add", "content": "unpack decorator to Storybook While at it, we also add the unpack decorator to our Storybook. This decorator is provided by kickstartDS as part of @kickstartDS/core, and is used to unpack arguments provided to the component, rendered as part of a Story.", "tokens": 65}
{"title": "4. Add Components | kickstartDS docs", "heading": "code formatting bug", "content": "Attention: there's a code formatting bug with the code above. The following line window._ks.radio.on(\"*\", myActions.radio); should read window._ks.radio.on(\"\", myActions.radio); We'll hopefully be able to fix this soon! This concludes the Storybook* integration!", "tokens": 73}
{"title": "4. Add Components | kickstartDS docs", "heading": "pack, unpack, story args... huh?", "content": "kickstartDS offers helpers you can use to automatically configure your stories Storybook Controls. If used, you'll automatically get Controls and respective documentation based on your component API ( JSON Schema). Because nesting Controls isn't straight-forward, we've written those helpers ( pack, unpack) that take complex JSON, and, as the name suggests, pack those into an object with flattened keys compatible with the Controls addon (much like a library like flat does it).", "tokens": 102}
{"title": "4. Add Components | kickstartDS docs", "heading": "Add aggregated", "content": "aggregated schema script We add a command aggregating schema dereferencing and props generation for us in schema. run-p schema:* runs all commands prefixed with schema: in parallel.", "tokens": 44}
{"title": "4. Add Components | kickstartDS docs", "heading": "Add additional", "content": "additional watch tasks We now add watch tasks for schema and dictionary, using chokidar. schema: regenerates component API and TypeScript types on schema change dictionary: regenerates your CSS Custom Properties on Style Dictionarychange", "tokens": 48}
{"title": "4. Add Components | kickstartDS docs", "heading": "Finished", "content": "package.json Your package.json should look like this now! Feel free to start your Storybook now by just calling the start command: _1yarn start Isn't that convenient? ðŸ˜… Now everything is set up to start the fun part: adding components!", "tokens": 57}
{"title": "4. Add Components | kickstartDS docs", "heading": "Component implementation", "content": "We roughly see four different ways of adding a component to your Design System, in the context of kickstartDS. Those are most definitely not exhausting, but they serve as a good introduction: Adapta component ( Button) Createa component ( Headline) Customizea component ( TeaserCard) Extenda component ( Section) We'll follow one guide for each of those general workflows, resulting in the four planned components being added to our Design System. In the real world the truth is not that clear cut, at least most of the time. Typically you'd probably have a mix of those scenarios. Feel free to just add the components as shown in the guides for now, every if you'll change those later for real use. You can always adapt them further at a later point! You can also skip the exhaustive component example guides, if you just want to copy & paste along. We'll always include the respective code snapshots to do that! To learn about finding components to implement, have a look at the Design System Initiative guide.", "tokens": 212}
{"title": "4. Add Components | kickstartDS docs", "heading": "1. Adding our own", "content": "Button component To demonstrate the first, and easiest, way of adding a component to your own Design System we will adapt a Button component. This also serves as an example for adapting a component, where we mostly take a component directly from kickstartDS, while still finding our own, often more restrictive, component API for it. The result will look like this: Choose your own adventure: |Path||Link| |Follow the Component example guide||Adapt | |Read the process description||Adapt a component| |Look at the Code Sandbox||see below| See the completed example in a Code Sandbox below: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 150}
{"title": "4. Add Components | kickstartDS docs", "heading": "2. Adding our own", "content": "Headline component The second way of adding a component involves much of the same steps we've seen for the Button already. That's not a coincidence, as every process should involve following the steps outlined by the adaptation process. It's like a base process that gets inherited, because reducing the offered properties into your own component API is essential! In addition to that process we customize the component with this one. We add our own property switchOrder to switch the order of headline and subheadline. Not a feature of the kickstartDS base Headline normally. This results in us having to change the React template, which makes this customizing, compared to example to extension. We also add RTE-like rendering capabilities to the content fields. We have a dedicated guide for customization, too, explaining the concepts a bit more in-depth. The result will look like this: Choose your own adventure: |Path||Link| |Follow the Component example guide||Customize | |Read the process description||Customize a component| |Look at the Code Sandbox||see below| See the completed example in a Code Sandbox below: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 255}
{"title": "4. Add Components | kickstartDS docs", "heading": "3. Adding our own", "content": "TeaserCard component For the third way of adding a component we add a TeaserCard to our Design System. This is not a component we will build while having a kickstartDS base component in mind, yet. Instead, we'll start with \"just\" the requirements (this really is the most common scenario, btw., it just builds nicely on the two before). We'll then map those to a component second, and proceed like for the others! This serves as a great example of the creation process. We create something new, but still benefit from all the underlying Design System goodness. The result will look like this: Choose your own adventure: |Path||Link| |Follow the Component example guide||Create | |Read the process description||Customize a component| |Look at the Code Sandbox||see below| See the completed example in a Code Sandbox below: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 206}
{"title": "4. Add Components | kickstartDS docs", "heading": "4. Adding our own", "content": "Section component For the last component, we'll add a Section that can be used to combine all of the components we've added before to create our first composable use cases! We take it from the kickstartDS base component pretty much verbatim. But we expand upon its capabilities by adding the option to every Section to add as many call-to-actions to it that get displayed at the end of the Section. Also not a feature currently offered by kickstartDS Sections. This showcases our last way of adding components nicely, namely extending a component. We take existing components and just combine and re-mix them to cover new use cases. This can be done completely without changing any markup... with just composition! The result will look like this: Choose your own adventure: |Path||Link| |Follow the Component example guide||Extend | |Read the process description||Customize a component| |Look at the Code Sandbox||see below| See the completed example in a Code Sandbox below: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 231}
{"title": "4. Add Components | kickstartDS docs", "heading": "Adding an article teaser recipe", "content": "We're currently still working on this guide, it will follow soon! We will combine all of the added components into a recipe here. A recipe is not quite a component (it doesn't have its own component API for example), but more of an inspiration to your Design Systems users. They show how more complex, but slightly one-off, components can be built by just combining existing stuff in smart ways!", "tokens": 88}
{"title": "4. Add Components | kickstartDS docs", "heading": "Result", "content": "Following those examples is mostly meant as an illustration of the basic building blocks of adding a component. They can be combined, mixed and scaled freely! We'll start adding more advanced component example guides for that, too! This concludes adding components to our Design System. It's also the last of the 5 parts currently documented. We're in the process of finishing the fifth section about publishing your Design System. So stay tuned for that!", "tokens": 89}
{"title": "4. Add Components | kickstartDS docs", "heading": "Code Sandbox", "content": "See the result of this step in the Code Sandbox below. It's showing specifically the result after this step. You can also view this on Github directly in the ds-guide repository, there's a branch for every step... and we're currently on the branch step/4 in the guide: Toggle the file browser with the hamburger icon at the top left, or open it directly in your browser.", "tokens": 86}
{"title": "Design & Component Token | kickstartDS docs", "heading": "Design Token Integration", "content": "To display your Design Token set in Storybook we use and recommend the storybook-design-token addon. We also include a format for Style Dictionary, which outputs your Design Token set into a specific CSS Custom Properties format, annotated with the token presenters as needed by storybook-design-token. For an example on how this needs to be configured, have a look at the chapter \"3. Configure Storybook\" of our \"Create your Design System\" guide. We also provide ready-to-use docs pages for Storybook, using the DesignTokenDocBlock by storybook-design-token, mapped to our semantic Design Token categories and values. You can find those in our mono-repository, or have a look at them in action on our own hosted Storybook (category DESIGN TOKENS in the sidebar).", "tokens": 176}
{"title": "Design & Component Token | kickstartDS docs", "heading": "Component Token integration", "content": "Our storybook-adddon-component-tokens addon displays CSS Custom Properties used inside a component directly as part of your Storybook. It extracts those values using custom-property-extract, and then converts those to a format displayed alongside your component. This helps in making token associations explicit (which Component Token uses what Design Token under the hood), while also illustrating the layering of tokens inside a single component (for example to generate style variations). You can also interact with those variables, for example changing some colors around. Those changes get persisted in your browser session, so you can easily verify if your changes work in the context of other components, too (the new color on that button might not be accessible when used in you Hero component, after all). There's currently no way of persisting changes made in the browser in this way, but we're thinking about this. Let us know if that's something that you'd be interested in! Show me a working demo (click on the Component Tokens addon tab) View the addon on Github: https://github.com/kickstartDS/storybook-addon-component-tokens Or directly on Storybooks page: https://storybook.js.org/addons/@kickstartds/storybook-addon-component-tokens/", "tokens": 271}
{"title": "Design & Component Token | kickstartDS docs", "heading": "Getting started", "content": "_1yarn add --dev @kickstartds/storybook-addon-component-tokens Enable the addon in .storybook/main.js: _3module.exports = {_3addons: ['@kickstartds/storybook-addon-component-tokens'],_3}; To use it inside MDX, or when customising the docs page: _1import { CssPropsBlock } from '@kickstartds/storybook-addon-component-tokens';", "tokens": 113}
{"title": "Design & Component Token | kickstartDS docs", "heading": "Usage", "content": "Include your component tokens, the addon will apply and document this automatically. _13export default {_13title: \"Simple Component\",_13parameters: {_13cssprops: {_13\"--color-primary\": [_13{_13value: \"#ff017d\",_13selector: \":root\"_13}_13]_13}_13},_13} as Meta; For a more detailed description of this integration, have a look at part three of our \"Create your Design System\" guide.", "tokens": 117}
{"title": "Styling | kickstartDS docs", "heading": "Summary", "content": "icon-arrow-down\nicon-arrow-left\nicon-arrow-right\nicon-arrow-up\nicon-browser\nicon-chevron-down\nicon-chevron-left\nicon-chevron-right\nicon-chevron-up\nicon-close\nicon-contact\nicon-date\nicon-download\nicon-email\nicon-facebook\nicon-first-page\nicon-home\nicon-info\nicon-instagram\nicon-last-page\nicon-linkedin\nicon-login\nicon-logout\nicon-map\nicon-move\nicon-person\nicon-phone\nicon-place\nicon-print\nicon-refresh\nicon-search\nicon-share\nicon-stackshare\nicon-star-outline\nicon-star\nicon-time\nicon-twitter\nicon-upload\nicon-whatsapp\nicon-xing\nicon-youtube\nicon-zoom\nSkip to main content\nFollow our main guide to learn how you can \"Create your Design System\" in just 5 steps:\nOpen guide\nGetting Started\nFoundations\nIntegration\nGuides\nConcepts\nFAQ\nRoadmap\nFeedback\nGitHub\nComponents\nStyling\nStyling\nThis foundations page will follow soon, please have a look back here soon!\nPrevious\nComponent API\nNext\nTemplate", "tokens": 298}
{"title": "Generated Controls | kickstartDS docs", "heading": "Generated Controls", "content": "Using Controls, and the Controls addon, is one of the main reasons for choosing Storybook. They really help bring your components to life! To quote from the source: Storybook Controls gives you a graphical UI to interact with a component's arguments dynamically without needing to code. It creates an addon panel next to your component examples ('stories'), so you can edit them live. Just that this (normally) comes with one caveat: You'll have to decide to either: - Live with the inferred defaults the addon automatically creates for you (but this is uncurated), or - explicitly define controls for your properties yourself ( Storybookaccounts for that, but it's extra work), or finally - just disable Controlsto reduce potential confusion", "tokens": 151}
{"title": "Generated Controls | kickstartDS docs", "heading": "Usage with", "content": "kickstartDS If you think about it, everything that should be available in your Controls is already defined by your respective component API, anyway. This is why we've written some helpers that do this for you... as long as a valid JSON Schema is found for your component, it will automatically be decorated with documentation for all its properties in Storybook, and in your Controls addon.", "tokens": 80}
{"title": "Generated Controls | kickstartDS docs", "heading": "Features", "content": "Using our helpers provides the following conversion for your JSON Schema: - Add type of Controlbased on JSON Schemafield type - Add title, description and meta info like required - Automatically flatten nested structures for Storybook Argscompatibility - Use that information to intelligently group Controlsfor a better overview", "tokens": 66}
{"title": "Generated Controls | kickstartDS docs", "heading": "Implementation", "content": "You can find the implementation in our Github mono-repository: https://github.com/kickstartDS/kickstartDS/tree/next/packages/components/core/source/storybook/helpers.js There are four functions exported to be used in your own stories for Storybook Controls: |Function||Description| |getArgsShared||Takes a |JSON Schema and returns Args and ArgTypes |pack||Takes a component instance (| |unpack||Takes a flattened instance and returns the complete | |unpackDecorator||Decorator you can use to add |", "tokens": 133}
{"title": "Generated Controls | kickstartDS docs", "heading": "Integration", "content": "Integration works by adding the unpackDecorator to all of your stories in .storybook/preview.js: This ensures props passed down to our components by Storybook Args get converted back to their original, deep JSON structure by default. And in stories themselves you'll have to use getArgsShared to get Args and ArgTypes to configure your components. See the example below, on how that would look for a Button story.", "tokens": 95}
{"title": "Generated Controls | kickstartDS docs", "heading": "Component", "content": "Let's take the Button as an example. This is the JSON Schema we've defined for an adapted version of it, as part of the \"Create your Design System\" guide: Using our helpers inside your story files automatically generates the following Controls for our Button, while also generating the full documentation block for the Docs view", "tokens": 68}
{"title": "Generated Controls | kickstartDS docs", "heading": "Pack arguments given to story instances", "content": "Finally, we'll need to pack options given to our stories / components. Have a look at the \"Adapt Button component\" guide for a full version of the Button component shown here.", "tokens": 45}
